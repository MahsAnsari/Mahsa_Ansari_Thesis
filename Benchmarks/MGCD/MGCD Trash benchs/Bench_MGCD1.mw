<?xml version="1.0" encoding="UTF-8"?>
<Worksheet>
<Version major="2025" minor="1"/>
<Label-Scheme value="2" prefix=""/>
<View-Properties presentation="false" autoexpanding_sections="true" UserProfileName="Maple Default Profile" NumericFormat-ApplyInteger="true" NumericFormat-ApplyRational="true" NumericFormat-ApplyExponent="false" editable="true">
</View-Properties>
<MapleNet-Properties prettyprint="3" compactdisplay="false" preplot="" helpbrowser="standard" echo="1" scientificx="true" unitattributes="&quot;fontweight&quot; = &quot;bold&quot;" writeScrollableTableTypesetting="true" imaginaryunit="I" longdelim="true" elisiontermsthreshold="10000" elisiondigitsbefore="100" plotdevice="inline" elisiontermsbefore="100" historytimestamp="false" indentamount="4" plotoutput="terminal" screenpixelheight="1080" rtablesize="[10, 10]" useclientjvm="true" format="worksheet" labelwidth="20" postplot="" typesetting="extended" elisiondigitsthreshold="10000" ansilprint="false" labelling="true" verboseproc="1" latexwidth="8.0" warnlevel="3" displayprecision="-1" elisiondigitsafter="100" errorbreak="1" plotoptions="" plotdriver="opengl" quiet="false" elisiontermsafter="100" screenwidth="79" ansi="false" ansicolor="[]" showassumed="1" trailingsemicolon="true" errorcursor="false" screenheight="25" prompt="&gt; " ShowLabels="true"/>
<Styles>
<Font name="Heading 1" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Warning" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="2D Output" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Heading 4" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Line Printed Output" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Heading 2" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="16" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Maple Output" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="2D Inert Output" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[144,144,144]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Heading 3" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="14" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Diagnostic" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[40,120,40]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Ordered List 1" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Maple Input" background="[255,255,255]" bold="true" executable="true" family="Courier New" foreground="[120,0,14]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Text Output" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Ordered List 2" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Ordered List 3" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Ordered List 4" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Ordered List 5" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Annotation Title" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Header and Footer" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="HyperlinkError" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="true" strikethrough="false" placeholder="false"/>
<Font name="Atomic Variable" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[175,0,175]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="HyperlinkWarning" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="true" strikethrough="false" placeholder="false"/>
<Font name="Dictionary Hyperlink" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[147,0,15]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" strikethrough="false" placeholder="false"/>
<Font name="2D Math" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Bullet Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Maple Plot" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Annotation Text" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="List Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Dash Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="2D Input" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Error" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Title" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Text" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Normal" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Caption Reference" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Code" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Maple Input Placeholder" background="[255,255,255]" bold="true" executable="true" family="Courier New" foreground="[200,0,200]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="true"/>
<Font name="Equation Label" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Author" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Hyperlink" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,128,128]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" strikethrough="false" placeholder="false"/>
<Font name="Caption Text" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Layout name="Heading 1" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="4" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Warning" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 4" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Line Printed Output" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="any" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 2" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="2" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Maple Output" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.3" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 3" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Diagnostic" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="any" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Ordered List 1" alignment="left" bullet="numeric" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Text Output" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="newline" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Ordered List 2" alignment="left" bullet="alphabetic" firstindent="0" leftmargin="36" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Ordered List 3" alignment="left" bullet="roman" firstindent="0" leftmargin="72" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Ordered List 4" alignment="left" bullet="ALPHABETIC" firstindent="0" leftmargin="108" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Ordered List 5" alignment="left" bullet="ROMAN" firstindent="0" leftmargin="144" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Annotation Title" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="12" spacebelow="12" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="HyperlinkError" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="HyperlinkWarning" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Bullet Item" alignment="left" bullet="dot" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Maple Plot" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="List Item" alignment="left" bullet="indent" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Dash Item" alignment="left" bullet="dash" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Error" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Title" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="12" spacebelow="12" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Normal" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Author" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="8" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Pencil-style name="Pencil 1" pen-color="[0,0,0]" pen-height="1.0" pen-width="1.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 2" pen-color="[0,0,255]" pen-height="1.0" pen-width="1.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 3" pen-color="[0,0,0]" pen-height="3.0" pen-width="3.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 4" pen-color="[0,0,255]" pen-height="3.0" pen-width="3.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 5" pen-color="[255,0,0]" pen-height="5.0" pen-width="5.0" pen-opacity="1.0"/>
<Highlighter-style name="Highlighter 5" pen-color="[255,255,0]" pen-height="48.0" pen-width="48.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 3" pen-color="[51,255,0]" pen-height="24.0" pen-width="24.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 4" pen-color="[0,255,255]" pen-height="32.0" pen-width="32.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 1" pen-color="[255,153,255]" pen-height="12.0" pen-width="8.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 2" pen-color="[255,204,0]" pen-height="14.0" pen-width="14.0" pen-opacity="0.8"/>
</Styles>
<Startup-Code startupcode=""/>
<Task-table>
	<Task-category name="&lt;default&gt;"/>
</Task-table>
<Task/>
<Group hide-input="false" labelreference="L113" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">restart;
with(PolynomialTools):
interface(rtablesize=40):
with(ExcelTools):
<Font foreground="[0,128,128]">#LAMinpolyMaple file contains the LAMinpoly algorithm to get M(z).
#PhigammaMaple file maps phi_p(f1), phi_p(f2) to their corresponding polynomials in Z_p[z]/&lt;M(z)&gt; using phi_{gamma} isomorphism.
#Get contains getvars, getring,..., and conv2cons for basic operations regarding the ring and extensions
#MonOpMaple 
#ContMaple
#PGCD
#MGCD
</Font></Text-field>
</Input>
</Group>
<Group hide-input="false" labelreference="L226" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[0,128,128]">#Read subrutines</Font>
currentdir():
read &quot;Get&quot;; read &quot;LAMinpolyMaple&quot;; read &quot;PhigammaMaple&quot;; read &quot;MonOpMaple&quot;;  read &quot;PGCDMaple&quot;; read &quot;MGCD1&quot;; read &quot;Bench.mpl&quot;;
RDP:=Algebraic:-RecursiveDensePolynomials;</Text-field>
</Input>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUkjbWlHRiQ2JVEkUkRQRicvJSdpdGFsaWNHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ2l0YWxpY0YnLUkjbW9HRiQ2LlEpJkFzc2lnbjtGJy9GM1Enbm9ybWFsRicvJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHRj0vJSlzdHJldGNoeUdGPS8lKnN5bW1ldHJpY0dGPS8lKGxhcmdlb3BHRj0vJS5tb3ZhYmxlbGltaXRzR0Y9LyUnYWNjZW50R0Y9LyUnbHNwYWNlR1EsMC4yNzc3Nzc4ZW1GJy8lJ3JzcGFjZUdGTC8lKWVxdWFsaXR5R0Y9LUYsNiVRKkFsZ2VicmFpY0YnRi9GMi1GNjYuUS8mY29sb247Jm1pbnVzO0YnRjlGO0Y+RkBGQkZERkZGSC9GS1EmMC4wZW1GJy9GTkZYRk8tRiw2JVE6UmVjdXJzaXZlRGVuc2VQb2x5bm9taWFsc0YnRi9GMkY5">LV9JLFR5cGVzZXR0aW5nRzYkJSpwcm90ZWN0ZWRHSShfc3lzbGliRzYiSSxtcHJpbnRzbGFzaEdGKDYkNyM+SSRSRFBHRihJOlJlY3Vyc2l2ZURlbnNlUG9seW5vbWlhbHNHNiQvSSttb2R1bGVuYW1lR0YoSSpBbGdlYnJhaWNHRiVGJjcjRi4=</Equation></Text-field>
</Output>
</Group>
<Group hide-input="false" labelreference="L339" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font opaque="true" size="16" background="[255,255,153]" foreground="[0,0,255]">#1</Font><Font opaque="true" background="[255,255,153]" foreground="[0,0,255]">:Number of Variables changing from 1 to 5</Font></Text-field>
</Input>
</Group>
<Group hide-input="false" labelreference="L711" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font opaque="true" background="[204,255,204]">flagalg:=MGCD; #Using RDP=Algebraic:-RecursiveDensePolynomials
vars:=</Font><Font foreground="[128,0,0]">[seq(</Font>1..4)];<Font opaque="true" background="[204,255,204]">
</Font>R:=<Font foreground="[128,0,0]">Benchmain(flagalg,vars</Font>,24,12,32,5,0);
Export(R,&quot;MGCD.xls&quot;,&quot;#var&quot;);</Text-field>
</Input>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUkjbWlHRiQ2JVEoZmxhZ2FsZ0YnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy1JI21vR0YkNi5RKSZBc3NpZ247RicvRjNRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y9LyUpc3RyZXRjaHlHRj0vJSpzeW1tZXRyaWNHRj0vJShsYXJnZW9wR0Y9LyUubW92YWJsZWxpbWl0c0dGPS8lJ2FjY2VudEdGPS8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkwvJSllcXVhbGl0eUdGPS1GLDYlUSVNR0NERidGL0YyRjk=">LV9JLFR5cGVzZXR0aW5nRzYkJSpwcm90ZWN0ZWRHSShfc3lzbGliRzYiSSxtcHJpbnRzbGFzaEdGKDYkNyM+SShmbGFnYWxnR0YoSSVNR0NER0YoNyNGLg==</Equation></Text-field>
</Output>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUkjbWlHRiQ2JVEldmFyc0YnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy1JI21vR0YkNi5RKSZBc3NpZ247RicvRjNRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y9LyUpc3RyZXRjaHlHRj0vJSpzeW1tZXRyaWNHRj0vJShsYXJnZW9wR0Y9LyUubW92YWJsZWxpbWl0c0dGPS8lJ2FjY2VudEdGPS8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkwvJSllcXVhbGl0eUdGPS1JKG1mZW5jZWRHRiQ2Ji1GIzYsLUkjbW5HRiQ2JFEiMUYnRjktRjY2LlEiLEYnRjlGOy9GP0YxRkBGQkZERkZGSC9GS1EmMC4wZW1GJy9GTlEsMC4zMzMzMzMzZW1GJ0ZPLUZXNiRRIjJGJ0Y5RlotRlc2JFEiM0YnRjlGWi1GVzYkUSI0RidGOS8lK2ZvcmVncm91bmRHUShbMCwwLDBdRicvJSlyZWFkb25seUdGPUY5RjkvJSVvcGVuR1EnJmxzcWI7RicvJSZjbG9zZUdRJyZyc3FiO0YnRjk=">LV9JLFR5cGVzZXR0aW5nRzYkJSpwcm90ZWN0ZWRHSShfc3lzbGliRzYiSSxtcHJpbnRzbGFzaEdGKDYkNyM+SSV2YXJzR0YoNyYiIiIiIiMiIiQiIiU3I0Yu</Equation></Text-field>
</Output>
<Output><Text-field style="Line Printed Output" layout="Line Printed Output">MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   1.359 12451562|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.015  25292| A := semi(A1);
  12 |    1   0.000  24705| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      7| Xpoly := X[1 .. k];
  18 |    1   0.000     20| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000   1528| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   3734| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   16   0.015  40887|     do
  26 |   16   0.000  11117|         p := nextprime(p);
  27 |   16   0.000      0|         lcmintest := true;
  28 |   16   0.000      0|         for i to m do
  29 |   64   0.000   1102|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   16   0.000     64|     st := time();
  32 |   16   0.156 1064605|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   16   0.000    256|     pt := pt+time()-st;
  34 |   16   0.000  39579|     Rand := rand(1 .. p-1);
  35 |   16   0.000     48|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   16   0.000    699|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   16   0.000   1184|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   16   0.000  83085|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   16   0.000     64|         st := time();
  42 |   16   0.377 2321266|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   16   0.000    256|         laminpolytime := laminpolytime+time()-st;
  44 |   16   0.000     48|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   16   0.000     64|         M, phimatrix, invphimatrix := LA;
  47 |   16   0.000     64|         st := time();
  48 |   16   0.311 3289422|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   16   0.265 3279389|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   16   0.000    256|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   16   0.000     64|     st := time();
  52 |   16   0.080  53658|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   16   0.000    256|     pgcdtime := pgcdtime+time()-st;
  54 |   16   0.000    100|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   16   0.000   1738|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   16   0.000     48|     if 1 &lt; m then
  62 |   16   0.000     64|         st := time();
  63 |   16   0.064 406552|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   16   0.000    256|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   16   0.000     64|     st := time();
  66 |   16   0.000   1591|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   16   0.000  60408|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   16   0.000    132|     lmt := lmt+time()-st;
  69 |   16   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   15   0.000      0|         summon := lmCp+minmon;
  76 |   15   0.000  30409|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   15   0.000  26759|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   15   0.000    180|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   15   0.000    222|             H := [op(H), Cp];
  84 |   15   0.000    207|             Np := [op(Np), p];
  85 |   15   0.000     60|             st := time();
  86 |   15   0.060 366766|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   15   0.000    180|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   16   0.000     64|     st := time();
  89 |   16   0.016 1174405|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   16   0.000    196|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   16   0.000     48|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2452|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000   1070|         do
  96 |    1   0.000     10|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.000  72287|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000  62436|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     12|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   0.953 14812889|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.000  24705| A := semi(A1);
  12 |    1   0.000  24705| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      7| Xpoly := X[1 .. k];
  18 |    1   0.000     20| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    577| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   1673| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   16   0.000  40880|     do
  26 |   16   0.000   1514|         p := nextprime(p);
  27 |   16   0.000      0|         lcmintest := true;
  28 |   16   0.000      0|         for i to m do
  29 |   64   0.000   1055|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   16   0.000     64|     st := time();
  32 |   16   0.079 1063008|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   16   0.000    256|     pt := pt+time()-st;
  34 |   16   0.000  39611|     Rand := rand(1 .. p-1);
  35 |   16   0.000     48|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   16   0.000    719|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   16   0.000   1184|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   16   0.016  83099|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   16   0.000     64|         st := time();
  42 |   16   0.126 2212994|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   16   0.000    232|         laminpolytime := laminpolytime+time()-st;
  44 |   16   0.000     48|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   16   0.000     64|         M, phimatrix, invphimatrix := LA;
  47 |   16   0.000     64|         st := time();
  48 |   16   0.186 3280932|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   16   0.139 3278122|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   16   0.000    256|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   16   0.000     64|     st := time();
  52 |   16   0.000  84528|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   16   0.000    132|     pgcdtime := pgcdtime+time()-st;
  54 |   16   0.000     96|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   16   0.000   1168|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   16   0.000     48|     if 1 &lt; m then
  62 |   16   0.000     64|         st := time();
  63 |   16   0.126 1664603|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   16   0.000    256|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   16   0.000     64|     st := time();
  66 |   16   0.000   1584|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   16   0.045 244160|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   16   0.000    232|     lmt := lmt+time()-st;
  69 |   16   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   15   0.000      0|         summon := lmCp+minmon;
  76 |   15   0.000  30405|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   15   0.000  34950|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   15   0.000    180|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   15   0.000    222|             H := [op(H), Cp];
  84 |   15   0.000    207|             Np := [op(Np), p];
  85 |   15   0.000     60|             st := time();
  86 |   15   0.126 1726937|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   15   0.000    212|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   16   0.000     64|     st := time();
  89 |   16   0.079 622616|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   16   0.000    228|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   16   0.000     48|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2474|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     10|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.016  84892|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.015 256046|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   1.563 20208956|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.000  24705| A := semi(A1);
  12 |    1   0.000  24705| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      7| Xpoly := X[1 .. k];
  18 |    1   0.000     20| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    577| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   1673| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   17   0.000  43435|     do
  26 |   17   0.000   1713|         p := nextprime(p);
  27 |   17   0.000      0|         lcmintest := true;
  28 |   17   0.000      0|         for i to m do
  29 |   68   0.000   1119|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   17   0.000     68|     st := time();
  32 |   17   0.079 1129446|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   17   0.000    256|     pt := pt+time()-st;
  34 |   17   0.000  41987|     Rand := rand(1 .. p-1);
  35 |   17   0.000     51|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   17   0.000    693|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   17   0.000   1258|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   17   0.000  88247|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   17   0.000     68|         st := time();
  42 |   17   0.141 2354697|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   17   0.000    272|         laminpolytime := laminpolytime+time()-st;
  44 |   17   0.000     51|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   17   0.000     68|         M, phimatrix, invphimatrix := LA;
  47 |   17   0.000     68|         st := time();
  48 |   17   0.141 3493723|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   17   0.141 3480272|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   17   0.000    272|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   17   0.000     68|     st := time();
  52 |   17   0.063 131121|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   17   0.000    264|     pgcdtime := pgcdtime+time()-st;
  54 |   17   0.000    102|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   17   0.000   1241|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   17   0.000     51|     if 1 &lt; m then
  62 |   17   0.000     68|         st := time();
  63 |   17   0.280 3228754|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   17   0.000    272|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   17   0.000     68|     st := time();
  66 |   17   0.000   1683|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   17   0.031 493714|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   17   0.000    272|     lmt := lmt+time()-st;
  69 |   17   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   16   0.000      0|         summon := lmCp+minmon;
  76 |   16   0.000  32432|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   16   0.000  48608|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   16   0.000    192|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   16   0.000    245|             H := [op(H), Cp];
  84 |   16   0.000    229|             Np := [op(Np), p];
  85 |   16   0.000     64|             st := time();
  86 |   16   0.562 3849029|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   16   0.000    236|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   17   0.000     68|     st := time();
  89 |   17   0.078 1280244|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   17   0.000    252|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   17   0.000     51|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2459|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     10|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.000 101440|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.047 345830|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   2.437 24783638|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.000  24705| A := semi(A1);
  12 |    1   0.000  24705| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      7| Xpoly := X[1 .. k];
  18 |    1   0.000     20| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    577| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   1673| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   16   0.015  40880|     do
  26 |   16   0.000   1514|         p := nextprime(p);
  27 |   16   0.000      0|         lcmintest := true;
  28 |   16   0.000      0|         for i to m do
  29 |   64   0.000   1050|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   16   0.000     64|     st := time();
  32 |   16   0.142 1063008|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   16   0.000    256|     pt := pt+time()-st;
  34 |   16   0.000  39541|     Rand := rand(1 .. p-1);
  35 |   16   0.000     48|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   16   0.000    699|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   16   0.000   1184|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   16   0.016  83139|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   16   0.000     64|         st := time();
  42 |   16   0.201 2214584|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   16   0.000    256|         laminpolytime := laminpolytime+time()-st;
  44 |   16   0.000     48|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   16   0.000     64|         M, phimatrix, invphimatrix := LA;
  47 |   16   0.000     64|         st := time();
  48 |   16   0.235 3287974|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   16   0.219 5388217|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   16   0.000    256|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   16   0.000     64|     st := time();
  52 |   16   0.156 162546|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   16   0.000    256|     pgcdtime := pgcdtime+time()-st;
  54 |   16   0.000     96|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   16   0.000   1168|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   16   0.000     48|     if 1 &lt; m then
  62 |   16   0.000     64|         st := time();
  63 |   16   0.547 4423538|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   16   0.000    256|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   16   0.000     64|     st := time();
  66 |   16   0.000   1584|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   16   0.031 685184|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   16   0.000    248|     lmt := lmt+time()-st;
  69 |   16   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   15   0.000      0|         summon := lmCp+minmon;
  76 |   15   0.000  30405|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   15   0.000  56190|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   15   0.000    180|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   15   0.000    222|             H := [op(H), Cp];
  84 |   15   0.000    207|             Np := [op(Np), p];
  85 |   15   0.000     60|             st := time();
  86 |   15   0.766 4993635|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   15   0.000    228|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   16   0.000     64|     st := time();
  89 |   16   0.078 1853893|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   16   0.000    244|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   16   0.000     48|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2467|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     10|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.016 117988|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.015 277646|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  18.234 243524611|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.062 612029| A := semi(A1);
  12 |    1   0.063 612029| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     20| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    577| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   1673| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   17   0.032  43503|     do
  26 |   17   0.000   1555|         p := nextprime(p);
  27 |   17   0.000      0|         lcmintest := true;
  28 |   17   0.000      0|         for i to m do
  29 |   68   0.016   1179|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   17   0.000     68|     st := time();
  32 |   17   2.888 27249448|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   17   0.000    272|     pt := pt+time()-st;
  34 |   17   0.000  41993|     Rand := rand(1 .. p-1);
  35 |   17   0.000     51|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   17   0.000    703|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   17   0.000   1258|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   17   0.048  88247|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   17   0.000     68|         st := time();
  42 |   17   0.141 2351014|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   17   0.000    240|         laminpolytime := laminpolytime+time()-st;
  44 |   17   0.000     51|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   17   0.000     68|         M, phimatrix, invphimatrix := LA;
  47 |   17   0.000     68|         st := time();
  48 |   17   7.501 95463320|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   17   4.672 95938758|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   17   0.000    272|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   17   0.000     68|     st := time();
  52 |   17   2.500 17295126|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   17   0.000    272|     pgcdtime := pgcdtime+time()-st;
  54 |   17   0.000    102|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   17   0.000   1904|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   17   0.000     51|     if 1 &lt; m then
  62 |   17   0.000     68|         st := time();
  63 |   17   0.077 1139928|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   17   0.000    272|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   17   0.000     68|     st := time();
  66 |   17   0.000   1751|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   17   0.000 150025|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   17   0.000    140|     lmt := lmt+time()-st;
  69 |   17   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   16   0.000     80|         summon := lmCp+minmon;
  76 |   16   0.000  40976|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   16   0.016  31744|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   16   0.000    192|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   16   0.000    245|             H := [op(H), Cp];
  84 |   16   0.000    229|             Np := [op(Np), p];
  85 |   16   0.000     64|             st := time();
  86 |   16   0.171 1053513|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   16   0.000    220|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   17   0.000     68|     st := time();
  89 |   17   0.000 359375|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   17   0.000    236|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   17   0.000     51|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2466|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.032 949685|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.015  86762|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

</Text-field>
</Output>
</Group>
<Group hide-input="false" labelreference="L709" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font opaque="true" size="16" background="[255,255,153]" foreground="[0,0,255]">#2: </Font><Font opaque="true" background="[255,255,153]" foreground="[0,0,128]">Total degree of the polynomials are changing from 1 to 15
</Font><Font opaque="true" background="[204,255,204]">flagalg:=MGCD; #Using RDP=Algebraic:-RecursiveDensePolynomials</Font><Font opaque="true" background="[255,255,153]" foreground="[0,0,128]">
tdeg:=</Font><Font foreground="[128,0,0]">[4,6,8,10,12,16,20,24,28,32,36,40</Font>];<Font opaque="true" background="[255,255,153]" foreground="[0,0,128]">
</Font>R:=<Font foreground="[128,0,0]">Benchmain(flagalg,2</Font>,tdeg,10,32,5,0);
Export(R,&quot;MGCD.xls&quot;,&quot;Tdeg&quot;);
</Text-field>
</Input>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUkjbWlHRiQ2JVEoZmxhZ2FsZ0YnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy1JI21vR0YkNi5RKSZBc3NpZ247RicvRjNRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y9LyUpc3RyZXRjaHlHRj0vJSpzeW1tZXRyaWNHRj0vJShsYXJnZW9wR0Y9LyUubW92YWJsZWxpbWl0c0dGPS8lJ2FjY2VudEdGPS8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkwvJSllcXVhbGl0eUdGPS1GLDYlUSVNR0NERidGL0YyRjk=">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYlLUkjbWlHRiQ2JVEoZmxhZ2FsZ0YnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy1JI21vR0YkNi5RKSZBc3NpZ247RicvRjNRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y9LyUpc3RyZXRjaHlHRj0vJSpzeW1tZXRyaWNHRj0vJShsYXJnZW9wR0Y9LyUubW92YWJsZWxpbWl0c0dGPS8lJ2FjY2VudEdGPS8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkwvJSllcXVhbGl0eUdGPS1GLDYlUSVNR0NERidGL0Yy</Equation></Text-field>
</Output>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUkjbWlHRiQ2JVEldGRlZ0YnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy1JI21vR0YkNi5RKSZBc3NpZ247RicvRjNRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y9LyUpc3RyZXRjaHlHRj0vJSpzeW1tZXRyaWNHRj0vJShsYXJnZW9wR0Y9LyUubW92YWJsZWxpbWl0c0dGPS8lJ2FjY2VudEdGPS8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkwvJSllcXVhbGl0eUdGPS1JKG1mZW5jZWRHRiQ2Ji1GIzY8LUkjbW5HRiQ2JFEiNEYnRjktRjY2LlEiLEYnRjlGOy9GP0YxRkBGQkZERkZGSC9GS1EmMC4wZW1GJy9GTlEsMC4zMzMzMzMzZW1GJ0ZPLUZXNiRRIjZGJ0Y5RlotRlc2JFEiOEYnRjlGWi1GVzYkUSMxMEYnRjlGWi1GVzYkUSMxMkYnRjlGWi1GVzYkUSMxNkYnRjlGWi1GVzYkUSMyMEYnRjlGWi1GVzYkUSMyNEYnRjlGWi1GVzYkUSMyOEYnRjlGWi1GVzYkUSMzMkYnRjlGWi1GVzYkUSMzNkYnRjlGWi1GVzYkUSM0MEYnRjkvJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnLyUpcmVhZG9ubHlHRj1GOUY5LyUlb3BlbkdRJyZsc3FiO0YnLyUmY2xvc2VHUScmcnNxYjtGJ0Y5">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYlLUkjbWlHRiQ2JVEldGRlZ0YnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy1JI21vR0YkNi5RKSZBc3NpZ247RicvRjNRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y9LyUpc3RyZXRjaHlHRj0vJSpzeW1tZXRyaWNHRj0vJShsYXJnZW9wR0Y9LyUubW92YWJsZWxpbWl0c0dGPS8lJ2FjY2VudEdGPS8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkwvJSllcXVhbGl0eUdGPS1JKG1mZW5jZWRHRiQ2Ji1GIzY5LUkjbW5HRiQ2JFEiNEYnRjktRjY2LlEiLEYnRjlGOy9GP0YxRkBGQkZERkZGSC9GS1EmMC4wZW1GJy9GTlEsMC4zMzMzMzMzZW1GJ0ZPLUZXNiRRIjZGJ0Y5RlotRlc2JFEiOEYnRjlGWi1GVzYkUSMxMEYnRjlGWi1GVzYkUSMxMkYnRjlGWi1GVzYkUSMxNkYnRjlGWi1GVzYkUSMyMEYnRjlGWi1GVzYkUSMyNEYnRjlGWi1GVzYkUSMyOEYnRjlGWi1GVzYkUSMzMkYnRjlGWi1GVzYkUSMzNkYnRjlGWi1GVzYkUSM0MEYnRjlGOS8lJW9wZW5HUScmbHNxYjtGJy8lJmNsb3NlR1EnJnJzcWI7Ric=</Equation></Text-field>
</Output>
<Output><Text-field style="Line Printed Output" layout="Line Printed Output">MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   2.563 29026034|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.000  36076| A := semi(A1);
  12 |    1   0.000  35435| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000   1682| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   4345| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   21   0.031  73591|     do
  26 |   21   0.000  10178|         p := nextprime(p);
  27 |   21   0.000      0|         lcmintest := true;
  28 |   21   0.000      0|         for i to m do
  29 |  105   0.000   1715|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   21   0.000     84|     st := time();
  32 |   21   0.172 1978738|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   21   0.000    336|     pt := pt+time()-st;
  34 |   21   0.000  51613|     Rand := rand(1 .. p-1);
  35 |   21   0.000     63|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   21   0.000   1135|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   21   0.000   1911|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   21   0.046 160710|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   21   0.000     84|         st := time();
  42 |   21   0.547 6557161|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   21   0.000    336|         laminpolytime := laminpolytime+time()-st;
  44 |   21   0.000     63|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   21   0.000     84|         M, phimatrix, invphimatrix := LA;
  47 |   21   0.000     84|         st := time();
  48 |   21   0.326 5902742|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   21   0.407 5859627|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   21   0.000    336|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   21   0.000     84|     st := time();
  52 |   21   0.361 3102368|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   21   0.000    336|     pgcdtime := pgcdtime+time()-st;
  54 |   21   0.000    130|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   21   0.000   2922|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   21   0.000     63|     if 1 &lt; m then
  62 |   21   0.000     84|         st := time();
  63 |   21   0.189 1923116|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   21   0.000    336|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   21   0.000     84|     st := time();
  66 |   21   0.000   2191|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   21   0.032 247590|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   21   0.000    328|     lmt := lmt+time()-st;
  69 |   21   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   20   0.000    100|         summon := lmCp+minmon;
  76 |   20   0.000  57468|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   20   0.000  57620|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   20   0.000    240|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   20   0.000    347|             H := [op(H), Cp];
  84 |   20   0.000    327|             Np := [op(Np), p];
  85 |   20   0.000     80|             st := time();
  86 |   20   0.436 2235966|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   20   0.000    308|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   21   0.000     84|     st := time();
  89 |   21   0.000 630752|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   21   0.000    324|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   21   0.000     63|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2452|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.016  62101|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000  19554|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   1.875 26699875|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.015  35435| A := semi(A1);
  12 |    1   0.000  35435| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   21   0.046  73584|     do
  26 |   21   0.000   1818|         p := nextprime(p);
  27 |   21   0.000      0|         lcmintest := true;
  28 |   21   0.000      0|         for i to m do
  29 |  105   0.000   1701|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   21   0.000     84|     st := time();
  32 |   21   0.127 1977318|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   21   0.000    336|     pt := pt+time()-st;
  34 |   21   0.000  51702|     Rand := rand(1 .. p-1);
  35 |   21   0.000     63|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   21   0.000   1135|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   21   0.000   1911|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   21   0.047 160440|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   21   0.000     84|         st := time();
  42 |   21   0.250 4444371|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   21   0.000    336|         laminpolytime := laminpolytime+time()-st;
  44 |   21   0.000     63|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   21   0.000     84|         M, phimatrix, invphimatrix := LA;
  47 |   21   0.000     84|         st := time();
  48 |   21   0.264 5800894|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   21   0.360 5786866|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   21   0.000    336|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   21   0.000     84|     st := time();
  52 |   21   0.359 3092388|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   21   0.000    328|     pgcdtime := pgcdtime+time()-st;
  54 |   21   0.000    126|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   21   0.000   2352|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   21   0.000     63|     if 1 &lt; m then
  62 |   21   0.000     84|         st := time();
  63 |   21   0.094 1911790|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   21   0.000    336|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   21   0.000     84|     st := time();
  66 |   21   0.000   2184|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   21   0.046 247590|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   21   0.000    280|     lmt := lmt+time()-st;
  69 |   21   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   20   0.000    100|         summon := lmCp+minmon;
  76 |   20   0.000  57451|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   20   0.000  57620|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   20   0.000    240|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   20   0.000    347|             H := [op(H), Cp];
  84 |   20   0.000    327|             Np := [op(Np), p];
  85 |   20   0.000     80|             st := time();
  86 |   20   0.251 2234274|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   20   0.000    300|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   21   0.000     84|     st := time();
  89 |   21   0.016 629295|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   21   0.000    316|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   21   0.000     63|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2456|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.000  62101|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000  19554|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     12|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   3.937 42025376|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.000  35435| A := semi(A1);
  12 |    1   0.000  35435| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   24   0.032  84096|     do
  26 |   24   0.000   3988|         p := nextprime(p);
  27 |   24   0.000      0|         lcmintest := true;
  28 |   24   0.000      0|         for i to m do
  29 |  120   0.000   1951|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   24   0.000     96|     st := time();
  32 |   24   0.219 2259792|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   24   0.000    368|     pt := pt+time()-st;
  34 |   24   0.000  58973|     Rand := rand(1 .. p-1);
  35 |   24   0.000     72|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   24   0.000   1295|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   24   0.000   2184|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   24   0.016 183360|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   24   0.000     96|         st := time();
  42 |   24   0.388 5078878|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   24   0.000    384|         laminpolytime := laminpolytime+time()-st;
  44 |   24   0.000     72|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   24   0.000     96|         M, phimatrix, invphimatrix := LA;
  47 |   24   0.000     96|         st := time();
  48 |   24   0.689 6678169|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   24   0.390 6679888|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   24   0.000    384|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   24   0.000     96|     st := time();
  52 |   24   0.577 5944217|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   24   0.000    384|     pgcdtime := pgcdtime+time()-st;
  54 |   24   0.000    144|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   24   0.000   3168|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   24   0.000     72|     if 1 &lt; m then
  62 |   24   0.000     96|         st := time();
  63 |   24   0.376 4426230|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   24   0.000    384|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   24   0.000     96|     st := time();
  66 |   24   0.000   2496|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   24   0.093 674197|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   24   0.000    384|     lmt := lmt+time()-st;
  69 |   24   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   23   0.000   1127|         summon := lmCp+minmon;
  76 |   23   0.000  72456|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   23   0.000  85100|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   23   0.000    276|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   23   0.000    434|             H := [op(H), Cp];
  84 |   23   0.000    411|             Np := [op(Np), p];
  85 |   23   0.000     92|             st := time();
  86 |   23   1.126 7631563|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   23   0.000    332|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   24   0.000     96|     st := time();
  89 |   24   0.031 1966935|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   24   0.000    348|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   24   0.000     72|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2445|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     25|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.000  79942|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000  23172|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     12|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   5.094 51517162|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.000  35435| A := semi(A1);
  12 |    1   0.000  35435| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   22   0.015  77088|     do
  26 |   22   0.000   1914|         p := nextprime(p);
  27 |   22   0.000      0|         lcmintest := true;
  28 |   22   0.000      0|         for i to m do
  29 |  110   0.000   1791|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   22   0.000     88|     st := time();
  32 |   22   0.189 2071476|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   22   0.000    352|     pt := pt+time()-st;
  34 |   22   0.016  54099|     Rand := rand(1 .. p-1);
  35 |   22   0.000     66|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   22   0.000   1185|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   22   0.000   2002|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   22   0.016 168080|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   22   0.000     88|         st := time();
  42 |   22   0.299 4655486|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   22   0.000    320|         laminpolytime := laminpolytime+time()-st;
  44 |   22   0.000     66|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   22   0.000     88|         M, phimatrix, invphimatrix := LA;
  47 |   22   0.000     88|         st := time();
  48 |   22   0.466 6192038|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   22   0.486 6185137|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   22   0.000    352|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   22   0.000     88|     st := time();
  52 |   22   1.062 8764309|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   22   0.000    352|     pgcdtime := pgcdtime+time()-st;
  54 |   22   0.000    132|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   22   0.000   3278|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   22   0.000     66|     if 1 &lt; m then
  62 |   22   0.000     88|         st := time();
  63 |   22   0.597 7016151|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   22   0.000    352|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   22   0.000     88|     st := time();
  66 |   22   0.000   2288|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   22   0.062 1117173|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   22   0.000    344|     lmt := lmt+time()-st;
  69 |   22   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   21   0.000   1029|         summon := lmCp+minmon;
  76 |   21   0.015  70108|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   21   0.015 101745|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   21   0.000    252|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   21   0.000    375|             H := [op(H), Cp];
  84 |   21   0.000    354|             Np := [op(Np), p];
  85 |   21   0.000     84|             st := time();
  86 |   21   1.809 11605646|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   21   0.000    316|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   22   0.000     88|     st := time();
  89 |   22   0.047 3217691|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   22   0.000    332|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   22   0.000     66|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2452|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     30|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.000 104227|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000  21506|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     12|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   3.844 44621875|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.016  67580| A := semi(A1);
  12 |    1   0.000  67580| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   23   0.015  80592|     do
  26 |   23   0.000   2021|         p := nextprime(p);
  27 |   23   0.000      0|         lcmintest := true;
  28 |   23   0.000      0|         for i to m do
  29 |  115   0.000   1871|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   23   0.000     92|     st := time();
  32 |   23   0.453 4156974|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   23   0.000    368|     pt := pt+time()-st;
  34 |   23   0.000  56587|     Rand := rand(1 .. p-1);
  35 |   23   0.000     69|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   23   0.000   1365|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   23   0.000   2093|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   23   0.016 175720|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   23   0.000     92|         st := time();
  42 |   23   0.391 4868072|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   23   0.000    368|         laminpolytime := laminpolytime+time()-st;
  44 |   23   0.000     69|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   23   0.000     92|         M, phimatrix, invphimatrix := LA;
  47 |   23   0.016     92|         st := time();
  48 |   23   0.767 12206576|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   23   0.638 12193554|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   23   0.000    368|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   23   0.000     92|     st := time();
  52 |   23   0.988 4558448|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   23   0.000    368|     pgcdtime := pgcdtime+time()-st;
  54 |   23   0.000    138|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   23   0.000   2576|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   23   0.000     69|     if 1 &lt; m then
  62 |   23   0.000     92|         st := time();
  63 |   23   0.154 2093727|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   23   0.000    368|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   23   0.000     92|     st := time();
  66 |   23   0.000   2392|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   23   0.047 271170|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   23   0.000    328|     lmt := lmt+time()-st;
  69 |   23   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   22   0.000    110|         summon := lmCp+minmon;
  76 |   22   0.016  63208|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   22   0.000  63382|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   22   0.000    264|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   22   0.000    404|             H := [op(H), Cp];
  84 |   22   0.000    382|             Np := [op(Np), p];
  85 |   22   0.000     88|             st := time();
  86 |   22   0.296 2737345|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   22   0.000    308|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   23   0.000     92|     st := time();
  89 |   23   0.015 808327|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   23   0.000    324|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   23   0.000     69|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2452|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.000 101829|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.016  27734|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   3.922 44628885|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.000  67580| A := semi(A1);
  12 |    1   0.016  67580| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   23   0.015  80592|     do
  26 |   23   0.000   2021|         p := nextprime(p);
  27 |   23   0.000      0|         lcmintest := true;
  28 |   23   0.000      0|         for i to m do
  29 |  115   0.000   1871|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   23   0.000     92|     st := time();
  32 |   23   0.409 4156974|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   23   0.000    352|     pt := pt+time()-st;
  34 |   23   0.000  56623|     Rand := rand(1 .. p-1);
  35 |   23   0.000     69|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   23   0.000   1365|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   23   0.000   2093|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   23   0.031 175720|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   23   0.000     92|         st := time();
  42 |   23   0.376 4867099|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   23   0.000    360|         laminpolytime := laminpolytime+time()-st;
  44 |   23   0.000     69|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   23   0.000     92|         M, phimatrix, invphimatrix := LA;
  47 |   23   0.000     92|         st := time();
  48 |   23   0.983 12209006|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   23   0.874 12200530|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   23   0.000    368|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   23   0.000     92|     st := time();
  52 |   23   0.533 4557182|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   23   0.000    368|     pgcdtime := pgcdtime+time()-st;
  54 |   23   0.000    138|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   23   0.000   2576|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   23   0.000     69|     if 1 &lt; m then
  62 |   23   0.000     92|         st := time();
  63 |   23   0.172 2093507|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   23   0.000    368|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   23   0.000     92|     st := time();
  66 |   23   0.016   2392|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   23   0.048 271170|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   23   0.000    368|     lmt := lmt+time()-st;
  69 |   23   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   22   0.000    110|         summon := lmCp+minmon;
  76 |   22   0.000  63208|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   22   0.000  63382|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   22   0.000    264|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   22   0.000    404|             H := [op(H), Cp];
  84 |   22   0.000    382|             Np := [op(Np), p];
  85 |   22   0.000     88|             st := time();
  86 |   22   0.434 2737345|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   22   0.000    324|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   23   0.000     92|     st := time();
  89 |   23   0.000 808327|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   23   0.000    340|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   23   0.000     69|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2431|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.015 101829|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000  27734|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   7.078 73776133|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.000  67580| A := semi(A1);
  12 |    1   0.016  67580| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   24   0.016  84096|     do
  26 |   24   0.000   2227|         p := nextprime(p);
  27 |   24   0.000      0|         lcmintest := true;
  28 |   24   0.000      0|         for i to m do
  29 |  120   0.000   1961|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   24   0.000     96|     st := time();
  32 |   24   0.519 4338115|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   24   0.000    384|     pt := pt+time()-st;
  34 |   24   0.000  59055|     Rand := rand(1 .. p-1);
  35 |   24   0.000     72|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   24   0.000   1305|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   24   0.000   2184|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   24   0.015 183360|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   24   0.000     96|         st := time();
  42 |   24   0.344 5078712|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   24   0.000    376|         laminpolytime := laminpolytime+time()-st;
  44 |   24   0.000     72|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   24   0.000     96|         M, phimatrix, invphimatrix := LA;
  47 |   24   0.000     96|         st := time();
  48 |   24   0.811 12832731|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   24   0.845 12849708|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   24   0.000    384|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   24   0.000     96|     st := time();
  52 |   24   1.045 11224073|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   24   0.000    384|     pgcdtime := pgcdtime+time()-st;
  54 |   24   0.000    144|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   24   0.000   3576|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   24   0.000     72|     if 1 &lt; m then
  62 |   24   0.000     96|         st := time();
  63 |   24   0.503 7653280|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   24   0.000    384|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   24   0.000     96|     st := time();
  66 |   24   0.000   2496|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   24   0.139 1218720|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   24   0.000    384|     lmt := lmt+time()-st;
  69 |   24   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   23   0.000   1127|         summon := lmCp+minmon;
  76 |   23   0.000  76806|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   23   0.047 111435|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   23   0.000    276|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   23   0.000    434|             H := [op(H), Cp];
  84 |   23   0.000    411|             Np := [op(Np), p];
  85 |   23   0.000     92|             st := time();
  86 |   23   2.325 14105057|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   23   0.000    348|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   24   0.000     96|     st := time();
  89 |   24   0.422 3616942|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   24   0.000    364|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   24   0.000     72|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2459|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.016 142371|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.015  40254|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  11.328 107574256|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.016  67580| A := semi(A1);
  12 |    1   0.015  67580| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   22   0.015  77088|     do
  26 |   22   0.000   1914|         p := nextprime(p);
  27 |   22   0.000      0|         lcmintest := true;
  28 |   22   0.000      0|         for i to m do
  29 |  110   0.000   1836|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   22   0.000     88|     st := time();
  32 |   22   0.294 3976236|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   22   0.000    352|     pt := pt+time()-st;
  34 |   22   0.016  54096|     Rand := rand(1 .. p-1);
  35 |   22   0.000     66|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   22   0.000   1150|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   22   0.000   2002|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   22   0.016 168080|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   22   0.000     88|         st := time();
  42 |   22   0.364 4655486|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   22   0.000    352|         laminpolytime := laminpolytime+time()-st;
  44 |   22   0.000     66|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   22   0.000     88|         M, phimatrix, invphimatrix := LA;
  47 |   22   0.000     88|         st := time();
  48 |   22   0.826 12193466|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   22   0.643 12186168|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   22   0.000    352|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   22   0.000     88|     st := time();
  52 |   22   2.339 21541891|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   22   0.000    352|     pgcdtime := pgcdtime+time()-st;
  54 |   22   0.000    132|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   22   0.016   4026|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   22   0.000     66|     if 1 &lt; m then
  62 |   22   0.000     88|         st := time();
  63 |   22   1.047 15370218|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   22   0.000    352|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   22   0.000     88|     st := time();
  66 |   22   0.000   2288|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   22   0.205 2539737|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   22   0.000    352|     lmt := lmt+time()-st;
  69 |   22   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   21   0.000   1029|         summon := lmCp+minmon;
  76 |   21   0.015  78108|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   21   0.031 170373|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   21   0.000    252|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   21   0.000    375|             H := [op(H), Cp];
  84 |   21   0.000    354|             Np := [op(Np), p];
  85 |   21   0.000     84|             st := time();
  86 |   21   5.345 26802961|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   21   0.000    332|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   22   0.000     88|     st := time();
  89 |   22   0.125 7355679|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   22   0.000    348|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   22   0.000     66|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2428|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     25|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.000 212738|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000  31638|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     12|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   5.656 70724260|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.000 111494| A := semi(A1);
  12 |    1   0.015 111494| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   25   0.031  87600|     do
  26 |   25   0.000   2377|         p := nextprime(p);
  27 |   25   0.000      0|         lcmintest := true;
  28 |   25   0.000      0|         for i to m do
  29 |  125   0.000   2041|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   25   0.000    100|     st := time();
  32 |   25   0.626 7402550|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   25   0.000    400|     pt := pt+time()-st;
  34 |   25   0.000  61507|     Rand := rand(1 .. p-1);
  35 |   25   0.000     75|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   25   0.000   1275|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   25   0.000   2275|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   25   0.094 191000|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   25   0.000    100|         st := time();
  42 |   25   0.328 5291159|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   25   0.000    400|         laminpolytime := laminpolytime+time()-st;
  44 |   25   0.000     75|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   25   0.000    100|         M, phimatrix, invphimatrix := LA;
  47 |   25   0.000    100|         st := time();
  48 |   25   1.921 21925841|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   25   1.208 21917885|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   25   0.000    400|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   25   0.000    100|     st := time();
  52 |   25   0.730 6569253|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   25   0.000    400|     pgcdtime := pgcdtime+time()-st;
  54 |   25   0.000    150|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   25   0.000   2800|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   25   0.000     75|     if 1 &lt; m then
  62 |   25   0.000    100|         st := time();
  63 |   25   0.141 2274716|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   25   0.000    400|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   25   0.000    100|     st := time();
  66 |   25   0.000   2600|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   25   0.076 294750|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   25   0.000    368|     lmt := lmt+time()-st;
  69 |   25   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   24   0.000    120|         summon := lmCp+minmon;
  76 |   24   0.000  68982|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   24   0.000  69144|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   24   0.000    288|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   24   0.000    465|             H := [op(H), Cp];
  84 |   24   0.000    441|             Np := [op(Np), p];
  85 |   24   0.000     96|             st := time();
  86 |   24   0.454 3297487|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   24   0.000    384|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   25   0.000    100|     st := time();
  89 |   25   0.016 832133|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   25   0.000    400|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   25   0.000     75|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2445|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     25|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.016 156219|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000  35914|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   6.079 71982385|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.016 111494| A := semi(A1);
  12 |    1   0.031 111494| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   22   0.046  77088|     do
  26 |   22   0.000   1914|         p := nextprime(p);
  27 |   22   0.000      0|         lcmintest := true;
  28 |   22   0.000      0|         for i to m do
  29 |  110   0.000   1801|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   22   0.000     88|     st := time();
  32 |   22   0.640 6514647|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   22   0.000    352|     pt := pt+time()-st;
  34 |   22   0.015  54039|     Rand := rand(1 .. p-1);
  35 |   22   0.000     66|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   22   0.000   1160|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   22   0.000   2002|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   22   0.046 168080|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   22   0.000     88|         st := time();
  42 |   22   0.315 4655486|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   22   0.000    352|         laminpolytime := laminpolytime+time()-st;
  44 |   22   0.000     66|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   22   0.000     88|         M, phimatrix, invphimatrix := LA;
  47 |   22   0.000     88|         st := time();
  48 |   22   1.125 19355126|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   22   1.092 19362189|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   22   0.000    352|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   22   0.000     88|     st := time();
  52 |   22   0.923 8510751|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   22   0.000    352|     pgcdtime := pgcdtime+time()-st;
  54 |   22   0.000    132|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   22   0.000   2904|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   22   0.000     66|     if 1 &lt; m then
  62 |   22   0.000     88|         st := time();
  63 |   22   0.250 4057321|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   22   0.000    352|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   22   0.000     88|     st := time();
  66 |   22   0.000   2288|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   22   0.422 618411|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   22   0.000    336|     lmt := lmt+time()-st;
  69 |   22   0.015      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   21   0.000   1029|         summon := lmCp+minmon;
  76 |   21   0.015  66186|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   21   0.000  77700|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   21   0.000    252|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   21   0.000    375|             H := [op(H), Cp];
  84 |   21   0.000    354|             Np := [op(Np), p];
  85 |   21   0.000     84|             st := time();
  86 |   21   1.096 6281312|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   21   0.000    316|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   22   0.000     88|     st := time();
  89 |   22   0.016 1714530|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   22   0.000    332|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   22   0.000     66|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2424|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     25|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.016 172493|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000  50100|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   9.688 99053941|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.016 111494| A := semi(A1);
  12 |    1   0.000 111494| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   21   0.047  73584|     do
  26 |   21   0.000   1818|         p := nextprime(p);
  27 |   21   0.000      0|         lcmintest := true;
  28 |   21   0.000      0|         for i to m do
  29 |  105   0.000   1736|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   21   0.000     84|     st := time();
  32 |   21   0.735 6218538|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   21   0.000    336|     pt := pt+time()-st;
  34 |   21   0.000  51644|     Rand := rand(1 .. p-1);
  35 |   21   0.000     63|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   21   0.000   1295|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   21   0.000   1911|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   21   0.031 160440|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   21   0.000     84|         st := time();
  42 |   21   0.375 4443873|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   21   0.000    328|         laminpolytime := laminpolytime+time()-st;
  44 |   21   0.000     63|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   21   0.000     84|         M, phimatrix, invphimatrix := LA;
  47 |   21   0.000     84|         st := time();
  48 |   21   1.499 18775087|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   21   1.423 18677823|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   21   0.000    336|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   21   0.000     84|     st := time();
  52 |   21   1.891 16595884|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   21   0.000    336|     pgcdtime := pgcdtime+time()-st;
  54 |   21   0.000    126|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   21   0.000   3486|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   21   0.000     63|     if 1 &lt; m then
  62 |   21   0.000     84|         st := time();
  63 |   21   0.733 10305983|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   21   0.000    336|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   21   0.000     84|     st := time();
  66 |   21   0.000   2184|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   21   0.190 1677850|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   21   0.000    336|     lmt := lmt+time()-st;
  69 |   21   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   20   0.000    980|         summon := lmCp+minmon;
  76 |   20   0.016  70597|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   20   0.015 126320|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   20   0.000    240|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   20   0.000    347|             H := [op(H), Cp];
  84 |   20   0.000    327|             Np := [op(Np), p];
  85 |   20   0.000     80|             st := time();
  86 |   20   2.623 16607518|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   20   0.000    308|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   21   0.000     84|     st := time();
  89 |   21   0.078 4734620|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   21   0.000    324|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   21   0.000     63|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2449|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.016 224527|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000  62620|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  18.734 165858442|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.000 111494| A := semi(A1);
  12 |    1   0.015 111494| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   23   0.015  80592|     do
  26 |   23   0.000   2021|         p := nextprime(p);
  27 |   23   0.000      0|         lcmintest := true;
  28 |   23   0.000      0|         for i to m do
  29 |  115   0.000   1941|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   23   0.000     92|     st := time();
  32 |   23   0.799 6811122|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   23   0.000    368|     pt := pt+time()-st;
  34 |   23   0.016  56591|     Rand := rand(1 .. p-1);
  35 |   23   0.000     69|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   23   0.000   1355|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   23   0.000   2093|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   23   0.063 175720|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   23   0.000     92|         st := time();
  42 |   23   0.314 4867099|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   23   0.000    360|         laminpolytime := laminpolytime+time()-st;
  44 |   23   0.000     69|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   23   0.000     92|         M, phimatrix, invphimatrix := LA;
  47 |   23   0.000     92|         st := time();
  48 |   23   1.199 21270395|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   23   1.455 21271829|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   23   0.000    368|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   23   0.000     92|     st := time();
  52 |   23   4.279 34069815|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   23   0.000    368|     pgcdtime := pgcdtime+time()-st;
  54 |   23   0.000    138|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   23   0.000   4600|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   23   0.000     69|     if 1 &lt; m then
  62 |   23   0.000     92|         st := time();
  63 |   23   2.018 21755536|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   23   0.000    368|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   23   0.000     92|     st := time();
  66 |   23   0.016   2392|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   23   0.236 3620623|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   23   0.000    360|     lmt := lmt+time()-st;
  69 |   23   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   22   0.000   1078|         summon := lmCp+minmon;
  76 |   22   0.000  86034|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   22   0.094 225192|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   22   0.000    264|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   22   0.000    404|             H := [op(H), Cp];
  84 |   22   0.000    382|             Np := [op(Np), p];
  85 |   22   0.000     88|             st := time();
  86 |   22   8.012 40516966|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   22   0.000    348|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   23   0.000     92|     st := time();
  89 |   23   0.187 10440332|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   23   0.000    364|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   23   0.000     69|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2442|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.016 306988|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000  54004|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   7.344 85424194|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.016 166376| A := semi(A1);
  12 |    1   0.015 166376| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   22   0.016  77088|     do
  26 |   22   0.000   1914|         p := nextprime(p);
  27 |   22   0.000      0|         lcmintest := true;
  28 |   22   0.000      0|         for i to m do
  29 |  110   0.000   1796|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   22   0.000     88|     st := time();
  32 |   22   1.239 9686276|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   22   0.000    352|     pt := pt+time()-st;
  34 |   22   0.000  54134|     Rand := rand(1 .. p-1);
  35 |   22   0.016     66|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   22   0.000   1115|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   22   0.000   2002|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   22   0.016 168080|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   22   0.000     88|         st := time();
  42 |   22   0.432 4661450|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   22   0.000    352|         laminpolytime := laminpolytime+time()-st;
  44 |   22   0.000     66|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   22   0.000     88|         M, phimatrix, invphimatrix := LA;
  47 |   22   0.000     88|         st := time();
  48 |   22   1.737 28530684|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   22   2.142 28510922|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   22   0.000    352|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   22   0.000     88|     st := time();
  52 |   22   1.031 7543604|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   22   0.000    352|     pgcdtime := pgcdtime+time()-st;
  54 |   22   0.000    132|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   22   0.000   2464|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   22   0.000     66|     if 1 &lt; m then
  62 |   22   0.000     88|         st := time();
  63 |   22   0.236 2002907|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   22   0.000    352|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   22   0.000     88|     st := time();
  66 |   22   0.000   2288|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   22   0.000 259380|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   22   0.000    180|     lmt := lmt+time()-st;
  69 |   22   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   21   0.000    105|         summon := lmCp+minmon;
  76 |   21   0.015  60355|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   21   0.000  60501|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   21   0.000    252|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   21   0.000    375|             H := [op(H), Cp];
  84 |   21   0.000    354|             Np := [op(Np), p];
  85 |   21   0.000     84|             st := time();
  86 |   21   0.402 2479199|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   21   0.000    324|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   22   0.000     88|     st := time();
  89 |   22   0.015 703672|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   22   0.000    340|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   22   0.000     66|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2452|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.016 226689|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000  44094|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   8.719 104923667|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.015 166376| A := semi(A1);
  12 |    1   0.016 166376| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   23   0.061  80592|     do
  26 |   23   0.000   2021|         p := nextprime(p);
  27 |   23   0.000      0|         lcmintest := true;
  28 |   23   0.000      0|         for i to m do
  29 |  115   0.000   1881|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   23   0.000     92|     st := time();
  32 |   23   0.951 10125750|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   23   0.000    368|     pt := pt+time()-st;
  34 |   23   0.000  56504|     Rand := rand(1 .. p-1);
  35 |   23   0.000     69|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   23   0.000   1285|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   23   0.000   2093|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   23   0.047 175720|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   23   0.000     92|         st := time();
  42 |   23   0.520 4867498|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   23   0.000    368|         laminpolytime := laminpolytime+time()-st;
  44 |   23   0.000     69|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   23   0.000     92|         M, phimatrix, invphimatrix := LA;
  47 |   23   0.000     92|         st := time();
  48 |   23   1.687 34102951|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   23   1.827 29898667|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   23   0.000    368|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   23   0.000     92|     st := time();
  52 |   23   1.939 11123764|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   23   0.000    368|     pgcdtime := pgcdtime+time()-st;
  54 |   23   0.000    138|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   23   0.000   3036|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   23   0.000     69|     if 1 &lt; m then
  62 |   23   0.000     92|         st := time();
  63 |   23   0.294 4244162|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   23   0.000    368|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   23   0.000     92|     st := time();
  66 |   23   0.000   2392|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   23   0.061 646106|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   23   0.000    368|     lmt := lmt+time()-st;
  69 |   23   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   22   0.000   1078|         summon := lmCp+minmon;
  76 |   22   0.031  69321|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   22   0.016  81400|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   22   0.000    264|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   22   0.000    404|             H := [op(H), Cp];
  84 |   22   0.000    382|             Np := [op(Np), p];
  85 |   22   0.000     88|             st := time();
  86 |   22   1.175 6939129|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   22   0.000    340|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   23   0.000     92|     st := time();
  89 |   23   0.047 1847343|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   23   0.000    356|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   23   0.000     69|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2455|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.032 243509|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000  63564|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  14.391 152663297|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.016 166376| A := semi(A1);
  12 |    1   0.016 166376| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   22   0.078  77088|     do
  26 |   22   0.000   1914|         p := nextprime(p);
  27 |   22   0.000      0|         lcmintest := true;
  28 |   22   0.000      0|         for i to m do
  29 |  110   0.000   1811|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   22   0.000     88|     st := time();
  32 |   22   0.782 9685500|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   22   0.000    352|     pt := pt+time()-st;
  34 |   22   0.000  53998|     Rand := rand(1 .. p-1);
  35 |   22   0.000     66|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   22   0.000   1195|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   22   0.000   2002|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   22   0.108 168080|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   22   0.000     88|         st := time();
  42 |   22   0.437 4655889|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   22   0.000    352|         laminpolytime := laminpolytime+time()-st;
  44 |   22   0.000     66|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   22   0.000     88|         M, phimatrix, invphimatrix := LA;
  47 |   22   0.000     88|         st := time();
  48 |   22   1.625 28908772|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   22   1.782 28894242|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   22   0.000    352|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   22   0.000     88|     st := time();
  52 |   22   2.751 27324007|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   22   0.000    352|     pgcdtime := pgcdtime+time()-st;
  54 |   22   0.000    132|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   22   0.000   4026|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   22   0.000     66|     if 1 &lt; m then
  62 |   22   0.000     88|         st := time();
  63 |   22   1.078 15371514|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   22   0.000    352|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   22   0.000     88|     st := time();
  66 |   22   0.000   2288|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   22   0.250 2539724|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   22   0.000    352|     lmt := lmt+time()-st;
  69 |   22   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   21   0.000   1029|         summon := lmCp+minmon;
  76 |   21   0.000  78056|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   21   0.016 170373|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   21   0.000    252|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   21   0.000    375|             H := [op(H), Cp];
  84 |   21   0.000    354|             Np := [op(Np), p];
  85 |   21   0.000     84|             st := time();
  86 |   21   5.109 26792878|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   21   0.000    324|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   22   0.000     88|     st := time();
  89 |   22   0.327 7161361|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   22   0.000    340|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   22   0.000     66|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2442|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.016 333643|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000  90270|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  27.219 253011302|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.015 166376| A := semi(A1);
  12 |    1   0.016 166376| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   22   0.016  77088|     do
  26 |   22   0.000   1914|         p := nextprime(p);
  27 |   22   0.000      0|         lcmintest := true;
  28 |   22   0.000      0|         for i to m do
  29 |  110   0.000   1841|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   22   0.000     88|     st := time();
  32 |   22   1.452 9686292|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   22   0.000    352|     pt := pt+time()-st;
  34 |   22   0.000  54028|     Rand := rand(1 .. p-1);
  35 |   22   0.000     66|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   22   0.000   1250|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   22   0.000   2002|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   22   0.047 168080|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   22   0.000     88|         st := time();
  42 |   22   0.326 4655486|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   22   0.016    352|         laminpolytime := laminpolytime+time()-st;
  44 |   22   0.000     66|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   22   0.000     88|         M, phimatrix, invphimatrix := LA;
  47 |   22   0.000     88|         st := time();
  48 |   22   1.970 29674466|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   22   1.672 29671400|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   22   0.000    352|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   22   0.000     88|     st := time();
  52 |   22   6.157 59991227|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   22   0.000    352|     pgcdtime := pgcdtime+time()-st;
  54 |   22   0.000    132|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   22   0.016   5148|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   22   0.000     66|     if 1 &lt; m then
  62 |   22   0.000     88|         st := time();
  63 |   22   2.420 34216990|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   22   0.000    352|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   22   0.000     88|     st := time();
  66 |   22   0.000   2288|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   22   0.533 5734203|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   22   0.000    352|     lmt := lmt+time()-st;
  69 |   22   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   21   0.000   1029|         summon := lmCp+minmon;
  76 |   21   0.015  89978|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   21   0.093 324660|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   21   0.000    252|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   21   0.000    375|             H := [op(H), Cp];
  84 |   21   0.000    354|             Np := [op(Np), p];
  85 |   21   0.000     84|             st := time();
  86 |   21  11.611 60955606|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   21   0.000    332|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   22   0.000     88|     st := time();
  89 |   22   0.812 16789450|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   22   0.000    348|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   22   0.000     66|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2449|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.032 493796|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000  69420|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   9.984 130155681|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.015 232226| A := semi(A1);
  12 |    1   0.031 232226| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   25   0.030  87600|     do
  26 |   25   0.000   2257|         p := nextprime(p);
  27 |   25   0.000      0|         lcmintest := true;
  28 |   25   0.000      0|         for i to m do
  29 |  125   0.000   2046|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   25   0.000    100|     st := time();
  32 |   25   1.410 15329550|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   25   0.000    400|     pt := pt+time()-st;
  34 |   25   0.000  61433|     Rand := rand(1 .. p-1);
  35 |   25   0.000     75|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   25   0.000   1440|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   25   0.000   2275|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   25   0.046 191000|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   25   0.000    100|         st := time();
  42 |   25   0.608 5290728|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   25   0.000    392|         laminpolytime := laminpolytime+time()-st;
  44 |   25   0.000     75|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   25   0.000    100|         M, phimatrix, invphimatrix := LA;
  47 |   25   0.000    100|         st := time();
  48 |   25   2.655 45250587|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   25   2.723 45246346|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   25   0.000    400|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   25   0.000    100|     st := time();
  52 |   25   1.609 11001747|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   25   0.000    400|     pgcdtime := pgcdtime+time()-st;
  54 |   25   0.000    150|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   25   0.015   2800|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   25   0.000     75|     if 1 &lt; m then
  62 |   25   0.000    100|         st := time();
  63 |   25   0.154 2275116|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   25   0.000    400|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   25   0.000    100|     st := time();
  66 |   25   0.000   2600|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   25   0.016 294750|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   25   0.000    264|     lmt := lmt+time()-st;
  69 |   25   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   24   0.000    120|         summon := lmCp+minmon;
  76 |   24   0.016  68999|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   24   0.000  69144|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   24   0.000    288|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   24   0.000    465|             H := [op(H), Cp];
  84 |   24   0.000    441|             Np := [op(Np), p];
  85 |   24   0.000     96|             st := time();
  86 |   24   0.500 3300572|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   24   0.000    348|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   25   0.000    100|     st := time();
  89 |   25   0.000 831043|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   25   0.000    364|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   25   0.000     75|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2438|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.156 315354|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000  52274|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  11.281 140439294|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.016     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.031 232226| A := semi(A1);
  12 |    1   0.047 232226| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   22   0.047  77088|     do
  26 |   22   0.000   1914|         p := nextprime(p);
  27 |   22   0.000      0|         lcmintest := true;
  28 |   22   0.000      0|         for i to m do
  29 |  110   0.000   1811|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   22   0.000     88|     st := time();
  32 |   22   1.407 13490400|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   22   0.000    352|     pt := pt+time()-st;
  34 |   22   0.016  54133|     Rand := rand(1 .. p-1);
  35 |   22   0.000     66|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   22   0.000   1210|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   22   0.000   2002|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   22   0.079 168080|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   22   0.000     88|         st := time();
  42 |   22   0.296 4655486|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   22   0.000    352|         laminpolytime := laminpolytime+time()-st;
  44 |   22   0.000     66|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   22   0.000     88|         M, phimatrix, invphimatrix := LA;
  47 |   22   0.000     88|         st := time();
  48 |   22   2.764 40147985|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   22   2.160 40145394|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   22   0.000    352|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   22   0.000     88|     st := time();
  52 |   22   1.919 17716594|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   22   0.000    352|     pgcdtime := pgcdtime+time()-st;
  54 |   22   0.000    132|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   22   0.000   3278|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   22   0.000     66|     if 1 &lt; m then
  62 |   22   0.000     88|         st := time();
  63 |   22   0.440 7012000|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   22   0.000    352|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   22   0.000     88|     st := time();
  66 |   22   0.015   2288|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   22   0.125 1117160|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   22   0.000    352|     lmt := lmt+time()-st;
  69 |   22   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   21   0.000   1029|         summon := lmCp+minmon;
  76 |   21   0.000  70147|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   21   0.046 101745|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   21   0.000    252|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   21   0.000    375|             H := [op(H), Cp];
  84 |   21   0.000    354|             Np := [op(Np), p];
  85 |   21   0.000     84|             st := time();
  86 |   21   1.795 11602031|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   21   0.000    332|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   22   0.000     88|     st := time();
  89 |   22   0.047 3139837|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   22   0.000    348|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   22   0.000     66|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2438|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     25|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.016 355830|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.015  96498|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  20.984 224799176|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.016     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.031 232226| A := semi(A1);
  12 |    1   0.031 232226| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.016   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   23   0.061  80592|     do
  26 |   23   0.000   2021|         p := nextprime(p);
  27 |   23   0.000      0|         lcmintest := true;
  28 |   23   0.000      0|         for i to m do
  29 |  115   0.000   1911|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   23   0.000     92|     st := time();
  32 |   23   1.485 14103582|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   23   0.000    368|     pt := pt+time()-st;
  34 |   23   0.000  56615|     Rand := rand(1 .. p-1);
  35 |   23   0.000     69|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   23   0.000   1210|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   23   0.000   2093|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   23   0.048 175720|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   23   0.000     92|         st := time();
  42 |   23   0.358 4867099|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   23   0.000    368|         laminpolytime := laminpolytime+time()-st;
  44 |   23   0.000     69|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   23   0.000     92|         M, phimatrix, invphimatrix := LA;
  47 |   23   0.000     92|         st := time();
  48 |   23   2.983 42624007|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   23   2.238 42622570|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   23   0.000    368|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   23   0.000     92|     st := time();
  52 |   23   3.873 42179045|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   23   0.000    368|     pgcdtime := pgcdtime+time()-st;
  54 |   23   0.000    138|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   23   0.000   4600|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   23   0.000     69|     if 1 &lt; m then
  62 |   23   0.000     92|         st := time();
  63 |   23   1.611 21742375|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   23   0.000    368|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   23   0.000     92|     st := time();
  66 |   23   0.000   2392|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   23   0.325 3620558|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   23   0.000    368|     lmt := lmt+time()-st;
  69 |   23   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   22   0.000   1078|         summon := lmCp+minmon;
  76 |   22   0.000  85956|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   22   0.047 225192|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   22   0.000    264|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   22   0.000    404|             H := [op(H), Cp];
  84 |   22   0.000    382|             Np := [op(Np), p];
  85 |   22   0.000     88|             st := time();
  86 |   22   7.456 40510981|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   22   0.000    348|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   23   0.000     92|     st := time();
  89 |   23   0.374 10825100|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   23   0.000    364|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   23   0.000     69|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2456|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.031 465657|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000 123204|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  31.141 310096871|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.047 232226| A := semi(A1);
  12 |    1   0.032 232226| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   21   0.032  73584|     do
  26 |   21   0.015   1818|         p := nextprime(p);
  27 |   21   0.000      0|         lcmintest := true;
  28 |   21   0.000      0|         for i to m do
  29 |  105   0.000   1776|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   21   0.000     84|     st := time();
  32 |   21   1.250 12877218|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   21   0.000    336|     pt := pt+time()-st;
  34 |   21   0.000  51749|     Rand := rand(1 .. p-1);
  35 |   21   0.000     63|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   21   0.000   1185|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   21   0.000   1911|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   21   0.048 160440|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   21   0.000     84|         st := time();
  42 |   21   0.329 4443873|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   21   0.000    336|         laminpolytime := laminpolytime+time()-st;
  44 |   21   0.000     63|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   21   0.000     84|         M, phimatrix, invphimatrix := LA;
  47 |   21   0.000     84|         st := time();
  48 |   21   2.623 39986366|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   21   2.421 39985353|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   21   0.000    336|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   21   0.000     84|     st := time();
  52 |   21   7.081 77003179|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   21   0.000    336|     pgcdtime := pgcdtime+time()-st;
  54 |   21   0.000    126|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   21   0.032   5271|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   21   0.000     63|     if 1 &lt; m then
  62 |   21   0.000     84|         st := time();
  63 |   21   2.639 40165581|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   21   0.000    336|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   21   0.000     84|     st := time();
  66 |   21   0.030   2184|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   21   0.581 6759955|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   21   0.000    336|     lmt := lmt+time()-st;
  69 |   21   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   20   0.000    980|         summon := lmCp+minmon;
  76 |   20   0.000  89488|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   20   0.079 371220|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   20   0.000    240|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   20   0.000    347|             H := [op(H), Cp];
  84 |   20   0.000    327|             Np := [op(Np), p];
  85 |   20   0.000     80|             st := time();
  86 |   20  13.294 67897869|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   20   0.000    316|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   21   0.000     84|     st := time();
  89 |   21   0.577 18998825|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   21   0.000    332|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   21   0.000     63|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2442|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.016    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.015 639588|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000 102354|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  13.875 181887897|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.047 396830| A := semi(A1);
  12 |    1   0.031 396830| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   21   0.061  73584|     do
  26 |   21   0.000   1818|         p := nextprime(p);
  27 |   21   0.000      0|         lcmintest := true;
  28 |   21   0.000      0|         for i to m do
  29 |  105   0.000   1751|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   21   0.000     84|     st := time();
  32 |   21   1.969 21953358|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   21   0.000    336|     pt := pt+time()-st;
  34 |   21   0.016  51568|     Rand := rand(1 .. p-1);
  35 |   21   0.000     63|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   21   0.000   1235|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   21   0.000   1911|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   21   0.063 160440|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   21   0.000     84|         st := time();
  42 |   21   0.310 4448977|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   21   0.000    336|         laminpolytime := laminpolytime+time()-st;
  44 |   21   0.000     63|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   21   0.000     84|         M, phimatrix, invphimatrix := LA;
  47 |   21   0.000     84|         st := time();
  48 |   21   4.564 67302638|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   21   4.455 67311930|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   21   0.000    336|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   21   0.000     84|     st := time();
  52 |   21   1.792 14009866|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   21   0.000    336|     pgcdtime := pgcdtime+time()-st;
  54 |   21   0.000    126|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   21   0.000   2352|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   21   0.000     63|     if 1 &lt; m then
  62 |   21   0.000     84|         st := time();
  63 |   21   0.125 1912437|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   21   0.000    336|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   21   0.000     84|     st := time();
  66 |   21   0.000   2184|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   21   0.016 247590|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   21   0.000    328|     lmt := lmt+time()-st;
  69 |   21   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   20   0.000    100|         summon := lmCp+minmon;
  76 |   20   0.016  57587|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   20   0.000  57620|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   20   0.000    240|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   20   0.000    347|             H := [op(H), Cp];
  84 |   20   0.000    327|             Np := [op(Np), p];
  85 |   20   0.000     80|             st := time();
  86 |   20   0.347 2235419|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   20   0.000    292|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   21   0.000     84|     st := time();
  89 |   21   0.032 652514|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   21   0.000    308|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   21   0.000     63|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2452|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     25|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.031 528113|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000  68634|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  18.594 226743769|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.047 396830| A := semi(A1);
  12 |    1   0.031 396830| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   21   0.015  73584|     do
  26 |   21   0.000   1818|         p := nextprime(p);
  27 |   21   0.000      0|         lcmintest := true;
  28 |   21   0.000      0|         for i to m do
  29 |  105   0.000   1751|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   21   0.000     84|     st := time();
  32 |   21   2.048 21953358|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   21   0.000    336|     pt := pt+time()-st;
  34 |   21   0.000  51566|     Rand := rand(1 .. p-1);
  35 |   21   0.000     63|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   21   0.000   1160|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   21   0.000   1911|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   21   0.077 160440|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   21   0.000     84|         st := time();
  42 |   21   0.312 4443873|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   21   0.000    336|         laminpolytime := laminpolytime+time()-st;
  44 |   21   0.000     63|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   21   0.000     84|         M, phimatrix, invphimatrix := LA;
  47 |   21   0.000     84|         st := time();
  48 |   21   4.671 67300468|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   21   4.845 67299652|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   21   0.000    336|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   21   0.000     84|     st := time();
  52 |   21   3.032 30341483|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   21   0.000    336|     pgcdtime := pgcdtime+time()-st;
  54 |   21   0.000    126|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   21   0.000   3486|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   21   0.000     63|     if 1 &lt; m then
  62 |   21   0.000     84|         st := time();
  63 |   21   0.623 10300007|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   21   0.000    336|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   21   0.000     84|     st := time();
  66 |   21   0.000   2184|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   21   0.218 1677837|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   21   0.000    312|     lmt := lmt+time()-st;
  69 |   21   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   20   0.000    980|         summon := lmCp+minmon;
  76 |   20   0.000  70636|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   20   0.016 126320|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   20   0.000    240|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   20   0.000    347|             H := [op(H), Cp];
  84 |   20   0.000    327|             Np := [op(Np), p];
  85 |   20   0.000     80|             st := time();
  86 |   20   2.518 16610475|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   20   0.000    316|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   21   0.000     84|     st := time();
  89 |   21   0.110 4739292|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   21   0.000    332|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   21   0.000     63|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2452|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     30|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.015 618432|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.016 158748|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  31.110 328686214|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.016     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.031 396830| A := semi(A1);
  12 |    1   0.032 396830| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   20   0.063  70080|     do
  26 |   20   0.000   1733|         p := nextprime(p);
  27 |   20   0.000      0|         lcmintest := true;
  28 |   20   0.000      0|         for i to m do
  29 |  100   0.000   1686|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   20   0.000     80|     st := time();
  32 |   20   2.093 20908363|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   20   0.000    320|     pt := pt+time()-st;
  34 |   20   0.000  49196|     Rand := rand(1 .. p-1);
  35 |   20   0.000     60|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   20   0.000   1010|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   20   0.000   1820|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   20   0.127 152800|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   20   0.000     80|         st := time();
  42 |   20   0.281 4232260|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   20   0.000    320|         laminpolytime := laminpolytime+time()-st;
  44 |   20   0.000     60|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   20   0.000     80|         M, phimatrix, invphimatrix := LA;
  47 |   20   0.000     80|         st := time();
  48 |   20   4.264 65350257|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   20   4.548 65605098|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   20   0.000    320|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   20   0.000     80|     st := time();
  52 |   20   6.186 70088227|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   20   0.000    320|     pgcdtime := pgcdtime+time()-st;
  54 |   20   0.000    120|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   20   0.016   4680|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   20   0.000     60|     if 1 &lt; m then
  62 |   20   0.000     80|         st := time();
  63 |   20   2.548 31107537|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   20   0.000    320|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   20   0.000     80|     st := time();
  66 |   20   0.048   2080|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   20   0.454 5212926|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   20   0.000    320|     lmt := lmt+time()-st;
  69 |   20   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   19   0.000    931|         summon := lmCp+minmon;
  76 |   19   0.000  81439|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   19   0.107 293740|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   19   0.000    228|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   19   0.000    320|             H := [op(H), Cp];
  84 |   19   0.000    301|             Np := [op(Np), p];
  85 |   19   0.000     76|             st := time();
  86 |   19   8.983 49242742|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   19   0.000    300|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   20   0.000     80|     st := time();
  89 |   20   1.219 14458662|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   20   0.000    316|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   20   0.000     60|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2442|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     25|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.078 809953|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.016 204924|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  72.359 655813916|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.093 396830| A := semi(A1);
  12 |    1   0.063 396830| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   24   0.185  84096|     do
  26 |   24   0.000   2227|         p := nextprime(p);
  27 |   24   0.000      0|         lcmintest := true;
  28 |   24   0.000      0|         for i to m do
  29 |  120   0.000   2051|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   24   0.000     96|     st := time();
  32 |   24   2.424 25089955|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   24   0.000    384|     pt := pt+time()-st;
  34 |   24   0.000  59127|     Rand := rand(1 .. p-1);
  35 |   24   0.000     72|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   24   0.000   1300|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   24   0.000   2184|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   24   0.047 183360|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   24   0.000     96|         st := time();
  42 |   24   0.420 5078712|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   24   0.000    384|         laminpolytime := laminpolytime+time()-st;
  44 |   24   0.000     72|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   24   0.000     96|         M, phimatrix, invphimatrix := LA;
  47 |   24   0.000     96|         st := time();
  48 |   24   6.156 80032080|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   24   4.439 80028358|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   24   0.000    384|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   24   0.000     96|     st := time();
  52 |   24  15.653 177045619|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   24   0.000    384|     pgcdtime := pgcdtime+time()-st;
  54 |   24   0.000    144|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   24   0.000   7248|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   24   0.000     72|     if 1 &lt; m then
  62 |   24   0.000     96|         st := time();
  63 |   24   7.159 77162952|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   24   0.000    384|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   24   0.000     96|     st := time();
  66 |   24   0.126   2496|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   24   1.265 13063378|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   24   0.000    384|     lmt := lmt+time()-st;
  69 |   24   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   23   0.000   1127|         summon := lmCp+minmon;
  76 |   23   0.000 115943|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   23   0.157 685860|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   23   0.000    276|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   23   0.000    434|             H := [op(H), Cp];
  84 |   23   0.000    411|             Np := [op(Np), p];
  85 |   23   0.000     92|             st := time();
  86 |   23  32.984 155369560|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   23   0.000    368|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   24   0.000     96|     st := time();
  89 |   24   1.125 39678246|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   24   0.000    384|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   24   0.000     72|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2456|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     40|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.063 1146374|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000 166556|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  21.110 284591732|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.063 605306| A := semi(A1);
  12 |    1   0.047 605306| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   22   0.093  77088|     do
  26 |   22   0.000   1914|         p := nextprime(p);
  27 |   22   0.000      0|         lcmintest := true;
  28 |   22   0.000      0|         for i to m do
  29 |  110   0.000   1846|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   22   0.000     88|     st := time();
  32 |   22   3.059 35040500|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   22   0.000    352|     pt := pt+time()-st;
  34 |   22   0.000  53991|     Rand := rand(1 .. p-1);
  35 |   22   0.000     66|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   22   0.000   1195|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   22   0.000   2002|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   22   0.158 168080|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   22   0.000     88|         st := time();
  42 |   22   0.282 4655756|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   22   0.000    352|         laminpolytime := laminpolytime+time()-st;
  44 |   22   0.000     66|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   22   0.000     88|         M, phimatrix, invphimatrix := LA;
  47 |   22   0.000     88|         st := time();
  48 |   22   6.938 108065029|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   22   6.952 108066041|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   22   0.000    352|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   22   0.000     88|     st := time();
  52 |   22   2.811 20765618|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   22   0.000    352|     pgcdtime := pgcdtime+time()-st;
  54 |   22   0.000    132|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   22   0.000   2464|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   22   0.000     66|     if 1 &lt; m then
  62 |   22   0.000     88|         st := time();
  63 |   22   0.079 2001975|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   22   0.000    352|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   22   0.000     88|     st := time();
  66 |   22   0.000   2288|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   22   0.063 259380|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   22   0.000    296|     lmt := lmt+time()-st;
  69 |   22   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   21   0.000    105|         summon := lmCp+minmon;
  76 |   21   0.000  60508|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   21   0.000  60501|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   21   0.000    252|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   21   0.000    375|             H := [op(H), Cp];
  84 |   21   0.000    354|             Np := [op(Np), p];
  85 |   21   0.000     84|             st := time();
  86 |   21   0.408 2480607|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   21   0.000    324|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   22   0.000     88|     st := time();
  89 |   22   0.032 678533|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   22   0.000    340|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   22   0.000     66|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2438|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     35|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.109 839865|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.016  84994|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  31.469 381959419|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.016     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.140 605306| A := semi(A1);
  12 |    1   0.125 605306| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   23   0.109  80592|     do
  26 |   23   0.000   2021|         p := nextprime(p);
  27 |   23   0.000      0|         lcmintest := true;
  28 |   23   0.000      0|         for i to m do
  29 |  115   0.000   1936|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   23   0.000     92|     st := time();
  32 |   23   4.438 36634049|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   23   0.000    368|     pt := pt+time()-st;
  34 |   23   0.000  56577|     Rand := rand(1 .. p-1);
  35 |   23   0.000     69|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   23   0.000   1225|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   23   0.000   2093|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   23   0.110 175720|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   23   0.000     92|         st := time();
  42 |   23   0.377 4867234|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   23   0.000    368|         laminpolytime := laminpolytime+time()-st;
  44 |   23   0.000     69|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   23   0.000     92|         M, phimatrix, invphimatrix := LA;
  47 |   23   0.000     92|         st := time();
  48 |   23   7.076 113616725|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   23   6.795 114079367|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   23   0.000    368|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   23   0.000     92|     st := time();
  52 |   23   5.577 53747578|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   23   0.000    368|     pgcdtime := pgcdtime+time()-st;
  54 |   23   0.000    138|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   23   0.000   4209|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   23   0.000     69|     if 1 &lt; m then
  62 |   23   0.000     92|         st := time();
  63 |   23   1.176 16063152|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   23   0.000    368|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   23   0.000     92|     st := time();
  66 |   23   0.000   2392|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   23   0.219 2655179|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   23   0.000    352|     lmt := lmt+time()-st;
  69 |   23   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   22   0.000   1078|         summon := lmCp+minmon;
  76 |   22   0.015  81885|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   22   0.031 178486|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   22   0.000    264|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   22   0.000    404|             H := [op(H), Cp];
  84 |   22   0.000    382|             Np := [op(Np), p];
  85 |   22   0.000     88|             st := time();
  86 |   22   4.890 29601648|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   22   0.000    348|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   23   0.000     92|     st := time();
  89 |   23   0.328 7673727|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   23   0.000    364|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   23   0.000     69|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2456|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     30|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.031 973924|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.016 236850|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  60.469 606660987|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.062 605306| A := semi(A1);
  12 |    1   0.063 605306| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   23   0.142  80592|     do
  26 |   23   0.000   2021|         p := nextprime(p);
  27 |   23   0.000      0|         lcmintest := true;
  28 |   23   0.000      0|         for i to m do
  29 |  115   0.015   1966|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   23   0.000     92|     st := time();
  32 |   23   4.746 36635258|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   23   0.000    368|     pt := pt+time()-st;
  34 |   23   0.000  56582|     Rand := rand(1 .. p-1);
  35 |   23   0.000     69|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   23   0.000   1370|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   23   0.000   2093|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   23   0.126 175720|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   23   0.000     92|         st := time();
  42 |   23   0.502 4867502|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   23   0.000    368|         laminpolytime := laminpolytime+time()-st;
  44 |   23   0.000     69|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   23   0.000     92|         M, phimatrix, invphimatrix := LA;
  47 |   23   0.000     92|         st := time();
  48 |   23   6.934 117595997|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   23   7.098 117502092|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   23   0.000    368|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   23   0.000     92|     st := time();
  52 |   23  13.811 137307256|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   23   0.000    368|     pgcdtime := pgcdtime+time()-st;
  54 |   23   0.000    138|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   23   0.016   6164|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   23   0.000     69|     if 1 &lt; m then
  62 |   23   0.000     92|         st := time();
  63 |   23   4.668 53132330|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   23   0.000    368|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   23   0.000     92|     st := time();
  66 |   23   0.015   2392|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   23   1.785 8962617|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   23   0.000    368|     lmt := lmt+time()-st;
  69 |   23   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   22   0.000   1078|         summon := lmCp+minmon;
  76 |   22   0.016 102630|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   22   0.108 483736|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   22   0.000    264|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   22   0.000    404|             H := [op(H), Cp];
  84 |   22   0.000    382|             Np := [op(Np), p];
  85 |   22   0.000     88|             st := time();
  86 |   22  19.471 100908497|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   22   0.000    348|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   23   0.000     92|     st := time();
  89 |   23   0.813 26020331|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   23   0.000    364|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   23   0.000     69|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2449|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.062 1283212|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.016 307780|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1 132.000 1090349388|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.015     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.125 605306| A := semi(A1);
  12 |    1   0.125 605306| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   25   0.158  87600|     do
  26 |   25   0.000   2257|         p := nextprime(p);
  27 |   25   0.000      0|         lcmintest := true;
  28 |   25   0.000      0|         for i to m do
  29 |  125   0.000   2136|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   25   0.000    100|     st := time();
  32 |   25   4.220 39819549|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   25   0.000    400|     pt := pt+time()-st;
  34 |   25   0.000  61539|     Rand := rand(1 .. p-1);
  35 |   25   0.000     75|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   25   0.000   1270|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   25   0.000   2275|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   25   0.108 191000|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   25   0.000    100|         st := time();
  42 |   25   0.390 5290325|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   25   0.000    400|         laminpolytime := laminpolytime+time()-st;
  44 |   25   0.000     75|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   25   0.000    100|         M, phimatrix, invphimatrix := LA;
  47 |   25   0.000    100|         st := time();
  48 |   25   6.420 126505276|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   25   7.379 126517053|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   25   0.000    400|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   25   0.000    100|     st := time();
  52 |   25  31.091 323025522|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   25   0.000    400|     pgcdtime := pgcdtime+time()-st;
  54 |   25   0.000    150|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   25   0.016   8825|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   25   0.000     75|     if 1 &lt; m then
  62 |   25   0.000    100|         st := time();
  63 |   25  10.393 122836804|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   25   0.000    400|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   25   0.000    100|     st := time();
  66 |   25   0.092   2600|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   25   2.704 20613964|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   25   0.000    400|     lmt := lmt+time()-st;
  69 |   25   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   24   0.000   1176|         summon := lmCp+minmon;
  76 |   24   0.016 134520|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   24   0.280 1056312|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   24   0.000    288|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   24   0.000    465|             H := [op(H), Cp];
  84 |   24   0.000    441|             Np := [op(Np), p];
  85 |   24   0.000     96|             st := time();
  86 |   24  64.764 258376987|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   24   0.000    384|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   25   0.000    100|     st := time();
  89 |   25   3.610 62523482|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   25   0.000    400|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   25   0.000     75|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2449|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     25|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.078 1820014|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.016 246610|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  30.344 389850107|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.094 857654| A := semi(A1);
  12 |    1   0.078 857654| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   21   0.204  73584|     do
  26 |   21   0.000   1818|         p := nextprime(p);
  27 |   21   0.000      0|         lcmintest := true;
  28 |   21   0.000      0|         for i to m do
  29 |  105   0.000   1796|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   21   0.000     84|     st := time();
  32 |   21   4.298 47359998|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   21   0.000    336|     pt := pt+time()-st;
  34 |   21   0.000  51677|     Rand := rand(1 .. p-1);
  35 |   21   0.000     63|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   21   0.000   1160|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   21   0.000   1911|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   21   0.139 160440|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   21   0.000     84|         st := time();
  42 |   21   0.297 4443873|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   21   0.000    336|         laminpolytime := laminpolytime+time()-st;
  44 |   21   0.000     63|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   21   0.000     84|         M, phimatrix, invphimatrix := LA;
  47 |   21   0.000     84|         st := time();
  48 |   21   7.783 151208904|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   21  12.997 151261146|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   21   0.000    336|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   21   0.000     84|     st := time();
  52 |   21   3.908 27043059|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   21   0.000    336|     pgcdtime := pgcdtime+time()-st;
  54 |   21   0.000    126|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   21   0.000   2352|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   21   0.000     63|     if 1 &lt; m then
  62 |   21   0.000     84|         st := time();
  63 |   21   0.157 1913323|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   21   0.000    336|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   21   0.000     84|     st := time();
  66 |   21   0.000   2184|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   21   0.016 247590|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   21   0.000    296|     lmt := lmt+time()-st;
  69 |   21   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   20   0.000    100|         summon := lmCp+minmon;
  76 |   20   0.000  57740|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   20   0.015  57620|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   20   0.000    240|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   20   0.000    347|             H := [op(H), Cp];
  84 |   20   0.000    327|             Np := [op(Np), p];
  85 |   20   0.000     80|             st := time();
  86 |   20   0.296 2234469|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   20   0.000    276|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   21   0.000     84|     st := time();
  89 |   21   0.000 637185|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   21   0.000    292|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   21   0.000     63|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2452|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.047 1260974|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.015 101354|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  43.391 525860191|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.016     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.078 857654| A := semi(A1);
  12 |    1   0.078 857654| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   22   0.126  77088|     do
  26 |   22   0.000   1914|         p := nextprime(p);
  27 |   22   0.000      0|         lcmintest := true;
  28 |   22   0.000      0|         for i to m do
  29 |  110   0.000   1881|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   22   0.000     88|     st := time();
  32 |   22   4.956 49616438|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   22   0.000    352|     pt := pt+time()-st;
  34 |   22   0.000  54173|     Rand := rand(1 .. p-1);
  35 |   22   0.016     66|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   22   0.000   1145|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   22   0.000   2002|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   22   0.185 168080|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   22   0.000     88|         st := time();
  42 |   22   0.360 4655486|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   22   0.000    352|         laminpolytime := laminpolytime+time()-st;
  44 |   22   0.000     66|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   22   0.000     88|         M, phimatrix, invphimatrix := LA;
  47 |   22   0.000     88|         st := time();
  48 |   22  10.030 158967627|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   22  11.046 158960588|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   22   0.000    352|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   22   0.000     88|     st := time();
  52 |   22   8.019 78548944|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   22   0.000    352|     pgcdtime := pgcdtime+time()-st;
  54 |   22   0.000    132|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   22   0.000   4400|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   22   0.000     66|     if 1 &lt; m then
  62 |   22   0.000     88|         st := time();
  63 |   22   1.762 20790109|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   22   0.000    352|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   22   0.000     88|     st := time();
  66 |   22   0.000   2288|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   22   0.359 3463156|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   22   0.000    352|     lmt := lmt+time()-st;
  69 |   22   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   21   0.000   1029|         summon := lmCp+minmon;
  76 |   21   0.000  82173|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   21   0.079 214956|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   21   0.000    252|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   21   0.000    375|             H := [op(H), Cp];
  84 |   21   0.000    354|             Np := [op(Np), p];
  85 |   21   0.000     84|             st := time();
  86 |   21   5.812 36667848|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   21   0.000    332|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   22   0.000     88|     st := time();
  89 |   22   0.359 10072824|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   22   0.000    348|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   22   0.000     66|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2428|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     25|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.063 1449038|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.047 330804|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  89.469 881134003|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.032     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.171 857654| A := semi(A1);
  12 |    1   0.204 857654| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   23   0.092  80592|     do
  26 |   23   0.000   2021|         p := nextprime(p);
  27 |   23   0.000      0|         lcmintest := true;
  28 |   23   0.000      0|         for i to m do
  29 |  115   0.000   1966|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   23   0.000     92|     st := time();
  32 |   23   5.732 51910931|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   23   0.000    368|     pt := pt+time()-st;
  34 |   23   0.000  56587|     Rand := rand(1 .. p-1);
  35 |   23   0.000     69|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   23   0.000   1210|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   23   0.000   2093|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   23   0.173 175720|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   23   0.000     92|         st := time();
  42 |   23   0.313 4867099|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   23   0.000    368|         laminpolytime := laminpolytime+time()-st;
  44 |   23   0.000     69|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   23   0.000     92|         M, phimatrix, invphimatrix := LA;
  47 |   23   0.000     92|         st := time();
  48 |   23   9.049 168969114|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   23   9.324 168879820|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   23   0.000    368|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   23   0.000     92|     st := time();
  52 |   23  26.609 217075212|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   23   0.000    368|     pgcdtime := pgcdtime+time()-st;
  54 |   23   0.000    138|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   23   0.031   6946|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   23   0.000     69|     if 1 &lt; m then
  62 |   23   0.000     92|         st := time();
  63 |   23   5.736 73915540|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   23   0.000    368|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   23   0.000     92|     st := time();
  66 |   23   0.015   2392|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   23   1.769 12519401|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   23   0.000    368|     lmt := lmt+time()-st;
  69 |   23   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   22   0.000   1078|         summon := lmCp+minmon;
  76 |   22   0.000 110902|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   22   0.125 656040|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   22   0.000    264|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   22   0.000    404|             H := [op(H), Cp];
  84 |   22   0.000    382|             Np := [op(Np), p];
  85 |   22   0.000     88|             st := time();
  86 |   22  27.625 141165159|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   22   0.000    348|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   23   0.000     92|     st := time();
  89 |   23   2.282 36703229|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   23   0.000    364|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   23   0.000     69|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2442|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.016    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.140 1872719|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.031 431772|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    2 175.171 1609375244|
   1 |    2   0.000      0| timings := true;
   2 |    2   0.000      8| tt := time();
   3 |    2   0.000      0| pt := 0;
   4 |    2   0.000      0| lmt := 0;
   5 |    2   0.000      0| laminpolytime := 0;
   6 |    2   0.000      0| phigammatime := 0;
   7 |    2   0.000      0| pgcdtime := 0;
   8 |    2   0.000      0| CRTRNRtime := 0;
   9 |    2   0.000      0| divtime := 0;
  10 |    2   0.015    146| A1, B1, ring := ConvRing(A0,B0);
  11 |    2   0.188 2011528| A := semi(A1);
  12 |    2   0.328 2011933| B := semi(B1);
  13 |    2   0.000      8| Char, X, E := op(ring);
  14 |    2   0.000      0| n := nops(X);
  15 |    2   0.000      0| m := nops(E);
  16 |    2   0.000      0| k := n-m;
  17 |    2   0.000     16| Xpoly := X[1 .. k];
  18 |    2   0.000     42| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    2   0.000   1462| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    2   0.000   4568| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    2   0.000      0| H := [];
  22 |    2   0.000      0| Np := [];
  23 |    2   0.000      0| p := 2147483648;
  24 |    2   0.015      0| do
  25 |   40   0.341 140160|     do
  26 |   40   0.000   3466|         p := nextprime(p);
  27 |   40   0.000      0|         lcmintest := true;
  28 |   40   0.000      0|         for i to m do
  29 |  200   0.000   3422|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   40   0.000    160|     st := time();
  32 |   40  10.721 105763209|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   40   0.000    640|     pt := pt+time()-st;
  34 |   40   0.000  98397|     Rand := rand(1 .. p-1);
  35 |   40   0.000    120|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   40   0.000   2320|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   40   0.000   3640|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   40   0.373 305600|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   40   0.000    160|         st := time();
  42 |   40   0.594 8464520|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   40   0.000    640|         laminpolytime := laminpolytime+time()-st;
  44 |   40   0.000    120|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   40   0.000    160|         M, phimatrix, invphimatrix := LA;
  47 |   40   0.000    160|         st := time();
  48 |   40  22.389 337445936|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   40  26.157 337532861|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   40   0.000    640|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   40   0.000    160|     st := time();
  52 |   40  45.361 449125085|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   40   0.000    640|     pgcdtime := pgcdtime+time()-st;
  54 |   40   0.000    240|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   40   0.032  10320|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   40   0.000    120|     if 1 &lt; m then
  62 |   40   0.000    160|         st := time();
  63 |   40  11.455 140059688|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   40   0.000    640|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   40   0.000    160|     st := time();
  66 |   40   0.077   4160|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   40   3.376 23488345|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   40   0.000    484|     lmt := lmt+time()-st;
  69 |   40   0.000      0|     if not assigned(minmon) then
  70 |    2   0.000      0|         CRT := Cp;
  71 |    2   0.000      0|         minmon := lmCp;
  72 |    2   0.000      0|         summon := minmon;
  73 |    2   0.000      0|         least := minmon;
  74 |    2   0.000      8|         H := [Cp]
                                else
  75 |   38   0.000   1026|         summon := lmCp+minmon;
  76 |   38   0.047 172064|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   38   0.264 1216399|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   38   0.000    456|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   38   0.000    640|             H := [op(H), Cp];
  84 |   38   0.000    602|             Np := [op(Np), p];
  85 |   38   0.000    152|             st := time();
  86 |   38  53.329 198923980|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   37   0.000    556|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   39   0.000    156|     st := time();
  89 |   39   0.031 650345|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   39   0.000    588|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   39   0.000    117|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2424|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.063 1801400|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.015 117714|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  62.078 713042405|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.016     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.125 1153874| A := semi(A1);
  12 |    1   0.109 1153874| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   22   0.158  77088|     do
  26 |   22   0.000   1914|         p := nextprime(p);
  27 |   22   0.000      0|         lcmintest := true;
  28 |   22   0.000      0|         for i to m do
  29 |  110   0.016   1881|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   22   0.000     88|     st := time();
  32 |   22   9.279 66726950|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   22   0.000    352|     pt := pt+time()-st;
  34 |   22   0.015  54086|     Rand := rand(1 .. p-1);
  35 |   22   0.000     66|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   22   0.000   1165|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   22   0.000   2002|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   22   0.281 168080|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   22   0.000     88|         st := time();
  42 |   22   0.595 4655889|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   22   0.000    352|         laminpolytime := laminpolytime+time()-st;
  44 |   22   0.000     66|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   22   0.000     88|         M, phimatrix, invphimatrix := LA;
  47 |   22   0.000     88|         st := time();
  48 |   22  15.138 214267453|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   22  14.392 214241431|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   22   0.000    352|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   22   0.000     88|     st := time();
  52 |   22  10.299 114810818|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   22   0.000    352|     pgcdtime := pgcdtime+time()-st;
  54 |   22   0.000    132|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   22   0.000   4774|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   22   0.000     66|     if 1 &lt; m then
  62 |   22   0.000     88|         st := time();
  63 |   22   1.811 27145058|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   22   0.000    352|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   22   0.000     88|     st := time();
  66 |   22   0.015   2288|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   22   0.436 4527952|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   22   0.000    352|     lmt := lmt+time()-st;
  69 |   22   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   21   0.000   1029|         summon := lmCp+minmon;
  76 |   21   0.000  86121|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   21   0.064 266385|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   21   0.000    252|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   21   0.000    375|             H := [op(H), Cp];
  84 |   21   0.000    354|             Np := [op(Np), p];
  85 |   21   0.000     84|             st := time();
  86 |   21   8.455 48052419|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   21   0.000    332|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   22   0.000     88|     st := time();
  89 |   22   0.655 13171440|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   22   0.000    348|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   22   0.000     66|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2459|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.172 2016906|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.047 440610|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  98.859 967758657|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.031     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.266 1153874| A := semi(A1);
  12 |    1   0.265 1153874| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   19   0.126  66576|     do
  26 |   19   0.000   1714|         p := nextprime(p);
  27 |   19   0.000      0|         lcmintest := true;
  28 |   19   0.000      0|         for i to m do
  29 |   95   0.000   1626|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   19   0.000     76|     st := time();
  32 |   19   6.232 57744250|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   19   0.000    304|     pt := pt+time()-st;
  34 |   19   0.000  46853|     Rand := rand(1 .. p-1);
  35 |   19   0.000     57|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   19   0.000   1020|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   19   0.000   1729|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   19   0.157 145160|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   19   0.000     76|         st := time();
  42 |   19   0.252 4020647|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   19   0.000    304|         laminpolytime := laminpolytime+time()-st;
  44 |   19   0.000     57|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   19   0.000     76|         M, phimatrix, invphimatrix := LA;
  47 |   19   0.000     76|         st := time();
  48 |   19  11.532 189288899|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   19  14.310 189342723|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   19   0.000    304|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   19   0.000     76|     st := time();
  52 |   19  27.625 265926073|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   19   0.000    304|     pgcdtime := pgcdtime+time()-st;
  54 |   19   0.000    114|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   19   0.000   6384|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   19   0.000     57|     if 1 &lt; m then
  62 |   19   0.000     76|         st := time();
  63 |   19   9.688 81049329|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   19   0.000    304|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   19   0.000     76|     st := time();
  66 |   19   0.016   1976|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   19   1.265 13769026|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   19   0.000    304|     lmt := lmt+time()-st;
  69 |   19   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   18   0.000    882|         summon := lmCp+minmon;
  76 |   18   0.000  97506|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   18   0.202 701208|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   18   0.000    216|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   18   0.000    294|             H := [op(H), Cp];
  84 |   18   0.000    276|             Np := [op(Np), p];
  85 |   18   0.000     72|             st := time();
  86 |   18  24.034 122582390|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   18   0.000    284|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   19   0.000     76|     st := time();
  89 |   19   2.717 37493654|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   19   0.000    300|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   19   0.000     57|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2448|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.016    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.094 2574218|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.031 576900|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    2 196.640 1879304800|
   1 |    2   0.000      0| timings := true;
   2 |    2   0.000      8| tt := time();
   3 |    2   0.000      0| pt := 0;
   4 |    2   0.000      0| lmt := 0;
   5 |    2   0.000      0| laminpolytime := 0;
   6 |    2   0.000      0| phigammatime := 0;
   7 |    2   0.000      0| pgcdtime := 0;
   8 |    2   0.000      0| CRTRNRtime := 0;
   9 |    2   0.000      0| divtime := 0;
  10 |    2   0.031    146| A1, B1, ring := ConvRing(A0,B0);
  11 |    2   0.266 2647840| A := semi(A1);
  12 |    2   0.266 2647840| B := semi(B1);
  13 |    2   0.000      8| Char, X, E := op(ring);
  14 |    2   0.000      0| n := nops(X);
  15 |    2   0.000      0| m := nops(E);
  16 |    2   0.000      0| k := n-m;
  17 |    2   0.000     16| Xpoly := X[1 .. k];
  18 |    2   0.000     42| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    2   0.000   1462| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    2   0.000   4568| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    2   0.000      0| H := [];
  22 |    2   0.000      0| Np := [];
  23 |    2   0.000      0| p := 2147483648;
  24 |    2   0.000      0| do
  25 |   38   0.410 133152|     do
  26 |   38   0.000   3428|         p := nextprime(p);
  27 |   38   0.000      0|         lcmintest := true;
  28 |   38   0.000      0|         for i to m do
  29 |  190   0.000   3252|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   38   0.000    152|     st := time();
  32 |   38  17.062 134891873|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   38   0.000    608|     pt := pt+time()-st;
  34 |   38   0.000  93566|     Rand := rand(1 .. p-1);
  35 |   38   0.015    114|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   38   0.000   2150|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   38   0.000   3458|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   38   0.470 290320|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   38   0.000    152|         st := time();
  42 |   38   0.777 8041294|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   38   0.000    608|         laminpolytime := laminpolytime+time()-st;
  44 |   38   0.000    114|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   38   0.000    152|         M, phimatrix, invphimatrix := LA;
  47 |   38   0.000    152|         st := time();
  48 |   38  33.566 429993518|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   38  28.077 430080266|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   38   0.000    608|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   38   0.000    152|     st := time();
  52 |   38  56.030 534702029|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   37   0.000    592|     pgcdtime := pgcdtime+time()-st;
  54 |   37   0.000    222|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   37   0.046   9289|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   37   0.000    111|     if 1 &lt; m then
  62 |   37   0.000    148|         st := time();
  63 |   37  10.909 140757037|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   37   0.000    592|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   37   0.000    148|     st := time();
  66 |   37   0.080   3848|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   37   2.779 23655055|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   37   0.000    520|     lmt := lmt+time()-st;
  69 |   37   0.000      0|     if not assigned(minmon) then
  70 |    2   0.000      0|         CRT := Cp;
  71 |    2   0.000      0|         minmon := lmCp;
  72 |    2   0.000      0|         summon := minmon;
  73 |    2   0.000      0|         least := minmon;
  74 |    2   0.000      8|         H := [Cp]
                                else
  75 |   35   0.000    791|         summon := lmCp+minmon;
  76 |   35   0.047 154889|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   35   0.266 1197315|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   35   0.000    420|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   35   0.000    575|             H := [op(H), Cp];
  84 |   35   0.000    540|             Np := [op(Np), p];
  85 |   35   0.000    140|             st := time();
  86 |   35  45.153 166667272|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   35   0.000    528|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   37   0.000    148|     st := time();
  89 |   37   0.125 699812|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   37   0.000    560|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   37   0.000    111|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2445|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.250 2474189|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.015 134074|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  72.078 842212800|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.016     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.141 1493966| A := semi(A1);
  12 |    1   0.140 1493966| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   20   0.219  70080|     do
  26 |   20   0.000   1733|         p := nextprime(p);
  27 |   20   0.000      0|         lcmintest := true;
  28 |   20   0.000      0|         for i to m do
  29 |  100   0.000   1711|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   20   0.000     80|     st := time();
  32 |   20   9.702 78515634|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   20   0.000    320|     pt := pt+time()-st;
  34 |   20   0.000  49244|     Rand := rand(1 .. p-1);
  35 |   20   0.000     60|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   20   0.000   1155|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   20   0.000   1820|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   20   0.282 152800|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   20   0.000     80|         st := time();
  42 |   20   0.703 4232663|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   20   0.000    320|         laminpolytime := laminpolytime+time()-st;
  44 |   20   0.000     60|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   20   0.000     80|         M, phimatrix, invphimatrix := LA;
  47 |   20   0.000     80|         st := time();
  48 |   20  15.953 253794312|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   20  18.781 253810045|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   20   0.000    320|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   20   0.000     80|     st := time();
  52 |   20  13.534 144613824|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   20   0.000    320|     pgcdtime := pgcdtime+time()-st;
  54 |   20   0.000    120|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   20   0.000   4680|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   20   0.000     60|     if 1 &lt; m then
  62 |   20   0.000     80|         st := time();
  63 |   20   2.357 31117607|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   20   0.000    320|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   20   0.000     80|     st := time();
  66 |   20   0.000   2080|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   20   0.827 5213329|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   20   0.000    320|     lmt := lmt+time()-st;
  69 |   20   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   19   0.000    931|         summon := lmCp+minmon;
  76 |   19   0.000  81491|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   19   0.016 293740|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   19   0.000    228|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   19   0.000    320|             H := [op(H), Cp];
  84 |   19   0.000    301|             Np := [op(Np), p];
  85 |   19   0.000     76|             st := time();
  86 |   19   8.548 49222556|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   19   0.000    300|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   20   0.000     80|     st := time();
  89 |   20   0.734 14728906|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   20   0.000    316|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   20   0.000     60|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2449|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.094 2737847|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.031 566268|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    3 330.389 3385540750|
   1 |    3   0.000      0| timings := true;
   2 |    3   0.000     12| tt := time();
   3 |    3   0.000      0| pt := 0;
   4 |    3   0.000      0| lmt := 0;
   5 |    3   0.000      0| laminpolytime := 0;
   6 |    3   0.000      0| phigammatime := 0;
   7 |    3   0.000      0| pgcdtime := 0;
   8 |    3   0.000      0| CRTRNRtime := 0;
   9 |    3   0.000      0| divtime := 0;
  10 |    3   0.077    219| A1, B1, ring := ConvRing(A0,B0);
  11 |    3   0.516 4865862| A := semi(A1);
  12 |    3   0.640 4866267| B := semi(B1);
  13 |    3   0.000     12| Char, X, E := op(ring);
  14 |    3   0.000      0| n := nops(X);
  15 |    3   0.000      0| m := nops(E);
  16 |    3   0.000      0| k := n-m;
  17 |    3   0.000     24| Xpoly := X[1 .. k];
  18 |    3   0.000     63| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    3   0.000   2193| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    3   0.000   6852| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    3   0.000      0| H := [];
  22 |    3   0.000      0| Np := [];
  23 |    3   0.000      0| p := 2147483648;
  24 |    3   0.000      0| do
  25 |   56   0.673 196224|     do
  26 |   56   0.000   4980|         p := nextprime(p);
  27 |   56   0.000      0|         lcmintest := true;
  28 |   56   0.000      0|         for i to m do
  29 |  280   0.016   4793|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   56   0.000    224|     st := time();
  32 |   56  24.143 239490034|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   55   0.000    880|     pt := pt+time()-st;
  34 |   55   0.016 135329|     Rand := rand(1 .. p-1);
  35 |   55   0.000    165|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   55   0.000   3075|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   55   0.000   5005|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   55   0.653 420200|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   55   0.000    220|         st := time();
  42 |   55   0.921 11638715|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   55   0.000    864|         laminpolytime := laminpolytime+time()-st;
  44 |   55   0.000    165|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   55   0.000    220|         M, phimatrix, invphimatrix := LA;
  47 |   55   0.000    220|         st := time();
  48 |   55  58.094 772704573|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   55  62.156 772346327|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   55   0.000    880|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   55   0.000    220|     st := time();
  52 |   55  99.614 996452326|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   54   0.000    864|     pgcdtime := pgcdtime+time()-st;
  54 |   54   0.000    324|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   54   0.016  15678|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   54   0.000    162|     if 1 &lt; m then
  62 |   54   0.000    216|         st := time();
  63 |   54  18.199 251098613|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   54   0.000    864|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   54   0.000    216|     st := time();
  66 |   54   0.172   5616|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   54   4.778 42122512|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   54   0.000    712|     lmt := lmt+time()-st;
  69 |   54   0.000      0|     if not assigned(minmon) then
  70 |    3   0.000      0|         CRT := Cp;
  71 |    3   0.000      0|         minmon := lmCp;
  72 |    3   0.000      0|         summon := minmon;
  73 |    3   0.000      0|         least := minmon;
  74 |    3   0.000     12|         H := [Cp]
                                else
  75 |   51   0.000   1531|         summon := lmCp+minmon;
  76 |   51   0.000 248055|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   51   0.471 2098666|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   51   0.000    612|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   51   0.000    838|             H := [op(H), Cp];
  84 |   51   0.000    787|             Np := [op(Np), p];
  85 |   51   0.000    204|             st := time();
  86 |   51  58.828 282571937|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   51   0.000    796|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   54   0.000    216|     st := time();
  89 |   54   0.172 817020|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   54   0.000    844|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   54   0.000    162|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2452|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.219 3252891|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.015 150434|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  97.391 1130072271|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.031     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.188 1877930| A := semi(A1);
  12 |    1   0.203 1877930| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   21   0.328  73584|     do
  26 |   21   0.000   1818|         p := nextprime(p);
  27 |   21   0.000      0|         lcmintest := true;
  28 |   21   0.000      0|         for i to m do
  29 |  105   0.000   1796|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   21   0.000     84|     st := time();
  32 |   21  11.562 103607866|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   21   0.000    336|     pt := pt+time()-st;
  34 |   21   0.000  51691|     Rand := rand(1 .. p-1);
  35 |   21   0.000     63|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   21   0.000   1185|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   21   0.000   1911|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   21   0.282 160440|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   21   0.000     84|         st := time();
  42 |   21   0.610 4444269|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   21   0.000    328|         laminpolytime := laminpolytime+time()-st;
  44 |   21   0.000     63|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   21   0.000     84|         M, phimatrix, invphimatrix := LA;
  47 |   21   0.000     84|         st := time();
  48 |   21  18.217 339283836|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   21  29.674 339386988|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   21   0.000    336|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   21   0.000     84|     st := time();
  52 |   21  18.219 201059295|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   21   0.000    336|     pgcdtime := pgcdtime+time()-st;
  54 |   21   0.000    126|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   21   0.032   5271|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   21   0.000     63|     if 1 &lt; m then
  62 |   21   0.000     84|         st := time();
  63 |   21   3.483 40216492|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   21   0.000    336|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   21   0.000     84|     st := time();
  66 |   21   0.000   2184|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   21   0.734 6759955|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   21   0.000    336|     lmt := lmt+time()-st;
  69 |   21   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   20   0.000    980|         summon := lmCp+minmon;
  76 |   20   0.000  89540|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   20   0.047 371220|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   20   0.000    240|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   20   0.000    347|             H := [op(H), Cp];
  84 |   20   0.000    327|             Np := [op(Np), p];
  85 |   20   0.000     80|             st := time();
  86 |   20  13.031 67916820|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   20   0.000    316|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   21   0.000     84|     st := time();
  89 |   21   0.593 18752305|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   21   0.000    332|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   21   0.000     63|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2449|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.015    295|         do
  96 |    1   0.000     35|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.110 3408521|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.032 707778|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    3 357.953 3729766007|
   1 |    3   0.000      0| timings := true;
   2 |    3   0.000     12| tt := time();
   3 |    3   0.000      0| pt := 0;
   4 |    3   0.000      0| lmt := 0;
   5 |    3   0.000      0| laminpolytime := 0;
   6 |    3   0.000      0| phigammatime := 0;
   7 |    3   0.000      0| pgcdtime := 0;
   8 |    3   0.000      0| CRTRNRtime := 0;
   9 |    3   0.000      0| divtime := 0;
  10 |    3   0.077    219| A1, B1, ring := ConvRing(A0,B0);
  11 |    3   0.563 6061626| A := semi(A1);
  12 |    3   0.797 6062031| B := semi(B1);
  13 |    3   0.000     12| Char, X, E := op(ring);
  14 |    3   0.000      0| n := nops(X);
  15 |    3   0.000      0| m := nops(E);
  16 |    3   0.000      0| k := n-m;
  17 |    3   0.000     24| Xpoly := X[1 .. k];
  18 |    3   0.000     63| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    3   0.000   2193| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    3   0.000   6852| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    3   0.000      0| H := [];
  22 |    3   0.000      0| Np := [];
  23 |    3   0.000      0| p := 2147483648;
  24 |    3   0.000      0| do
  25 |   50   0.817 175200|     do
  26 |   50   0.000   4690|         p := nextprime(p);
  27 |   50   0.000      0|         lcmintest := true;
  28 |   50   0.000      0|         for i to m do
  29 |  250   0.000   4283|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   50   0.000    200|     st := time();
  32 |   50  27.749 274012809|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   50   0.000    800|     pt := pt+time()-st;
  34 |   50   0.000 123004|     Rand := rand(1 .. p-1);
  35 |   50   0.000    150|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   50   0.000   2690|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   50   0.000   4550|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   50   0.827 382000|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   50   0.000    200|         st := time();
  42 |   50   0.796 10580650|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   50   0.000    800|         laminpolytime := laminpolytime+time()-st;
  44 |   50   0.000    150|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   50   0.000    200|         M, phimatrix, invphimatrix := LA;
  47 |   50   0.000    200|         st := time();
  48 |   50  73.085 889381425|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   50  68.262 889604735|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   50   0.000    800|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   50   0.000    200|     st := time();
  52 |   50 109.796 1129150322|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   50   0.000    800|     pgcdtime := pgcdtime+time()-st;
  54 |   50   0.000    300|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   50   0.046  14722|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   50   0.000    150|     if 1 &lt; m then
  62 |   50   0.000    200|         st := time();
  63 |   50  20.327 262720523|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   50   0.000    800|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   50   0.000    200|     st := time();
  66 |   50   0.141   5200|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   50   6.046 44143266|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   50   0.000    672|     lmt := lmt+time()-st;
  69 |   50   0.000      0|     if not assigned(minmon) then
  70 |    3   0.000      0|         CRT := Cp;
  71 |    3   0.000      0|         minmon := lmCp;
  72 |    3   0.000      0|         summon := minmon;
  73 |    3   0.000      0|         least := minmon;
  74 |    3   0.000     12|         H := [Cp]
                                else
  75 |   47   0.000   1291|         summon := lmCp+minmon;
  76 |   47   0.062 229685|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   47   0.705 2154891|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   47   0.000    564|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   47   0.000    761|             H := [op(H), Cp];
  84 |   47   0.000    714|             Np := [op(Np), p];
  85 |   47   0.000    188|             st := time();
  86 |   47  47.561 209796228|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   45   0.000    680|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   48   0.000    192|     st := time();
  89 |   48   0.155 832769|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   48   0.000    728|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   48   0.000    144|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2438|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.125 4127632|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.016 166794|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1 128.141 1419342022|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.047     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.516 2305766| A := semi(A1);
  12 |    1   1.047 2306164| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   21   0.452  73584|     do
  26 |   21   0.000   1818|         p := nextprime(p);
  27 |   21   0.000      0|         lcmintest := true;
  28 |   21   0.000      0|         for i to m do
  29 |  105   0.000   1796|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   21   0.000     84|     st := time();
  32 |   21  12.532 127308640|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   21   0.000    336|     pt := pt+time()-st;
  34 |   21   0.000  51666|     Rand := rand(1 .. p-1);
  35 |   21   0.000     63|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   21   0.000   1150|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   21   0.000   1911|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   21   0.389 160440|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   21   0.000     84|         st := time();
  42 |   21   0.626 4444276|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   21   0.000    336|         laminpolytime := laminpolytime+time()-st;
  44 |   21   0.000     63|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   21   0.000     84|         M, phimatrix, invphimatrix := LA;
  47 |   21   0.000     84|         st := time();
  48 |   21  32.278 423469562|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   21  27.426 423632217|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   21   0.000    336|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   21   0.000     84|     st := time();
  52 |   21  24.357 267059527|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   21   0.000    336|     pgcdtime := pgcdtime+time()-st;
  54 |   21   0.000    126|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   21   0.032   5628|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   21   0.000     63|     if 1 &lt; m then
  62 |   21   0.000     84|         st := time();
  63 |   21  11.986 48515684|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   21   0.000    336|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   21   0.000     84|     st := time();
  66 |   21   0.031   2184|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   21   0.890 8182713|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   21   0.000    336|     lmt := lmt+time()-st;
  69 |   21   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   20   0.000    980|         summon := lmCp+minmon;
  76 |   20   0.000  93300|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   20   0.062 439760|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   20   0.000    240|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   20   0.000    347|             H := [op(H), Cp];
  84 |   20   0.000    327|             Np := [op(Np), p];
  85 |   20   0.000     80|             st := time();
  86 |   20  13.330 82282429|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   20   0.000    316|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   21   0.000     84|     st := time();
  89 |   21   1.687 23576639|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   21   0.000    332|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   21   0.000     63|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2428|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.422 4548410|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.031 865140|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

</Text-field>
</Output>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUkqbWNvbXBsZXRlRzYjL0krbW9kdWxlbmFtZUc2IkksVHlwZXNldHRpbmdHSShfc3lzbGliR0YnNiQtSSVtcm93R0YkNiYtSSNtaUdGJDYlUSJSRicvJSdpdGFsaWNHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ2l0YWxpY0YnLUkjbW9HRiQ2LlEpJkFzc2lnbjtGJy9GNlEnbm9ybWFsRicvJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHRkAvJSlzdHJldGNoeUdGQC8lKnN5bW1ldHJpY0dGQC8lKGxhcmdlb3BHRkAvJS5tb3ZhYmxlbGltaXRzR0ZALyUnYWNjZW50R0ZALyUnbHNwYWNlR1EsMC4yNzc3Nzc4ZW1GJy8lJ3JzcGFjZUdGTy8lKWVxdWFsaXR5R0ZALUkobWFjdGlvbkdGJDYlLUYsNiYtSSdtdGFibGVHRiQ2OC1JJG10ckdGJDYoLUkkbXRkR0YkNiotRiw2JS1GLDYmLUkobWZlbmNlZEdGJDYmLUYsNiUtSS1tc2Nyb2xsdGFibGVHRiQ2YnAtSSptc2Nyb2xsdHJHRiQ2Mi1JKm1zY3JvbGx0ZEdGJDYqLUkjbXNHRiQ2I1EjZEZGJy8lK2ZvcmVncm91bmRHUShbMCwwLDBdRicvJSlyZWFkb25seUdGQC8lKXJvd2FsaWduR1EhRicvJSxjb2x1bW5hbGlnbkdGaXAvJStncm91cGFsaWduR0ZpcC8lKHJvd3NwYW5HUSIxRicvJStjb2x1bW5zcGFuR0ZgcS1GXHA2Ki1GX3A2I1ElI2V4dEYnRmJwRmVwRmdwRmpwRlxxRl5xRmFxLUZccDYqLUZfcDYjUSUjdmFyRidGYnBGZXBGZ3BGanBGXHFGXnFGYXEtRlxwNiotRl9wNiNRKVRkZWcoZjEpRidGYnBGZXBGZ3BGanBGXHFGXnFGYXEtRlxwNiotRl9wNiNRKVRkZWcoZjIpRidGYnBGZXBGZ3BGanBGXHFGXnFGYXEtRlxwNiotRl9wNiNRKFRkZWcoZylGJ0ZicEZlcEZncEZqcEZccUZecUZhcS1GXHA2Ki1GX3A2I1EoVGRlZyhhKUYnRmJwRmVwRmdwRmpwRlxxRl5xRmFxLUZccDYqLUZfcDYjUShUZGVnKGIpRidGYnBGZXBGZ3BGanBGXHFGXnFGYXEtRlxwNiotRl9wNiNRKlRkZWcoR0NEKUYnRmJwRmVwRmdwRmpwRlxxRl5xRmFxLUZccDYqLUZfcDYjUSVUaW1lRidGYnBGZXBGZ3BGanBGXHFGXnFGYXEtRlxwNiotRl9wNiNRI05wRidGYnBGZXBGZ3BGanBGXHFGXnFGYXFGYnBGZXBGZ3BGanBGXHEtRmlvNjItRlxwNiotSSNtbkdGJDYkUSMzMkYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXEtRlxwNiotRmp0NiRRIjVGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxLUZccDYqLUZqdDYkUSIyRidGPEZicEZlcEZncEZqcEZccUZecUZhcS1GXHA2Ki1GanQ2JFEiOEYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGZ3VGYnUtRlxwNiotRmp0NiRRIjZGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRlx2RmJ1LUZccDYqLUZqdDYkUSYyLjU2M0YnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXEtRlxwNiotRmp0NiRRIzIwRidGPEZicEZlcEZncEZqcEZccUZecUZhcUZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidUZndUZndUZidUZcdkZcdkZidS1GXHA2Ki1GanQ2JFEmMS44NzVGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmZ2RmJwRmVwRmdwRmpwRlxxLUZpbzYyRmd0Rl11RmJ1Rmd1Rmd1LUZccDYqLUZqdDYkUSI0RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZkd0Zkd0Zkdy1GXHA2Ki1GanQ2JFEmMy45MzdGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxLUZccDYqLUZqdDYkUSMyM0YnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnVGZ3VGZ3VGXHZGYnVGYnVGXHYtRlxwNiotRmp0NiRRJjUuMDk0RidGPEZicEZlcEZncEZqcEZccUZecUZhcS1GXHA2Ki1GanQ2JFEjMjFGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmJwRmVwRmdwRmpwRlxxLUZpbzYyRmd0Rl11RmJ1LUZccDYqLUZqdDYkUSMxMkYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGYXlGYnUtRlxwNiotRmp0NiRRIzEwRidGPEZicEZlcEZncEZqcEZccUZecUZhcUZmeUZidS1GXHA2Ki1GanQ2JFEmMy44NDRGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxLUZccDYqLUZqdDYkUSMyMkYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnVGYXlGYXlGYnVGZnlGZnlGYnUtRlxwNiotRmp0NiRRJjMuOTIyRidGPEZicEZlcEZncEZqcEZccUZecUZhcUZgekZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidUZheUZheUZcdkZcdkZcdkZcdi1GXHA2Ki1GanQ2JFEmNy4wNzhGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRl54RmJwRmVwRmdwRmpwRlxxLUZpbzYyRmd0Rl11RmJ1RmF5RmF5RmZ5RmJ1RmJ1RmZ5LUZccDYqLUZqdDYkUScxMS4zMjhGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmp4RmJwRmVwRmdwRmpwRlxxLUZpbzYyRmd0Rl11RmJ1LUZccDYqLUZqdDYkUSMxNkYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGXFxsRmJ1LUZccDYqLUZqdDYkUSMxNEYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGYVxsRmJ1LUZccDYqLUZqdDYkUSY1LjY1NkYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXEtRlxwNiotRmp0NiRRIzI0RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidUZcXGxGXFxsRmR3RmF5RmF5RmR3LUZccDYqLUZqdDYkUSY2LjA3OUYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGanhGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnVGXFxsRlxcbEZndUZndUZndUZndS1GXHA2Ki1GanQ2JFEmOS42ODhGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmZ2RmJwRmVwRmdwRmpwRlxxLUZpbzYyRmd0Rl11RmJ1RlxcbEZcXGxGYXlGZHdGZHdGYXktRlxwNiotRmp0NiRRJzE4LjczNEYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGYHpGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnVGZnZGZnZGYnUtRlxwNiotRmp0NiRRIzE4RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZnXmxGYnUtRlxwNiotRmp0NiRRJjcuMzQ0RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZqeEZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidUZmdkZmdkZkd0ZcXGxGXFxsRmR3LUZccDYqLUZqdDYkUSY4LjcxOUYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGYHpGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnVGZnZGZnZGZnlGZnlGZnlGZnktRlxwNiotRmp0NiRRJzE0LjM5MUYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGanhGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnVGZnZGZnZGXFxsRmR3RmR3RlxcbC1GXHA2Ki1GanQ2JFEnMjcuMjE5RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZqeEZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidUZbXWxGW11sRmJ1RmB6RmB6RmJ1LUZccDYqLUZqdDYkUSY5Ljk4NEYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGW11sRmJwRmVwRmdwRmpwRlxxLUZpbzYyRmd0Rl11RmJ1RltdbEZbXWxGXHZGZ15sRmdebEZcdi1GXHA2Ki1GanQ2JFEnMTEuMjgxRidGPEZicEZlcEZncEZqcEZccUZecUZhcUZqeEZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidUZbXWxGW11sRmF5RmF5RmF5RmF5LUZccDYqLUZqdDYkUScyMC45ODRGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmB6RmJwRmVwRmdwRmpwRlxxLUZpbzYyRmd0Rl11RmJ1RltdbEZbXWxGZ15sRlx2Rlx2RmdebC1GXHA2Ki1GanQ2JFEnMzEuMTQxRidGPEZicEZlcEZncEZqcEZccUZecUZhcUZmdkZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidUZndEZndEZidS1GXHA2Ki1GanQ2JFEjMzBGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmRibEZidS1GXHA2Ki1GanQ2JFEnMTMuODc1RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZmdkZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidUZndEZndEZndUZbXWxGW11sRmd1LUZccDYqLUZqdDYkUScxOC41OTRGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmZ2RmJwRmVwRmdwRmpwRlxxLUZpbzYyRmd0Rl11RmJ1Rmd0Rmd0RlxcbEZcXGxGXFxsRlxcbC1GXHA2Ki1GanQ2JFEnMzEuMTEwRidGPEZicEZlcEZncEZqcEZccUZecUZhcS1GXHA2Ki1GanQ2JFEjMTlGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmJwRmVwRmdwRmpwRlxxLUZpbzYyRmd0Rl11RmJ1Rmd0Rmd0RltdbEZndUZndUZbXWwtRlxwNiotRmp0NiRRJzcyLjM1OUYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGXnhGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnUtRlxwNiotRmp0NiRRIzQwRidGPEZicEZlcEZncEZqcEZccUZecUZhcUZqZGxGYnUtRlxwNiotRmp0NiRRIzM4RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZfZWxGYnUtRlxwNiotRmp0NiRRJzIxLjExMEYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGanhGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnVGamRsRmpkbEZmeUZkYmxGZGJsRmZ5LUZccDYqLUZqdDYkUSczMS40NjlGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmB6RmJwRmVwRmdwRmpwRlxxLUZpbzYyRmd0Rl11RmJ1RmpkbEZqZGxGZnZGZnZGZnZGZnYtRlxwNiotRmp0NiRRJzYwLjQ2OUYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGYHpGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnVGamRsRmpkbEZkYmxGZnlGZnlGZGJsLUZccDYqLUZqdDYkUSgxMzIuMDAwRidGPEZicEZlcEZncEZqcEZccUZecUZhcUZbXWxGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnUtRlxwNiotRmp0NiRRIzQ4RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZgZ2xGYnUtRlxwNiotRmp0NiRRIzQ2RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZlZ2xGYnUtRlxwNiotRmp0NiRRJzMwLjM0NEYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGZnZGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnVGYGdsRmBnbEZheS1GXHA2Ki1GanQ2JFEjMzZGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmFobEZheS1GXHA2Ki1GanQ2JFEnNDMuMzkxRidGPEZicEZlcEZncEZqcEZccUZecUZhcUZqeEZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidUZgZ2xGYGdsRltdbEZbXWxGW11sRltdbC1GXHA2Ki1GanQ2JFEnODkuNDY5RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZgekZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidUZgZ2xGYGdsRmFobEZheUZheS1GXHA2Ki1GLzYlUSVGQUlMRidGMkY1RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmRpbEZgekZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidS1GXHA2Ki1GanQ2JFEjNTZGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRltqbEZidS1GXHA2Ki1GanQ2JFEjNTRGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmBqbEZidS1GXHA2Ki1GanQ2JFEnNDAuNjA5RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZcZGxGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnVGW2psRltqbEZhXGwtRlxwNiotRmp0NiRRIzQyRidGPEZicEZlcEZncEZqcEZccUZecUZhcUZcW21GYVxsLUZccDYqLUZqdDYkUSc2Mi4wNzhGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmp4RmJwRmVwRmdwRmpwRlxxLUZpbzYyRmd0Rl11RmJ1RltqbEZbamwtRlxwNiotRmp0NiRRIzI4RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZoW21GaFttRmhbbS1GXHA2Ki1GanQ2JFEnOTguODU5RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZnXmxGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnVGW2psRltqbEZcW21GYVxsRmFcbEZkaWxGZGlsRmdebEZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidS1GXHA2Ki1GanQ2JFEjNjRGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmZcbUZidS1GXHA2Ki1GanQ2JFEjNjJGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRltdbUZidS1GXHA2Ki1GanQ2JFEnNTguNTYyRidGPEZicEZlcEZncEZqcEZccUZecUZhcUZqeEZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidUZmXG1GZlxtRlxcbEZgZ2xGYGdsRlxcbC1GXHA2Ki1GanQ2JFEnNzIuMDc4RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZcZGxGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnVGZlxtRmZcbUZndEZndEZndEZkaWxGZGlsRlxkbEZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidUZmXG1GZlxtRmBnbEZcXGxGXFxsRmRpbEZkaWxGXGRsRmJwRmVwRmdwRmpwRlxxLUZpbzYyLUZccDYqLUYvNidGaXBGMkZicEZlcEY1RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmJebUZiXm1GYl5tRmJebUZiXm1GYl5tRmJebUZiXm1GYl5tRmJebUZicEZlcEZncEZqcEZccS8lJmFsaWduR1ElYXhpc0YnL0ZocFEnY2VudGVyRicvRltxRmpebS9GXXFRJ3xmcmxlZnR8aHJGJy8lL2FsaWdubWVudHNjb3BlR0Y0LyUsY29sdW1ud2lkdGhHUSVhdXRvRicvJSZ3aWR0aEdGYl9tLyUrcm93c3BhY2luZ0dRJjEuMGV4RicvJS5jb2x1bW5zcGFjaW5nR1EmMC44ZW1GJy8lKXJvd2xpbmVzR1Elbm9uZUYnLyUsY29sdW1ubGluZXNHRl1gbS8lJmZyYW1lR0ZdYG0vJS1mcmFtZXNwYWNpbmdHUSwwLjRlbX4wLjVleEYnLyUqZXF1YWxyb3dzR0ZALyUtZXF1YWxjb2x1bW5zR0ZALyUtZGlzcGxheXN0eWxlR0ZALyUlc2lkZUdRJnJpZ2h0RicvJTBtaW5sYWJlbHNwYWNpbmdHRmpfbS8lMXNob3djb2x1bW5oZWFkZXJHRkAvJS5zaG93cm93aGVhZGVyR0Y0LyUuZnJvemVuZGlzcGxheUdGQC8lLm51bWJlcmNvbHVtbnNHUSMxMUYnLyUrbnVtYmVycm93c0dRIzUwRicvJTZkZWZhdWx0dmlzaWJsZWNvbHVtbnNHRmhhbS8lM2RlZmF1bHR2aXNpYmxlcm93c0dGXmVsLyUxY29sdW1ubG93ZXJib3VuZEdGYHEvJTFjb2x1bW51cHBlcmJvdW5kR0ZoYW0vJS5yb3dsb3dlcmJvdW5kR0ZgcS8lLnJvd3VwcGVyYm91bmRHUSM0MUYnLyUtZGlzcGxheXdpZHRoR1EkNzMyRicvJS5kaXNwbGF5aGVpZ2h0R1ElMTAxOEYnLyUwdXNlcmRlZmluZWRzaXplR0ZALyU6ZGlzcGxheWhvcml6b250YWxwb3NpdGlvbkdRIjBGJy8lOGRpc3BsYXl2ZXJ0aWNhbHBvc2l0aW9uR0ZjY20vJTRkaXNwbGF5Y29sdW1ud2lkdGhzR1FNWzMwLH40MCx+NDAsfjY3LH42Nyx+NjIsfjYxLH42Mix+ODYsfjUwLH4zMl1GJy8lNWRpc3BsYXljb2x1bW5zcGFjaW5nR1FJWzExLH4xMSx+MTEsfjExLH4xMSx+MTEsfjExLH4xMSx+MTEsfjExXUYnLyU4dXNlcmRlZmluZWRjb2x1bW53aWR0aHNHUWhvW2ZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZV1GJy8lMmRpc3BsYXlyb3doZWlnaHRzR1Fjd1sxNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTddRicvJTJkaXNwbGF5cm93c3BhY2luZ0dRXnRbOCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OF1GJy8lNnVzZXJkZWZpbmVkcm93aGVpZ2h0c0dRaWBsW2ZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZV1GJy8lKnRhYmxldHlwZUdGZnUvJTJyb3dpbmRleGluZ29mZnNldEdGY2NtLyU1Y29sdW1uaW5kZXhpbmdvZmZzZXRHRmNjbS8lMmFycmF5c2xpY2VpbmRpY2VzR1EjW11GJ0ZicEY8RjwvJSVvcGVuR1EnJmxzcWI7RicvJSZjbG9zZUdRJyZyc3FiO0YnRmJwRmVwRjxGYnBGPEZicEZlcEZncEZqcEZccUZecUZhcUZicEZlcEZncEZqcEZccS1GZ242KC1Gam42Ki1JJm10ZXh0R0YkNiVRNTUwfiZ0aW1lczt+MTF+TWF0cml4RicvJSVzaXplR0ZbdkY8RmJwRmVwRmdwL0ZbcUZdYW1GXHFGXnFGYXFGYnBGZXBGZ3BGanBGXHFGYnBGZXBGZl5tL0ZocFEpYmFzZWxpbmVGJ0ZbX21GXF9tRl5fbUZgX21GY19tRmVfbUZoX21GW2BtRl5gbUZgYG1GYmBtRmVgbUZnYG1GaWBtRlthbUZeYW1GYnBGZXBGPC8lK2FjdGlvbnR5cGVHUS1icm93c2VydGFibGVGJy8lKXJ0YWJsZWlkR1E1MzY4OTM0ODk3MTY5NDE3NjY2NTJGJ0Y8LUklbXN1YkdGJDYlLUYvNiVRKF9ydGFibGVGJ0YyRjUtRiw2Ji1GanQ2JFE1MzY4OTM0OTAxMzUzNjE4NzI4MjhGJ0Y8RmJwRmVwRjwvJS9zdWJzY3JpcHRzaGlmdEdGY2Nt">LUkqbWNvbXBsZXRlRzYjL0krbW9kdWxlbmFtZUc2IkksVHlwZXNldHRpbmdHSShfc3lzbGliR0YnNiQtSSVtcm93R0YkNiYtSSNtaUdGJDYlUSJSRicvJSdpdGFsaWNHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ2l0YWxpY0YnLUkjbW9HRiQ2LlEpJkFzc2lnbjtGJy9GNlEnbm9ybWFsRicvJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHRkAvJSlzdHJldGNoeUdGQC8lKnN5bW1ldHJpY0dGQC8lKGxhcmdlb3BHRkAvJS5tb3ZhYmxlbGltaXRzR0ZALyUnYWNjZW50R0ZALyUnbHNwYWNlR1EsMC4yNzc3Nzc4ZW1GJy8lJ3JzcGFjZUdGTy8lKWVxdWFsaXR5R0ZALUkobWFjdGlvbkdGJDYlLUYsNiYtSSdtdGFibGVHRiQ2OC1JJG10ckdGJDYoLUkkbXRkR0YkNiotRiw2JS1GLDYmLUkobWZlbmNlZEdGJDYmLUYsNiUtSS1tc2Nyb2xsdGFibGVHRiQ2YnAtSSptc2Nyb2xsdHJHRiQ2Mi1JKm1zY3JvbGx0ZEdGJDYqLUkjbXNHRiQ2I1EjZEZGJy8lK2ZvcmVncm91bmRHUShbMCwwLDBdRicvJSlyZWFkb25seUdGQC8lKXJvd2FsaWduR1EhRicvJSxjb2x1bW5hbGlnbkdGaXAvJStncm91cGFsaWduR0ZpcC8lKHJvd3NwYW5HUSIxRicvJStjb2x1bW5zcGFuR0ZgcS1GXHA2Ki1GX3A2I1ElI2V4dEYnRmJwRmVwRmdwRmpwRlxxRl5xRmFxLUZccDYqLUZfcDYjUSUjdmFyRidGYnBGZXBGZ3BGanBGXHFGXnFGYXEtRlxwNiotRl9wNiNRKVRkZWcoZjEpRidGYnBGZXBGZ3BGanBGXHFGXnFGYXEtRlxwNiotRl9wNiNRKVRkZWcoZjIpRidGYnBGZXBGZ3BGanBGXHFGXnFGYXEtRlxwNiotRl9wNiNRKFRkZWcoZylGJ0ZicEZlcEZncEZqcEZccUZecUZhcS1GXHA2Ki1GX3A2I1EoVGRlZyhhKUYnRmJwRmVwRmdwRmpwRlxxRl5xRmFxLUZccDYqLUZfcDYjUShUZGVnKGIpRidGYnBGZXBGZ3BGanBGXHFGXnFGYXEtRlxwNiotRl9wNiNRKlRkZWcoR0NEKUYnRmJwRmVwRmdwRmpwRlxxRl5xRmFxLUZccDYqLUZfcDYjUSVUaW1lRidGYnBGZXBGZ3BGanBGXHFGXnFGYXEtRlxwNiotRl9wNiNRI05wRidGYnBGZXBGZ3BGanBGXHFGXnFGYXFGYnBGZXBGZ3BGanBGXHEtRmlvNjItRlxwNiotSSNtbkdGJDYkUSMzMkYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXEtRlxwNiotRmp0NiRRIjVGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxLUZccDYqLUZqdDYkUSIyRidGPEZicEZlcEZncEZqcEZccUZecUZhcS1GXHA2Ki1GanQ2JFEiOEYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGZ3VGYnUtRlxwNiotRmp0NiRRIjZGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRlx2RmJ1LUZccDYqLUZqdDYkUSYyLjU2M0YnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXEtRlxwNiotRmp0NiRRIzIwRidGPEZicEZlcEZncEZqcEZccUZecUZhcUZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidUZndUZndUZidUZcdkZcdkZidS1GXHA2Ki1GanQ2JFEmMS44NzVGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmZ2RmJwRmVwRmdwRmpwRlxxLUZpbzYyRmd0Rl11RmJ1Rmd1Rmd1LUZccDYqLUZqdDYkUSI0RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZkd0Zkd0Zkdy1GXHA2Ki1GanQ2JFEmMy45MzdGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxLUZccDYqLUZqdDYkUSMyM0YnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnVGZ3VGZ3VGXHZGYnVGYnVGXHYtRlxwNiotRmp0NiRRJjUuMDk0RidGPEZicEZlcEZncEZqcEZccUZecUZhcS1GXHA2Ki1GanQ2JFEjMjFGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmJwRmVwRmdwRmpwRlxxLUZpbzYyRmd0Rl11RmJ1LUZccDYqLUZqdDYkUSMxMkYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGYXlGYnUtRlxwNiotRmp0NiRRIzEwRidGPEZicEZlcEZncEZqcEZccUZecUZhcUZmeUZidS1GXHA2Ki1GanQ2JFEmMy44NDRGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxLUZccDYqLUZqdDYkUSMyMkYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnVGYXlGYXlGYnVGZnlGZnlGYnUtRlxwNiotRmp0NiRRJjMuOTIyRidGPEZicEZlcEZncEZqcEZccUZecUZhcUZgekZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidUZheUZheUZcdkZcdkZcdkZcdi1GXHA2Ki1GanQ2JFEmNy4wNzhGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRl54RmJwRmVwRmdwRmpwRlxxLUZpbzYyRmd0Rl11RmJ1RmF5RmF5RmZ5RmJ1RmJ1RmZ5LUZccDYqLUZqdDYkUScxMS4zMjhGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmp4RmJwRmVwRmdwRmpwRlxxLUZpbzYyRmd0Rl11RmJ1LUZccDYqLUZqdDYkUSMxNkYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGXFxsRmJ1LUZccDYqLUZqdDYkUSMxNEYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGYVxsRmJ1LUZccDYqLUZqdDYkUSY1LjY1NkYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXEtRlxwNiotRmp0NiRRIzI0RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidUZcXGxGXFxsRmR3RmF5RmF5RmR3LUZccDYqLUZqdDYkUSY2LjA3OUYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGanhGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnVGXFxsRlxcbEZndUZndUZndUZndS1GXHA2Ki1GanQ2JFEmOS42ODhGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmZ2RmJwRmVwRmdwRmpwRlxxLUZpbzYyRmd0Rl11RmJ1RlxcbEZcXGxGYXlGZHdGZHdGYXktRlxwNiotRmp0NiRRJzE4LjczNEYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGYHpGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnVGZnZGZnZGYnUtRlxwNiotRmp0NiRRIzE4RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZnXmxGYnUtRlxwNiotRmp0NiRRJjcuMzQ0RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZqeEZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidUZmdkZmdkZkd0ZcXGxGXFxsRmR3LUZccDYqLUZqdDYkUSY4LjcxOUYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGYHpGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnVGZnZGZnZGZnlGZnlGZnlGZnktRlxwNiotRmp0NiRRJzE0LjM5MUYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGanhGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnVGZnZGZnZGXFxsRmR3RmR3RlxcbC1GXHA2Ki1GanQ2JFEnMjcuMjE5RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZqeEZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidUZbXWxGW11sRmJ1RmB6RmB6RmJ1LUZccDYqLUZqdDYkUSY5Ljk4NEYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGW11sRmJwRmVwRmdwRmpwRlxxLUZpbzYyRmd0Rl11RmJ1RltdbEZbXWxGXHZGZ15sRmdebEZcdi1GXHA2Ki1GanQ2JFEnMTEuMjgxRidGPEZicEZlcEZncEZqcEZccUZecUZhcUZqeEZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidUZbXWxGW11sRmF5RmF5RmF5RmF5LUZccDYqLUZqdDYkUScyMC45ODRGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmB6RmJwRmVwRmdwRmpwRlxxLUZpbzYyRmd0Rl11RmJ1RltdbEZbXWxGZ15sRlx2Rlx2RmdebC1GXHA2Ki1GanQ2JFEnMzEuMTQxRidGPEZicEZlcEZncEZqcEZccUZecUZhcUZmdkZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidUZndEZndEZidS1GXHA2Ki1GanQ2JFEjMzBGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmRibEZidS1GXHA2Ki1GanQ2JFEnMTMuODc1RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZmdkZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidUZndEZndEZndUZbXWxGW11sRmd1LUZccDYqLUZqdDYkUScxOC41OTRGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmZ2RmJwRmVwRmdwRmpwRlxxLUZpbzYyRmd0Rl11RmJ1Rmd0Rmd0RlxcbEZcXGxGXFxsRlxcbC1GXHA2Ki1GanQ2JFEnMzEuMTEwRidGPEZicEZlcEZncEZqcEZccUZecUZhcS1GXHA2Ki1GanQ2JFEjMTlGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmJwRmVwRmdwRmpwRlxxLUZpbzYyRmd0Rl11RmJ1Rmd0Rmd0RltdbEZndUZndUZbXWwtRlxwNiotRmp0NiRRJzcyLjM1OUYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGXnhGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnUtRlxwNiotRmp0NiRRIzQwRidGPEZicEZlcEZncEZqcEZccUZecUZhcUZqZGxGYnUtRlxwNiotRmp0NiRRIzM4RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZfZWxGYnUtRlxwNiotRmp0NiRRJzIxLjExMEYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGanhGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnVGamRsRmpkbEZmeUZkYmxGZGJsRmZ5LUZccDYqLUZqdDYkUSczMS40NjlGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmB6RmJwRmVwRmdwRmpwRlxxLUZpbzYyRmd0Rl11RmJ1RmpkbEZqZGxGZnZGZnZGZnZGZnYtRlxwNiotRmp0NiRRJzYwLjQ2OUYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGYHpGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnVGamRsRmpkbEZkYmxGZnlGZnlGZGJsLUZccDYqLUZqdDYkUSgxMzIuMDAwRidGPEZicEZlcEZncEZqcEZccUZecUZhcUZbXWxGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnUtRlxwNiotRmp0NiRRIzQ4RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZgZ2xGYnUtRlxwNiotRmp0NiRRIzQ2RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZlZ2xGYnUtRlxwNiotRmp0NiRRJzMwLjM0NEYnRjxGYnBGZXBGZ3BGanBGXHFGXnFGYXFGZnZGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnVGYGdsRmBnbEZheS1GXHA2Ki1GanQ2JFEjMzZGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmFobEZheS1GXHA2Ki1GanQ2JFEnNDMuMzkxRidGPEZicEZlcEZncEZqcEZccUZecUZhcUZqeEZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidUZgZ2xGYGdsRltdbEZbXWxGW11sRltdbC1GXHA2Ki1GanQ2JFEnODkuNDY5RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZgekZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidUZgZ2xGYGdsRmFobEZheUZheS1GXHA2Ki1GLzYlUSVGQUlMRidGMkY1RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmRpbEZgekZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidS1GXHA2Ki1GanQ2JFEjNTZGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRltqbEZidS1GXHA2Ki1GanQ2JFEjNTRGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmBqbEZidS1GXHA2Ki1GanQ2JFEnNDAuNjA5RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZcZGxGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnVGW2psRltqbEZhXGwtRlxwNiotRmp0NiRRIzQyRidGPEZicEZlcEZncEZqcEZccUZecUZhcUZcW21GYVxsLUZccDYqLUZqdDYkUSc2Mi4wNzhGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmp4RmJwRmVwRmdwRmpwRlxxLUZpbzYyRmd0Rl11RmJ1RltqbEZbamwtRlxwNiotRmp0NiRRIzI4RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZoW21GaFttRmhbbS1GXHA2Ki1GanQ2JFEnOTguODU5RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZnXmxGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnVGW2psRltqbEZcW21GYVxsRmFcbEZkaWxGZGlsRmdebEZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidS1GXHA2Ki1GanQ2JFEjNjRGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmZcbUZidS1GXHA2Ki1GanQ2JFEjNjJGJ0Y8RmJwRmVwRmdwRmpwRlxxRl5xRmFxRltdbUZidS1GXHA2Ki1GanQ2JFEnNTguNTYyRidGPEZicEZlcEZncEZqcEZccUZecUZhcUZqeEZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidUZmXG1GZlxtRlxcbEZgZ2xGYGdsRlxcbC1GXHA2Ki1GanQ2JFEnNzIuMDc4RidGPEZicEZlcEZncEZqcEZccUZecUZhcUZcZGxGYnBGZXBGZ3BGanBGXHEtRmlvNjJGZ3RGXXVGYnVGZlxtRmZcbUZndEZndEZndEZkaWxGZGlsRlxkbEZicEZlcEZncEZqcEZccS1GaW82MkZndEZddUZidUZmXG1GZlxtRmBnbEZcXGxGXFxsRmRpbEZkaWxGXGRsRmJwRmVwRmdwRmpwRlxxLUZpbzYyLUZccDYqLUYvNidGaXBGMkZicEZlcEY1RmJwRmVwRmdwRmpwRlxxRl5xRmFxRmJebUZiXm1GYl5tRmJebUZiXm1GYl5tRmJebUZiXm1GYl5tRmJebUZicEZlcEZncEZqcEZccS8lJmFsaWduR1ElYXhpc0YnL0ZocFEnY2VudGVyRicvRltxRmpebS9GXXFRJ3xmcmxlZnR8aHJGJy8lL2FsaWdubWVudHNjb3BlR0Y0LyUsY29sdW1ud2lkdGhHUSVhdXRvRicvJSZ3aWR0aEdGYl9tLyUrcm93c3BhY2luZ0dRJjEuMGV4RicvJS5jb2x1bW5zcGFjaW5nR1EmMC44ZW1GJy8lKXJvd2xpbmVzR1Elbm9uZUYnLyUsY29sdW1ubGluZXNHRl1gbS8lJmZyYW1lR0ZdYG0vJS1mcmFtZXNwYWNpbmdHUSwwLjRlbX4wLjVleEYnLyUqZXF1YWxyb3dzR0ZALyUtZXF1YWxjb2x1bW5zR0ZALyUtZGlzcGxheXN0eWxlR0ZALyUlc2lkZUdRJnJpZ2h0RicvJTBtaW5sYWJlbHNwYWNpbmdHRmpfbS8lMXNob3djb2x1bW5oZWFkZXJHRkAvJS5zaG93cm93aGVhZGVyR0Y0LyUuZnJvemVuZGlzcGxheUdGQC8lLm51bWJlcmNvbHVtbnNHUSMxMUYnLyUrbnVtYmVycm93c0dRIzUwRicvJTZkZWZhdWx0dmlzaWJsZWNvbHVtbnNHRmhhbS8lM2RlZmF1bHR2aXNpYmxlcm93c0dGXmVsLyUxY29sdW1ubG93ZXJib3VuZEdGYHEvJTFjb2x1bW51cHBlcmJvdW5kR0ZoYW0vJS5yb3dsb3dlcmJvdW5kR0ZgcS8lLnJvd3VwcGVyYm91bmRHUSM0MUYnLyUtZGlzcGxheXdpZHRoR1EkNzMyRicvJS5kaXNwbGF5aGVpZ2h0R1ElMTAxOEYnLyUwdXNlcmRlZmluZWRzaXplR0ZALyU6ZGlzcGxheWhvcml6b250YWxwb3NpdGlvbkdRIjBGJy8lOGRpc3BsYXl2ZXJ0aWNhbHBvc2l0aW9uR0ZjY20vJTRkaXNwbGF5Y29sdW1ud2lkdGhzR1FNWzMwLH40MCx+NDAsfjY3LH42Nyx+NjIsfjYxLH42Mix+ODYsfjUwLH4zMl1GJy8lNWRpc3BsYXljb2x1bW5zcGFjaW5nR1FJWzExLH4xMSx+MTEsfjExLH4xMSx+MTEsfjExLH4xMSx+MTEsfjExXUYnLyU4dXNlcmRlZmluZWRjb2x1bW53aWR0aHNHUWhvW2ZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZV1GJy8lMmRpc3BsYXlyb3doZWlnaHRzR1Fjd1sxNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTddRicvJTJkaXNwbGF5cm93c3BhY2luZ0dRXnRbOCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OF1GJy8lNnVzZXJkZWZpbmVkcm93aGVpZ2h0c0dRaWBsW2ZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZV1GJy8lKnRhYmxldHlwZUdGZnUvJTJyb3dpbmRleGluZ29mZnNldEdGY2NtLyU1Y29sdW1uaW5kZXhpbmdvZmZzZXRHRmNjbS8lMmFycmF5c2xpY2VpbmRpY2VzR1EjW11GJ0ZicEY8RjwvJSVvcGVuR1EnJmxzcWI7RicvJSZjbG9zZUdRJyZyc3FiO0YnRmJwRmVwRjxGYnBGPEZicEZlcEZncEZqcEZccUZecUZhcUZicEZlcEZncEZqcEZccS1GZ242KC1Gam42Ki1JJm10ZXh0R0YkNiVRNTUwfiZ0aW1lczt+MTF+TWF0cml4RicvJSVzaXplR0ZbdkY8RmJwRmVwRmdwL0ZbcUZdYW1GXHFGXnFGYXFGYnBGZXBGZ3BGanBGXHFGYnBGZXBGZl5tL0ZocFEpYmFzZWxpbmVGJ0ZbX21GXF9tRl5fbUZgX21GY19tRmVfbUZoX21GW2BtRl5gbUZgYG1GYmBtRmVgbUZnYG1GaWBtRlthbUZeYW1GYnBGZXBGPC8lK2FjdGlvbnR5cGVHUS1icm93c2VydGFibGVGJy8lKXJ0YWJsZWlkR1E1MzY4OTM0ODk3MTY5NDE3NjY2NTJGJ0Y8LUklbXN1YkdGJDYlLUYvNiVRKF9ydGFibGVGJ0YyRjUtRiw2Ji1GanQ2JFE1MzY4OTM0OTAxMzUzNjE4NzI4MjhGJ0Y8RmJwRmVwRjwvJS9zdWJzY3JpcHRzaGlmdEdGY2Nt</Equation></Text-field>
</Output>
</Group>
<Group hide-input="false" labelreference="L704" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font opaque="true" size="16" background="[255,255,153]" foreground="[0,0,255]">#3 </Font><Font opaque="true" background="[255,255,153]" foreground="[0,0,128]">Degree of the field is in [4,8,12,16,24,32,64,72] with max number of extensions
#numext will be chosen to be the maximum</Font>
dF:<Font opaque="true" foreground="[128,0,0]">=[4,8,12,16,24,32,64,72];
</Font>R:=<Font foreground="[128,0,0]">Benchmain(flagalg,2</Font>,24,12,dF,numext,0);
Export(R,&quot;MGCD.xls&quot;,&quot;dF&quot;);<Font opaque="true" foreground="[128,0,0]">
</Font></Text-field>
</Input>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUkjbWlHRiQ2JVEjZEZGJy8lJ2l0YWxpY0dRJXRydWVGJy8lLG1hdGh2YXJpYW50R1EnaXRhbGljRictSSNtb0dGJDYuUSkmQXNzaWduO0YnL0YzUSdub3JtYWxGJy8lJmZlbmNlR1EmZmFsc2VGJy8lKnNlcGFyYXRvckdGPS8lKXN0cmV0Y2h5R0Y9LyUqc3ltbWV0cmljR0Y9LyUobGFyZ2VvcEdGPS8lLm1vdmFibGVsaW1pdHNHRj0vJSdhY2NlbnRHRj0vJSdsc3BhY2VHUSwwLjI3Nzc3NzhlbUYnLyUncnNwYWNlR0ZMLyUpZXF1YWxpdHlHRj0tSShtZmVuY2VkR0YkNiYtRiM2NC1JI21uR0YkNiRRIjRGJ0Y5LUY2Ni5RIixGJ0Y5RjsvRj9GMUZARkJGREZGRkgvRktRJjAuMGVtRicvRk5RLDAuMzMzMzMzM2VtRidGTy1GVzYkUSI4RidGOUZaLUZXNiRRIzEyRidGOUZaLUZXNiRRIzE2RidGOUZaLUZXNiRRIzI0RidGOUZaLUZXNiRRIzMyRidGOUZaLUZXNiRRIzY0RidGOUZaLUZXNiRRIzcyRidGOS8lK2ZvcmVncm91bmRHUShbMCwwLDBdRicvJSlyZWFkb25seUdGPUY5RjkvJSVvcGVuR1EnJmxzcWI7RicvJSZjbG9zZUdRJyZyc3FiO0YnRjk=">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYlLUkjbWlHRiQ2JVEjZEZGJy8lJ2l0YWxpY0dRJXRydWVGJy8lLG1hdGh2YXJpYW50R1EnaXRhbGljRictSSNtb0dGJDYuUSkmQXNzaWduO0YnL0YzUSdub3JtYWxGJy8lJmZlbmNlR1EmZmFsc2VGJy8lKnNlcGFyYXRvckdGPS8lKXN0cmV0Y2h5R0Y9LyUqc3ltbWV0cmljR0Y9LyUobGFyZ2VvcEdGPS8lLm1vdmFibGVsaW1pdHNHRj0vJSdhY2NlbnRHRj0vJSdsc3BhY2VHUSwwLjI3Nzc3NzhlbUYnLyUncnNwYWNlR0ZMLyUpZXF1YWxpdHlHRj0tSShtZmVuY2VkR0YkNiYtRiM2MS1JI21uR0YkNiRRIjRGJ0Y5LUY2Ni5RIixGJ0Y5RjsvRj9GMUZARkJGREZGRkgvRktRJjAuMGVtRicvRk5RLDAuMzMzMzMzM2VtRidGTy1GVzYkUSI4RidGOUZaLUZXNiRRIzEyRidGOUZaLUZXNiRRIzE2RidGOUZaLUZXNiRRIzI0RidGOUZaLUZXNiRRIzMyRidGOUZaLUZXNiRRIzY0RidGOUZaLUZXNiRRIzcyRidGOUY5LyUlb3BlbkdRJyZsc3FiO0YnLyUmY2xvc2VHUScmcnNxYjtGJw==</Equation></Text-field>
</Output>
<Output><Text-field style="Line Printed Output" layout="Line Printed Output">MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    3 269.562 2689269829|
   1 |    3   0.000      0| timings := true;
   2 |    3   0.000     12| tt := time();
   3 |    3   0.000      0| pt := 0;
   4 |    3   0.000      0| lmt := 0;
   5 |    3   0.000      0| laminpolytime := 0;
   6 |    3   0.000      0| phigammatime := 0;
   7 |    3   0.000      0| pgcdtime := 0;
   8 |    3   0.000      0| CRTRNRtime := 0;
   9 |    3   0.000      0| divtime := 0;
  10 |    3   0.062    219| A1, B1, ring := ConvRing(A0,B0);
  11 |    3   0.454 4700436| A := semi(A1);
  12 |    3   0.483 4700436| B := semi(B1);
  13 |    3   0.000     12| Char, X, E := op(ring);
  14 |    3   0.000      0| n := nops(X);
  15 |    3   0.000      0| m := nops(E);
  16 |    3   0.000      0| k := n-m;
  17 |    3   0.000     24| Xpoly := X[1 .. k];
  18 |    3   0.000     60| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    3   0.000   1746| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    3   0.000   5206| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    3   0.000      0| H := [];
  22 |    3   0.000      0| Np := [];
  23 |    3   0.000      0| p := 2147483648;
  24 |    3   0.000      0| do
  25 |   25   0.408  81626|     do
  26 |   25   0.000   2455|         p := nextprime(p);
  27 |   25   0.000      0|         lcmintest := true;
  28 |   25   0.000      0|         for i to m do
  29 |  119   0.000   2057|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   25   0.000    100|     st := time();
  32 |   25  16.767 140306693|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   25   0.000    400|     pt := pt+time()-st;
  34 |   25   0.000  61536|     Rand := rand(1 .. p-1);
  35 |   25   0.000     75|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   25   0.000   1504|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   25   0.000   2153|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   25   0.419 179470|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   25   0.000    100|         st := time();
  42 |   25   0.392 4885330|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   25   0.000    388|         laminpolytime := laminpolytime+time()-st;
  44 |   25   0.000     75|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   25   0.000    100|         M, phimatrix, invphimatrix := LA;
  47 |   25   0.000    100|         st := time();
  48 |   25  42.843 471205164|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   25  32.126 452754041|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   24   0.000    384|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   24   0.000     96|     st := time();
  52 |   24 112.876 1129925925|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   23   0.000    368|     pgcdtime := pgcdtime+time()-st;
  54 |   23   0.000    138|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   23   0.047  10782|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   23   0.000     69|     if 1 &lt; m then
  62 |   23   0.000     92|         st := time();
  63 |   23  19.731 256243388|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   23   0.000    368|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   23   0.000     92|     st := time();
  66 |   23   0.188   2386|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   23   4.173 43245750|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   23   0.000    356|     lmt := lmt+time()-st;
  69 |   23   0.000      0|     if not assigned(minmon) then
  70 |    3   0.000      0|         CRT := Cp;
  71 |    3   0.000      0|         minmon := lmCp;
  72 |    3   0.000      0|         summon := minmon;
  73 |    3   0.000      0|         least := minmon;
  74 |    3   0.000     12|         H := [Cp]
                                else
  75 |   20   0.000    936|         summon := lmCp+minmon;
  76 |   20   0.000 139436|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   20   0.345 2003758|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   20   0.000    240|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   20   0.000    238|             H := [op(H), Cp];
  84 |   20   0.000    221|             Np := [op(Np), p];
  85 |   20   0.000     80|             st := time();
  86 |   20  38.123 178605781|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   20   0.000    308|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   23   0.000     92|     st := time();
  89 |   23   0.125  38026|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   23   0.000    352|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   23   0.000     69|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2445|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.000 147828|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000   7926|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     12|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   0.344 5828086|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.016  88904| A := semi(A1);
  12 |    1   0.015  88904| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     18| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    284| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000    638| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |    2   0.000   1034|     do
  26 |    2   0.000    203|         p := nextprime(p);
  27 |    2   0.000      0|         lcmintest := true;
  28 |    2   0.000      0|         for i to m do
  29 |    4   0.000     80|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |    2   0.000      8|     st := time();
  32 |    2   0.031 445028|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |    2   0.000     32|     pt := pt+time()-st;
  34 |    2   0.000   4931|     Rand := rand(1 .. p-1);
  35 |    2   0.000      6|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |    2   0.000     44|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |    2   0.000     60|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |    2   0.000   3750|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |    2   0.000      8|         st := time();
  42 |    2   0.000  18226|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |    2   0.000     20|         laminpolytime := laminpolytime+time()-st;
  44 |    2   0.000      6|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |    2   0.000      8|         M, phimatrix, invphimatrix := LA;
  47 |    2   0.000      8|         st := time();
  48 |    2   0.063 1483633|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |    2   0.063 1483753|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |    2   0.000     32|         phigammatime := phigammatime+time()-st
                                end if;
  51 |    2   0.000      8|     st := time();
  52 |    2   0.124 1727044|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |    2   0.000     32|     pgcdtime := pgcdtime+time()-st;
  54 |    2   0.000     12|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |    2   0.000    400|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |    2   0.000      6|     if 1 &lt; m then
  62 |    2   0.000      8|         st := time();
  63 |    2   0.016 169929|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |    2   0.000     32|         phigammatime := phigammatime+time()-st
                                end if;
  65 |    2   0.000      8|     st := time();
  66 |    2   0.000    202|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |    2   0.000  36064|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |    2   0.000     20|     lmt := lmt+time()-st;
  69 |    2   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |    1   0.000     49|         summon := lmCp+minmon;
  76 |    1   0.000   2917|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |    1   0.000   1506|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |    1   0.000     12|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |    1   0.000      5|             H := [op(H), Cp];
  84 |    1   0.000      7|             Np := [op(Np), p];
  85 |    1   0.000      4|             st := time();
  86 |    1   0.016  12738|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |    1   0.000     12|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |    2   0.000      8|     st := time();
  89 |    2   0.000  71421|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |    2   0.000     28|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |    2   0.000      6|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2452|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.000 156590|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000  26486|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     12|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   0.641 9309350|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.016  88904| A := semi(A1);
  12 |    1   0.000  88904| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     18| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    284| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000    638| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |    2   0.000   1034|     do
  26 |    2   0.000    203|         p := nextprime(p);
  27 |    2   0.000      0|         lcmintest := true;
  28 |    2   0.000      0|         for i to m do
  29 |    4   0.000     75|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |    2   0.000      8|     st := time();
  32 |    2   0.141 445826|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |    2   0.000     32|     pt := pt+time()-st;
  34 |    2   0.000   4903|     Rand := rand(1 .. p-1);
  35 |    2   0.000      6|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |    2   0.000     39|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |    2   0.000     60|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |    2   0.000   3750|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |    2   0.000      8|         st := time();
  42 |    2   0.000  18226|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |    2   0.000     20|         laminpolytime := laminpolytime+time()-st;
  44 |    2   0.000      6|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |    2   0.000      8|         M, phimatrix, invphimatrix := LA;
  47 |    2   0.000      8|         st := time();
  48 |    2   0.077 1560358|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |    2   0.063 1560324|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |    2   0.000     32|         phigammatime := phigammatime+time()-st
                                end if;
  51 |    2   0.000      8|     st := time();
  52 |    2   0.281 4364872|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |    2   0.000     32|     pgcdtime := pgcdtime+time()-st;
  54 |    2   0.000     12|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |    2   0.000    604|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |    2   0.000      6|     if 1 &lt; m then
  62 |    2   0.000      8|         st := time();
  63 |    2   0.032 547358|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |    2   0.000     32|         phigammatime := phigammatime+time()-st
                                end if;
  65 |    2   0.000      8|     st := time();
  66 |    2   0.000    202|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |    2   0.000 116322|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |    2   0.000     20|     lmt := lmt+time()-st;
  69 |    2   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |    1   0.000     49|         summon := lmCp+minmon;
  76 |    1   0.000   4009|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |    1   0.000   3930|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |    1   0.000     12|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |    1   0.000      5|             H := [op(H), Cp];
  84 |    1   0.000      7|             Np := [op(Np), p];
  85 |    1   0.000      4|             st := time();
  86 |    1   0.015  41536|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |    1   0.000     12|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |    2   0.000      8|     st := time();
  89 |    2   0.000 241677|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |    2   0.000     28|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |    2   0.000      6|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2431|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.016 177246|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000  34766|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   2.125 15242942|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.016  88904| A := semi(A1);
  12 |    1   0.015  88904| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     18| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    284| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000    638| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |    2   0.000   1034|     do
  26 |    2   0.000    203|         p := nextprime(p);
  27 |    2   0.000      0|         lcmintest := true;
  28 |    2   0.000      0|         for i to m do
  29 |    4   0.000     80|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |    2   0.000      8|     st := time();
  32 |    2   0.047 445028|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |    2   0.000     24|     pt := pt+time()-st;
  34 |    2   0.000   4885|     Rand := rand(1 .. p-1);
  35 |    2   0.000      6|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |    2   0.000     34|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |    2   0.000     60|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |    2   0.016   3750|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |    2   0.000      8|         st := time();
  42 |    2   0.000  18226|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |    2   0.000     20|         laminpolytime := laminpolytime+time()-st;
  44 |    2   0.000      6|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |    2   0.000      8|         M, phimatrix, invphimatrix := LA;
  47 |    2   0.000      8|         st := time();
  48 |    2   0.125 1485563|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |    2   0.140 1485552|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |    2   0.000     32|         phigammatime := phigammatime+time()-st
                                end if;
  51 |    2   0.000      8|     st := time();
  52 |    2   1.454 9337162|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |    2   0.000     32|     pgcdtime := pgcdtime+time()-st;
  54 |    2   0.000     12|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |    2   0.000    808|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |    2   0.000      6|     if 1 &lt; m then
  62 |    2   0.000      8|         st := time();
  63 |    2   0.172 1160304|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |    2   0.000     32|         phigammatime := phigammatime+time()-st
                                end if;
  65 |    2   0.000      8|     st := time();
  66 |    2   0.000    202|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |    2   0.062 243318|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |    2   0.000     32|     lmt := lmt+time()-st;
  69 |    2   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |    1   0.000     49|         summon := lmCp+minmon;
  76 |    1   0.000   5101|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |    1   0.000   7794|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |    1   0.000     12|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |    1   0.000      5|             H := [op(H), Cp];
  84 |    1   0.000      7|             Np := [op(Np), p];
  85 |    1   0.000      4|             st := time();
  86 |    1   0.016  87886|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |    1   0.000     12|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |    2   0.000      8|     st := time();
  89 |    2   0.031 513345|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |    2   0.000     28|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |    2   0.000      6|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2445|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     30|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.015 232767|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.016  27782|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   1.328 20370844|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.031 195154| A := semi(A1);
  12 |    1   0.016 195154| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     19| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    428| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   1091| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |    5   0.000   4710|     do
  26 |    5   0.000    557|         p := nextprime(p);
  27 |    5   0.000      0|         lcmintest := true;
  28 |    5   0.000      0|         for i to m do
  29 |   15   0.000    261|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |    5   0.000     20|     st := time();
  32 |    5   0.360 2566716|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |    5   0.000     80|     pt := pt+time()-st;
  34 |    5   0.000  12325|     Rand := rand(1 .. p-1);
  35 |    5   0.000     15|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |    5   0.000    170|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |    5   0.000    285|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |    5   0.000  16355|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |    5   0.000     20|         st := time();
  42 |    5   0.000 102430|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |    5   0.000     44|         laminpolytime := laminpolytime+time()-st;
  44 |    5   0.000     15|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |    5   0.000     20|         M, phimatrix, invphimatrix := LA;
  47 |    5   0.000     20|         st := time();
  48 |    5   0.327 7153834|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |    5   0.329 7154731|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |    5   0.000     80|         phigammatime := phigammatime+time()-st
                                end if;
  51 |    5   0.000     20|     st := time();
  52 |    5   0.249 2440859|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |    5   0.000     80|     pgcdtime := pgcdtime+time()-st;
  54 |    5   0.000     30|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |    5   0.000    560|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |    5   0.000     15|     if 1 &lt; m then
  62 |    5   0.000     20|         st := time();
  63 |    5   0.000 104124|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |    5   0.000     80|         phigammatime := phigammatime+time()-st
                                end if;
  65 |    5   0.000     20|     st := time();
  66 |    5   0.000    510|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |    5   0.000  19595|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |    5   0.000     44|     lmt := lmt+time()-st;
  69 |    5   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |    4   0.000     20|         summon := lmCp+minmon;
  76 |    4   0.000   8922|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |    4   0.000   3676|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |    4   0.000     48|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |    4   0.000     35|             H := [op(H), Cp];
  84 |    4   0.000     31|             Np := [op(Np), p];
  85 |    4   0.000     16|             st := time();
  86 |    4   0.016  27113|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |    4   0.000     36|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |    5   0.000     20|     st := time();
  89 |    5   0.000  24883|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |    5   0.000     52|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |    5   0.000     15|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2431|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.000 307343|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000  25250|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     12|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   2.860 25491833|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.016 195154| A := semi(A1);
  12 |    1   0.016 195154| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     19| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    428| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   1091| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |    5   0.015   4710|     do
  26 |    5   0.000    557|         p := nextprime(p);
  27 |    5   0.000      0|         lcmintest := true;
  28 |    5   0.000      0|         for i to m do
  29 |   15   0.000    261|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |    5   0.000     20|     st := time();
  32 |    5   0.283 2565920|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |    5   0.000     80|     pt := pt+time()-st;
  34 |    5   0.000  12276|     Rand := rand(1 .. p-1);
  35 |    5   0.000     15|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |    5   0.000    170|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |    5   0.000    285|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |    5   0.015  16355|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |    5   0.000     20|         st := time();
  42 |    5   0.015 102430|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |    5   0.000     72|         laminpolytime := laminpolytime+time()-st;
  44 |    5   0.000     15|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |    5   0.000     20|         M, phimatrix, invphimatrix := LA;
  47 |    5   0.000     20|         st := time();
  48 |    5   0.641 7000227|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |    5   0.624 7000078|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |    5   0.000     80|         phigammatime := phigammatime+time()-st
                                end if;
  51 |    5   0.000     20|     st := time();
  52 |    5   0.750 6262596|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |    5   0.000     80|     pgcdtime := pgcdtime+time()-st;
  54 |    5   0.000     30|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |    5   0.000   1000|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |    5   0.000     15|     if 1 &lt; m then
  62 |    5   0.000     20|         st := time();
  63 |    5   0.375 890740|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |    5   0.000     80|         phigammatime := phigammatime+time()-st
                                end if;
  65 |    5   0.000     20|     st := time();
  66 |    5   0.000    510|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |    5   0.015 189983|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |    5   0.000     56|     lmt := lmt+time()-st;
  69 |    5   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |    4   0.000    196|         summon := lmCp+minmon;
  76 |    4   0.016  12954|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |    4   0.000  11136|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |    4   0.000     48|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |    4   0.000     35|             H := [op(H), Cp];
  84 |    4   0.000     31|             Np := [op(Np), p];
  85 |    4   0.000     16|             st := time();
  86 |    4   0.048 310483|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |    4   0.000     52|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |    5   0.000     20|     st := time();
  89 |    5   0.015 321914|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |    5   0.000     68|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |    5   0.000     15|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2442|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.016 310370|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000  80980|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   3.453 39707704|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.015 195154| A := semi(A1);
  12 |    1   0.016 195154| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     19| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    428| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   1091| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |    5   0.032   4710|     do
  26 |    5   0.000    557|         p := nextprime(p);
  27 |    5   0.000      0|         lcmintest := true;
  28 |    5   0.000      0|         for i to m do
  29 |   15   0.000    261|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |    5   0.000     20|     st := time();
  32 |    5   0.217 2565920|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |    5   0.000     80|     pt := pt+time()-st;
  34 |    5   0.000  12315|     Rand := rand(1 .. p-1);
  35 |    5   0.000     15|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |    5   0.000    130|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |    5   0.000    285|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |    5   0.016  16355|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |    5   0.000     20|         st := time();
  42 |    5   0.016 102430|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |    5   0.000     80|         laminpolytime := laminpolytime+time()-st;
  44 |    5   0.000     15|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |    5   0.000     20|         M, phimatrix, invphimatrix := LA;
  47 |    5   0.000     20|         st := time();
  48 |    5   0.422 7155104|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |    5   0.453 7155191|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |    5   0.000     80|         phigammatime := phigammatime+time()-st
                                end if;
  51 |    5   0.000     20|     st := time();
  52 |    5   1.562 16048680|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |    5   0.000     80|     pgcdtime := pgcdtime+time()-st;
  54 |    5   0.000     30|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |    5   0.000   1510|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |    5   0.000     15|     if 1 &lt; m then
  62 |    5   0.000     20|         st := time();
  63 |    5   0.267 2971273|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |    5   0.000     80|         phigammatime := phigammatime+time()-st
                                end if;
  65 |    5   0.000     20|     st := time();
  66 |    5   0.000    510|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |    5   0.062 637345|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |    5   0.000     64|     lmt := lmt+time()-st;
  69 |    5   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |    4   0.000    196|         summon := lmCp+minmon;
  76 |    4   0.000  17370|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |    4   0.016  30912|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |    4   0.000     48|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |    4   0.000     35|             H := [op(H), Cp];
  84 |    4   0.000     31|             Np := [op(Np), p];
  85 |    4   0.000     16|             st := time();
  86 |    4   0.234 1061072|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |    4   0.000     60|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |    5   0.000     20|     st := time();
  89 |    5   0.078 1021650|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |    5   0.000     76|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |    5   0.000     15|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2452|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     25|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.047 402695|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000 105484|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   5.578 65495977|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.015 195154| A := semi(A1);
  12 |    1   0.016 195154| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     19| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    428| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   1091| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |    5   0.016   4710|     do
  26 |    5   0.000    557|         p := nextprime(p);
  27 |    5   0.000      0|         lcmintest := true;
  28 |    5   0.000      0|         for i to m do
  29 |   15   0.000    266|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |    5   0.000     20|     st := time();
  32 |    5   0.250 2565920|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |    5   0.000     80|     pt := pt+time()-st;
  34 |    5   0.000  12301|     Rand := rand(1 .. p-1);
  35 |    5   0.000     15|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |    5   0.000    165|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |    5   0.000    285|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |    5   0.000  16355|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |    5   0.000     20|         st := time();
  42 |    5   0.000 102430|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |    5   0.000     44|         laminpolytime := laminpolytime+time()-st;
  44 |    5   0.000     15|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |    5   0.000     20|         M, phimatrix, invphimatrix := LA;
  47 |    5   0.000     20|         st := time();
  48 |    5   0.421 7309251|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |    5   0.579 7310604|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |    5   0.000     80|         phigammatime := phigammatime+time()-st
                                end if;
  51 |    5   0.000     20|     st := time();
  52 |    5   2.719 34795929|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |    5   0.000     80|     pgcdtime := pgcdtime+time()-st;
  54 |    5   0.000     30|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |    5   0.015   2020|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |    5   0.000     15|     if 1 &lt; m then
  62 |    5   0.000     20|         st := time();
  63 |    5   0.890 6342665|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |    5   0.000     80|         phigammatime := phigammatime+time()-st
                                end if;
  65 |    5   0.000     20|     st := time();
  66 |    5   0.016    510|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |    5   0.126 1349528|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |    5   0.000     80|     lmt := lmt+time()-st;
  69 |    5   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |    4   0.000    196|         summon := lmCp+minmon;
  76 |    4   0.000  21799|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |    4   0.031  62496|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |    4   0.000     48|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |    4   0.000     35|             H := [op(H), Cp];
  84 |    4   0.000     31|             Np := [op(Np), p];
  85 |    4   0.000     16|             st := time();
  86 |    4   0.390 2259839|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |    4   0.000     60|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |    5   0.000     20|     st := time();
  89 |    5   0.063 2335655|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |    5   0.000     76|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |    5   0.000     15|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2442|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.015 523018|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.016  83764|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   3.594 43143691|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.015     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.016 285779| A := semi(A1);
  12 |    1   0.031 285779| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     19| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    428| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   1124| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |    7   0.000   8967|     do
  26 |    7   0.000    705|         p := nextprime(p);
  27 |    7   0.000      0|         lcmintest := true;
  28 |    7   0.000      0|         for i to m do
  29 |   21   0.000    357|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |    7   0.000     28|     st := time();
  32 |    7   0.797 5124652|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |    7   0.000    112|     pt := pt+time()-st;
  34 |    7   0.015  17252|     Rand := rand(1 .. p-1);
  35 |    7   0.000     21|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |    7   0.000    196|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |    7   0.000    399|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |    7   0.016  23058|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |    7   0.000     28|         st := time();
  42 |    7   0.047 267645|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |    7   0.000    112|         laminpolytime := laminpolytime+time()-st;
  44 |    7   0.000     21|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |    7   0.000     28|         M, phimatrix, invphimatrix := LA;
  47 |    7   0.000     28|         st := time();
  48 |    7   1.142 15823460|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |    7   0.874 16056725|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |    7   0.000    112|         phigammatime := phigammatime+time()-st
                                end if;
  51 |    7   0.000     28|     st := time();
  52 |    7   0.563 4352871|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |    7   0.000    112|     pgcdtime := pgcdtime+time()-st;
  54 |    7   0.000     42|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |    7   0.000    784|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |    7   0.000     21|     if 1 &lt; m then
  62 |    7   0.000     28|         st := time();
  63 |    7   0.015 202060|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |    7   0.000    112|         phigammatime := phigammatime+time()-st
                                end if;
  65 |    7   0.000     28|     st := time();
  66 |    7   0.000    714|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |    7   0.000  34300|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |    7   0.000     60|     lmt := lmt+time()-st;
  69 |    7   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |    6   0.000     30|         summon := lmCp+minmon;
  76 |    6   0.000  13383|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |    6   0.000   6642|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |    6   0.000     72|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |    6   0.000     60|             H := [op(H), Cp];
  84 |    6   0.000     54|             Np := [op(Np), p];
  85 |    6   0.000     24|             st := time();
  86 |    6   0.031  78340|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |    6   0.000     76|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |    7   0.000     28|     st := time();
  89 |    7   0.000  55977|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |    7   0.000     92|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |    7   0.000     21|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2445|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     30|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.016 455754|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.016  42022|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   4.437 54317093|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.031 285779| A := semi(A1);
  12 |    1   0.031 285779| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     19| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    428| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   1124| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |    7   0.016   8967|     do
  26 |    7   0.000    705|         p := nextprime(p);
  27 |    7   0.000      0|         lcmintest := true;
  28 |    7   0.000      0|         for i to m do
  29 |   21   0.000    362|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |    7   0.000     28|     st := time();
  32 |    7   0.485 5123860|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |    7   0.000    112|     pt := pt+time()-st;
  34 |    7   0.000  17231|     Rand := rand(1 .. p-1);
  35 |    7   0.000     21|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |    7   0.000    211|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |    7   0.000    399|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |    7   0.000  23058|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |    7   0.000     28|         st := time();
  42 |    7   0.031 267645|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |    7   0.000     96|         laminpolytime := laminpolytime+time()-st;
  44 |    7   0.000     21|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |    7   0.000     28|         M, phimatrix, invphimatrix := LA;
  47 |    7   0.000     28|         st := time();
  48 |    7   1.296 15874205|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |    7   1.110 16057329|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |    7   0.000    112|         phigammatime := phigammatime+time()-st
                                end if;
  51 |    7   0.000     28|     st := time();
  52 |    7   1.080 11520605|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |    7   0.000    112|     pgcdtime := pgcdtime+time()-st;
  54 |    7   0.000     42|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |    7   0.015   1400|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |    7   0.000     21|     if 1 &lt; m then
  62 |    7   0.000     28|         st := time();
  63 |    7   0.108 2003927|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |    7   0.000    112|         phigammatime := phigammatime+time()-st
                                end if;
  65 |    7   0.000     28|     st := time();
  66 |    7   0.000    714|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |    7   0.063 375270|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |    7   0.000    112|     lmt := lmt+time()-st;
  69 |    7   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |    6   0.000    294|         summon := lmCp+minmon;
  76 |    6   0.000  19431|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |    6   0.000  22152|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |    6   0.000     72|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |    6   0.000     60|             H := [op(H), Cp];
  84 |    6   0.000     54|             Np := [op(Np), p];
  85 |    6   0.000     24|             st := time();
  86 |    6   0.140 991040|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |    6   0.000     84|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |    7   0.000     28|     st := time();
  89 |    7   0.016 799257|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |    7   0.000    100|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |    7   0.000     21|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2424|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.015 498280|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000 133332|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   7.813 83204197|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.031 285779| A := semi(A1);
  12 |    1   0.032 285779| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     19| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    428| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   1124| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |    7   0.015   8967|     do
  26 |    7   0.000    705|         p := nextprime(p);
  27 |    7   0.000      0|         lcmintest := true;
  28 |    7   0.000      0|         for i to m do
  29 |   21   0.000    367|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |    7   0.000     28|     st := time();
  32 |    7   0.547 5123860|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |    7   0.000    112|     pt := pt+time()-st;
  34 |    7   0.000  17217|     Rand := rand(1 .. p-1);
  35 |    7   0.000     21|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |    7   0.000    216|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |    7   0.000    399|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |    7   0.047  23058|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |    7   0.000     28|         st := time();
  42 |    7   0.000 267645|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |    7   0.000     60|         laminpolytime := laminpolytime+time()-st;
  44 |    7   0.000     21|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |    7   0.000     28|         M, phimatrix, invphimatrix := LA;
  47 |    7   0.000     28|         st := time();
  48 |    7   2.061 16291556|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |    7   1.095 16290616|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |    7   0.000    112|         phigammatime := phigammatime+time()-st
                                end if;
  51 |    7   0.000     28|     st := time();
  52 |    7   2.625 29513978|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |    7   0.000    112|     pgcdtime := pgcdtime+time()-st;
  54 |    7   0.000     42|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |    7   0.000   2114|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |    7   0.000     21|     if 1 &lt; m then
  62 |    7   0.000     28|         st := time();
  63 |    7   0.468 6752416|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |    7   0.000    112|         phigammatime := phigammatime+time()-st
                                end if;
  65 |    7   0.000     28|     st := time();
  66 |    7   0.000    714|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |    7   0.110 1274693|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |    7   0.000    112|     lmt := lmt+time()-st;
  69 |    7   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |    6   0.000    294|         summon := lmCp+minmon;
  76 |    6   0.000  26055|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |    6   0.000  63336|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |    6   0.000     72|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |    6   0.000     60|             H := [op(H), Cp];
  84 |    6   0.000     54|             Np := [op(Np), p];
  85 |    6   0.000     24|             st := time();
  86 |    6   0.532 3418701|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |    6   0.000     92|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |    7   0.000     28|     st := time();
  89 |    7   0.218 2798056|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |    7   0.000    108|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |    7   0.000     21|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2459|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     30|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.032 578450|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000 173340|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  12.282 135521993|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.032 285779| A := semi(A1);
  12 |    1   0.015 285779| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     19| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    428| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   1124| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |    7   0.032   8967|     do
  26 |    7   0.000    705|         p := nextprime(p);
  27 |    7   0.000      0|         lcmintest := true;
  28 |    7   0.000      0|         for i to m do
  29 |   21   0.000    382|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |    7   0.000     28|     st := time();
  32 |    7   0.639 5124652|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |    7   0.000    112|     pt := pt+time()-st;
  34 |    7   0.000  17209|     Rand := rand(1 .. p-1);
  35 |    7   0.000     21|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |    7   0.000    236|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |    7   0.000    399|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |    7   0.000  23058|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |    7   0.000     28|         st := time();
  42 |    7   0.030 267645|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |    7   0.000    104|         laminpolytime := laminpolytime+time()-st;
  44 |    7   0.000     21|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |    7   0.000     28|         M, phimatrix, invphimatrix := LA;
  47 |    7   0.000     28|         st := time();
  48 |    7   0.924 16758272|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |    7   0.938 16757870|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |    7   0.000    112|         phigammatime := phigammatime+time()-st
                                end if;
  51 |    7   0.000     28|     st := time();
  52 |    7   5.718 64381835|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |    7   0.000    112|     pgcdtime := pgcdtime+time()-st;
  54 |    7   0.000     42|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |    7   0.015   2828|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |    7   0.000     21|     if 1 &lt; m then
  62 |    7   0.000     28|         st := time();
  63 |    7   1.235 14430070|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |    7   0.000    112|         phigammatime := phigammatime+time()-st
                                end if;
  65 |    7   0.000     28|     st := time();
  66 |    7   0.000    714|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |    7   0.235 2708628|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |    7   0.000    112|     lmt := lmt+time()-st;
  69 |    7   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |    6   0.000    294|         summon := lmCp+minmon;
  76 |    6   0.016  32705|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |    6   0.015 129144|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |    6   0.000     72|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |    6   0.000     60|             H := [op(H), Cp];
  84 |    6   0.000     54|             Np := [op(Np), p];
  85 |    6   0.000     24|             st := time();
  86 |    6   1.563 7300442|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |    6   0.000     92|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |    7   0.000     28|     st := time();
  89 |    7   0.812 6030582|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |    7   0.000    108|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |    7   0.000     21|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2449|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.047 830428|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.016 137460|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   6.250 81295174|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.046 412654| A := semi(A1);
  12 |    1   0.032 412654| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     20| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    577| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   1639| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   10   0.062  17950|     do
  26 |   10   0.000    949|         p := nextprime(p);
  27 |   10   0.000      0|         lcmintest := true;
  28 |   10   0.000      0|         for i to m do
  29 |   40   0.000    671|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   10   0.000     40|     st := time();
  32 |   10   0.907 10940920|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   10   0.000    160|     pt := pt+time()-st;
  34 |   10   0.000  24618|     Rand := rand(1 .. p-1);
  35 |   10   0.000     30|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   10   0.000    485|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   10   0.000    740|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   10   0.016  51680|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   10   0.000     40|         st := time();
  42 |   10   0.046 601230|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   10   0.000    152|         laminpolytime := laminpolytime+time()-st;
  44 |   10   0.000     30|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   10   0.000     40|         M, phimatrix, invphimatrix := LA;
  47 |   10   0.000     40|         st := time();
  48 |   10   1.609 29848890|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   10   2.297 29849005|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   10   0.000    160|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   10   0.000     40|     st := time();
  52 |   10   1.157 7608484|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   10   0.000    160|     pgcdtime := pgcdtime+time()-st;
  54 |   10   0.000     60|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   10   0.000   1120|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   10   0.000     30|     if 1 &lt; m then
  62 |   10   0.000     40|         st := time();
  63 |   10   0.030 404937|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   10   0.000    160|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   10   0.000     40|     st := time();
  66 |   10   0.000   1030|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   10   0.000  66110|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   10   0.000     84|     lmt := lmt+time()-st;
  69 |   10   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |    9   0.000     45|         summon := lmCp+minmon;
  76 |    9   0.000  22947|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |    9   0.000  14184|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |    9   0.000    108|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |    9   0.000    105|             H := [op(H), Cp];
  84 |    9   0.000     96|             Np := [op(Np), p];
  85 |    9   0.000     36|             st := time();
  86 |    9   0.016 231140|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |    9   0.000    116|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   10   0.000     40|     st := time();
  89 |   10   0.000 112551|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   10   0.000    132|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   10   0.000     30|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2445|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.032 612190|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000  50874|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   8.281 92577670|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.031 412654| A := semi(A1);
  12 |    1   0.047 412654| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     20| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    577| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   1639| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |    9   0.000  16155|     do
  26 |    9   0.000    930|         p := nextprime(p);
  27 |    9   0.000      0|         lcmintest := true;
  28 |    9   0.000      0|         for i to m do
  29 |   36   0.000    612|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |    9   0.000     36|     st := time();
  32 |    9   1.343 9848012|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |    9   0.000    144|     pt := pt+time()-st;
  34 |    9   0.000  22189|     Rand := rand(1 .. p-1);
  35 |    9   0.016     27|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |    9   0.000    391|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |    9   0.000    666|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |    9   0.016  46512|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |    9   0.000     36|         st := time();
  42 |    9   0.048 541107|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |    9   0.000    120|         laminpolytime := laminpolytime+time()-st;
  44 |    9   0.000     27|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |    9   0.000     36|         M, phimatrix, invphimatrix := LA;
  47 |    9   0.000     36|         st := time();
  48 |    9   1.531 26991135|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |    9   1.953 26991353|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |    9   0.000    144|         phigammatime := phigammatime+time()-st
                                end if;
  51 |    9   0.000     36|     st := time();
  52 |    9   1.952 18221832|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |    9   0.000    144|     pgcdtime := pgcdtime+time()-st;
  54 |    9   0.000     54|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |    9   0.000   1800|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |    9   0.000     27|     if 1 &lt; m then
  62 |    9   0.000     36|         st := time();
  63 |    9   0.251 3563927|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |    9   0.000    144|         phigammatime := phigammatime+time()-st
                                end if;
  65 |    9   0.000     36|     st := time();
  66 |    9   0.000    927|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |    9   0.062 700479|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |    9   0.000    128|     lmt := lmt+time()-st;
  69 |    9   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |    8   0.000    392|         summon := lmCp+minmon;
  76 |    8   0.000  28564|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |    8   0.016  42288|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |    8   0.000     96|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |    8   0.000     89|             H := [op(H), Cp];
  84 |    8   0.000     81|             Np := [op(Np), p];
  85 |    8   0.000     32|             st := time();
  86 |    8   0.453 2464421|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |    8   0.000    124|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |    9   0.000     36|     st := time();
  89 |    9   0.093 1408057|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |    9   0.000    140|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |    9   0.000     27|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2438|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.454 688673|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.015 164964|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  14.328 160686110|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.047 412654| A := semi(A1);
  12 |    1   0.031 412654| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     20| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    577| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   1639| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   10   0.031  17950|     do
  26 |   10   0.000    949|         p := nextprime(p);
  27 |   10   0.000      0|         lcmintest := true;
  28 |   10   0.000      0|         for i to m do
  29 |   40   0.000    691|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   10   0.000     40|     st := time();
  32 |   10   0.954 10940920|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   10   0.000    160|     pt := pt+time()-st;
  34 |   10   0.000  24609|     Rand := rand(1 .. p-1);
  35 |   10   0.000     30|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   10   0.000    470|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   10   0.016    740|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   10   0.015  51680|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   10   0.000     40|         st := time();
  42 |   10   0.047 601230|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   10   0.000    152|         laminpolytime := laminpolytime+time()-st;
  44 |   10   0.000     30|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   10   0.000     40|         M, phimatrix, invphimatrix := LA;
  47 |   10   0.000     40|         st := time();
  48 |   10   2.314 31121357|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   10   2.328 30804596|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   10   0.000    160|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   10   0.000     40|     st := time();
  52 |   10   4.624 52530022|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   10   0.000    160|     pgcdtime := pgcdtime+time()-st;
  54 |   10   0.000     60|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   10   0.000   3020|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   10   0.000     30|     if 1 &lt; m then
  62 |   10   0.000     40|         st := time();
  63 |   10   1.327 13376908|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   10   0.000    160|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   10   0.000     40|     st := time();
  66 |   10   0.016   1030|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   10   0.219 2663346|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   10   0.000    160|     lmt := lmt+time()-st;
  69 |   10   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |    9   0.000    441|         summon := lmCp+minmon;
  76 |    9   0.000  42198|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |    9   0.030 136350|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |    9   0.000    108|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |    9   0.000    105|             H := [op(H), Cp];
  84 |    9   0.000     96|             Np := [op(Np), p];
  85 |    9   0.000     36|             st := time();
  86 |    9   1.923 10821089|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |    9   0.000    140|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   10   0.000     40|     st := time();
  89 |   10   0.359 5639661|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   10   0.000    156|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   10   0.000     30|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2456|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     30|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.031 859136|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.016 215148|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  21.734 233176804|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.094 412654| A := semi(A1);
  12 |    1   0.047 412654| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     20| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    577| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   1639| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |    9   0.032  16155|     do
  26 |    9   0.000    930|         p := nextprime(p);
  27 |    9   0.000      0|         lcmintest := true;
  28 |    9   0.000      0|         for i to m do
  29 |   36   0.000    632|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |    9   0.000     36|     st := time();
  32 |    9   0.859 9846828|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |    9   0.000    144|     pt := pt+time()-st;
  34 |    9   0.000  22099|     Rand := rand(1 .. p-1);
  35 |    9   0.016     27|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |    9   0.000    371|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |    9   0.000    666|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |    9   0.046  46512|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |    9   0.000     36|         st := time();
  42 |    9   0.016 541107|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |    9   0.000    136|         laminpolytime := laminpolytime+time()-st;
  44 |    9   0.000     27|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |    9   0.000     36|         M, phimatrix, invphimatrix := LA;
  47 |    9   0.000     36|         st := time();
  48 |    9   1.406 28583118|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |    9   1.704 28583292|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |    9   0.000    144|         phigammatime := phigammatime+time()-st
                                end if;
  51 |    9   0.000     36|     st := time();
  52 |    9  10.529 103482724|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |    9   0.000    144|     pgcdtime := pgcdtime+time()-st;
  54 |    9   0.000     54|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |    9   0.000   3636|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |    9   0.000     27|     if 1 &lt; m then
  62 |    9   0.000     36|         st := time();
  63 |    9   2.624 25827877|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |    9   0.000    144|         phigammatime := phigammatime+time()-st
                                end if;
  65 |    9   0.000     36|     st := time();
  66 |    9   0.064    927|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |    9   0.530 5104736|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |    9   0.000    144|     lmt := lmt+time()-st;
  69 |    9   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |    8   0.000    392|         summon := lmCp+minmon;
  76 |    8   0.000  46472|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |    8   0.064 247344|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |    8   0.000     96|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |    8   0.000     89|             H := [op(H), Cp];
  84 |    8   0.000     81|             Np := [op(Np), p];
  85 |    8   0.000     32|             st := time();
  86 |    8   3.188 18246391|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |    8   0.000    124|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |    9   0.000     36|     st := time();
  89 |    9   0.469 10439450|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |    9   0.000    140|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |    9   0.000     27|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2466|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.031 1132077|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.015 170724|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  18.000 229595213|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.062 612029| A := semi(A1);
  12 |    1   0.063 612029| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     20| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    577| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   1673| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   16   0.047  40944|     do
  26 |   16   0.000   1514|         p := nextprime(p);
  27 |   16   0.000      0|         lcmintest := true;
  28 |   16   0.000      0|         for i to m do
  29 |   64   0.000   1115|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   16   0.000     64|     st := time();
  32 |   16   2.344 25646208|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   16   0.000    256|     pt := pt+time()-st;
  34 |   16   0.000  39353|     Rand := rand(1 .. p-1);
  35 |   16   0.000     48|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   16   0.000    769|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   16   0.000   1184|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   16   0.109  83056|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   16   0.000     64|         st := time();
  42 |   16   0.157 2212592|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   16   0.000    256|         laminpolytime := laminpolytime+time()-st;
  44 |   16   0.000     48|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   16   0.000     64|         M, phimatrix, invphimatrix := LA;
  47 |   16   0.000     64|         st := time();
  48 |   16   4.532 90294960|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   16   7.936 90300870|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   16   0.000    256|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   16   0.000     64|     st := time();
  52 |   16   2.484 16231329|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   16   0.000    256|     pgcdtime := pgcdtime+time()-st;
  54 |   16   0.000     96|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   16   0.000   1792|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   16   0.000     48|     if 1 &lt; m then
  62 |   16   0.000     64|         st := time();
  63 |   16   0.062 1071596|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   16   0.000    256|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   16   0.000     64|     st := time();
  66 |   16   0.000   1648|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   16   0.000 141200|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   16   0.000    132|     lmt := lmt+time()-st;
  69 |   16   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   15   0.000     75|         summon := lmCp+minmon;
  76 |   15   0.000  38415|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   15   0.000  29760|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   15   0.000    180|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   15   0.000    222|             H := [op(H), Cp];
  84 |   15   0.000    207|             Np := [op(Np), p];
  85 |   15   0.000     60|             st := time();
  86 |   15   0.157 919200|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   15   0.000    212|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   16   0.000     64|     st := time();
  89 |   16   0.000 323995|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   16   0.000    228|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   16   0.000     48|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2445|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     30|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.047 894306|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000  86762|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  23.906 287950105|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.062 612029| A := semi(A1);
  12 |    1   0.063 612029| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     20| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    577| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   1673| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   16   0.078  40944|     do
  26 |   16   0.000   1514|         p := nextprime(p);
  27 |   16   0.000      0|         lcmintest := true;
  28 |   16   0.000      0|         for i to m do
  29 |   64   0.000   1115|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   16   0.000     64|     st := time();
  32 |   16   2.375 25646208|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   16   0.000    256|     pt := pt+time()-st;
  34 |   16   0.000  39345|     Rand := rand(1 .. p-1);
  35 |   16   0.000     48|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   16   0.000    699|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   16   0.000   1184|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   16   0.080  83056|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   16   0.000     64|         st := time();
  42 |   16   0.172 2212592|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   16   0.000    256|         laminpolytime := laminpolytime+time()-st;
  44 |   16   0.000     48|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   16   0.000     64|         M, phimatrix, invphimatrix := LA;
  47 |   16   0.000     64|         st := time();
  48 |   16   4.672 90294960|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   16   9.076 90170347|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   16   0.000    256|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   16   0.000     64|     st := time();
  52 |   16   4.313 45044794|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   16   0.000    256|     pgcdtime := pgcdtime+time()-st;
  54 |   16   0.000     96|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   16   0.000   3200|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   16   0.000     48|     if 1 &lt; m then
  62 |   16   0.000     64|         st := time();
  63 |   16   0.689 11804882|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   16   0.000    256|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   16   0.000     64|     st := time();
  66 |   16   0.000   1648|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   16   0.187 1810800|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   16   0.000    256|     lmt := lmt+time()-st;
  69 |   16   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   15   0.000    735|         summon := lmCp+minmon;
  76 |   15   0.000  53655|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   15   0.000 109710|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   15   0.000    180|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   15   0.000    222|             H := [op(H), Cp];
  84 |   15   0.000    207|             Np := [op(Np), p];
  85 |   15   0.000     60|             st := time();
  86 |   15   1.998 13205045|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   15   0.000    236|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   16   0.000     64|     st := time();
  89 |   16   0.078 4867207|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   16   0.000    252|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   16   0.000     48|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2441|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.047 1046905|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.016 276832|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  37.157 406169440|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.016     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.063 612029| A := semi(A1);
  12 |    1   0.046 612029| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     20| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    577| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   1673| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   15   0.093  38385|     do
  26 |   15   0.000   1484|         p := nextprime(p);
  27 |   15   0.000      0|         lcmintest := true;
  28 |   15   0.000      0|         for i to m do
  29 |   60   0.000   1046|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   15   0.000     60|     st := time();
  32 |   15   2.406 24043726|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   15   0.000    240|     pt := pt+time()-st;
  34 |   15   0.000  36889|     Rand := rand(1 .. p-1);
  35 |   15   0.000     45|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   15   0.000    660|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   15   0.000   1110|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   15   0.110  77865|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   15   0.000     60|         st := time();
  42 |   15   0.141 2074305|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   15   0.000    232|         laminpolytime := laminpolytime+time()-st;
  44 |   15   0.000     45|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   15   0.000     60|         M, phimatrix, invphimatrix := LA;
  47 |   15   0.000     60|         st := time();
  48 |   15   6.046 84677668|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   15   7.515 84679406|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   15   0.000    240|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   15   0.000     60|     st := time();
  52 |   15   9.783 109052752|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   15   0.000    240|     pgcdtime := pgcdtime+time()-st;
  54 |   15   0.000     90|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   15   0.015   4530|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   15   0.000     45|     if 1 &lt; m then
  62 |   15   0.000     60|         st := time();
  63 |   15   3.186 37747503|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   15   0.000    240|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   15   0.000     60|     st := time();
  66 |   15   0.031   1545|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   15   0.471 5850215|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   15   0.000    240|     lmt := lmt+time()-st;
  69 |   15   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   14   0.000    686|         summon := lmCp+minmon;
  76 |   14   0.016  65702|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   14   0.109 300972|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   14   0.000    168|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   14   0.000    200|             H := [op(H), Cp];
  84 |   14   0.000    186|             Np := [op(Np), p];
  85 |   14   0.000     56|             st := time();
  86 |   14   6.032 39761587|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   14   0.000    220|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   15   0.000     60|     st := time();
  89 |   15   1.000 14836382|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   15   0.000    236|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   15   0.000     45|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2449|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.016    295|         do
  96 |    1   0.000     25|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.046 1322414|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.016 360112|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  67.641 700914685|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.062 612029| A := semi(A1);
  12 |    1   0.047 612029| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     20| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    577| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   1673| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   16   0.159  40944|     do
  26 |   16   0.000   1514|         p := nextprime(p);
  27 |   16   0.000      0|         lcmintest := true;
  28 |   16   0.000      0|         for i to m do
  29 |   64   0.000   1115|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   16   0.000     64|     st := time();
  32 |   16   3.095 25646208|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   16   0.000    256|     pt := pt+time()-st;
  34 |   16   0.000  39409|     Rand := rand(1 .. p-1);
  35 |   16   0.000     48|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   16   0.000    709|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   16   0.000   1184|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   16   0.062  83056|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   16   0.000     64|         st := time();
  42 |   16   0.232 2212592|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   16   0.000    248|         laminpolytime := laminpolytime+time()-st;
  44 |   16   0.000     48|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   16   0.000     64|         M, phimatrix, invphimatrix := LA;
  47 |   16   0.000     64|         st := time();
  48 |   16   7.344 90296171|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   16   7.081 90296609|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   16   0.000    256|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   16   0.000     64|     st := time();
  52 |   16  23.233 255508208|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   16   0.000    256|     pgcdtime := pgcdtime+time()-st;
  54 |   16   0.000     96|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   16   0.032   6464|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   16   0.000     48|     if 1 &lt; m then
  62 |   16   0.000     64|         st := time();
  63 |   16   5.265 86239014|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   16   0.000    256|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   16   0.000     64|     st := time();
  66 |   16   0.048   1648|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   16   1.516 13316001|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   16   0.000    256|     lmt := lmt+time()-st;
  69 |   16   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   15   0.000    735|         summon := lmCp+minmon;
  76 |   15   0.000  87135|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   15   0.124 662670|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   15   0.000    180|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   15   0.000    222|             H := [op(H), Cp];
  84 |   15   0.000    207|             Np := [op(Np), p];
  85 |   15   0.000     60|             st := time();
  86 |   15  17.904 98273992|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   15   0.000    236|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   16   0.000     64|     st := time();
  89 |   16   1.358 34829245|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   16   0.000    252|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   16   0.000     48|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2456|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.016    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.063 1851903|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000 285424|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  34.250 427354615|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.015     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.094 857654| A := semi(A1);
  12 |    1   0.078 857654| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   23   0.186  80592|     do
  26 |   23   0.000   2021|         p := nextprime(p);
  27 |   23   0.000      0|         lcmintest := true;
  28 |   23   0.000      0|         for i to m do
  29 |  115   0.000   1966|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   23   0.000     92|     st := time();
  32 |   23   4.829 51870474|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   23   0.000    368|     pt := pt+time()-st;
  34 |   23   0.000  56517|     Rand := rand(1 .. p-1);
  35 |   23   0.000     69|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   23   0.000   1245|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   23   0.000   2093|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   23   0.172 175720|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   23   0.000     92|         st := time();
  42 |   23   0.313 4867099|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   23   0.000    352|         laminpolytime := laminpolytime+time()-st;
  44 |   23   0.000     69|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   23   0.000     92|         M, phimatrix, invphimatrix := LA;
  47 |   23   0.000     92|         st := time();
  48 |   23   8.534 165609752|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   23  15.015 165432154|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   23   0.000    368|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   23   0.000     92|     st := time();
  52 |   23   4.373 30222076|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   23   0.000    368|     pgcdtime := pgcdtime+time()-st;
  54 |   23   0.000    138|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   23   0.000   2576|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   23   0.015     69|     if 1 &lt; m then
  62 |   23   0.000     92|         st := time();
  63 |   23   0.142 2094303|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   23   0.000    368|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   23   0.000     92|     st := time();
  66 |   23   0.000   2392|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   23   0.031 271170|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   23   0.000    352|     lmt := lmt+time()-st;
  69 |   23   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   22   0.000    110|         summon := lmCp+minmon;
  76 |   22   0.015  63514|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   22   0.000  63382|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   22   0.000    264|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   22   0.000    404|             H := [op(H), Cp];
  84 |   22   0.000    382|             Np := [op(Np), p];
  85 |   22   0.000     88|             st := time();
  86 |   22   0.375 2736866|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   22   0.000    324|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   23   0.000     92|     st := time();
  89 |   23   0.000 725630|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   23   0.000    340|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   23   0.000     69|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2452|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.063 1245219|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000 101354|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  39.203 473387220|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.078 857654| A := semi(A1);
  12 |    1   0.094 857654| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   20   0.204  70080|     do
  26 |   20   0.000   1733|         p := nextprime(p);
  27 |   20   0.000      0|         lcmintest := true;
  28 |   20   0.000      0|         for i to m do
  29 |  100   0.000   1711|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   20   0.000     80|     st := time();
  32 |   20   4.886 45105572|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   20   0.000    320|     pt := pt+time()-st;
  34 |   20   0.000  49249|     Rand := rand(1 .. p-1);
  35 |   20   0.000     60|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   20   0.000   1140|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   20   0.000   1820|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   20   0.156 152800|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   20   0.000     80|         st := time();
  42 |   20   0.284 4232260|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   20   0.000    312|         laminpolytime := laminpolytime+time()-st;
  44 |   20   0.000     60|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   20   0.000     80|         M, phimatrix, invphimatrix := LA;
  47 |   20   0.000     80|         st := time();
  48 |   20  12.031 143787836|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   20   7.562 144391303|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   20   0.000    320|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   20   0.000     80|     st := time();
  52 |   20   6.954 71617728|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   20   0.000    320|     pgcdtime := pgcdtime+time()-st;
  54 |   20   0.000    120|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   20   0.000   4000|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   20   0.000     60|     if 1 &lt; m then
  62 |   20   0.000     80|         st := time();
  63 |   20   1.220 18897111|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   20   0.000    320|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   20   0.000     80|     st := time();
  66 |   20   0.015   2080|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   20   0.297 3148300|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   20   0.000    312|     lmt := lmt+time()-st;
  69 |   20   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   19   0.000    931|         summon := lmCp+minmon;
  76 |   19   0.000  74347|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   19   0.047 194484|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   19   0.000    228|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   19   0.000    320|             H := [op(H), Cp];
  84 |   19   0.000    301|             Np := [op(Np), p];
  85 |   19   0.000     76|             st := time();
  86 |   19   5.140 29621558|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   19   0.000    300|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   20   0.000     80|     st := time();
  89 |   20   0.157 8545374|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   20   0.000    316|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   20   0.000     60|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2456|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     25|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.062 1429283|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.016 330804|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  79.812 836729723|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.016     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.078 857654| A := semi(A1);
  12 |    1   0.078 857654| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   22   0.140  77088|     do
  26 |   22   0.000   1914|         p := nextprime(p);
  27 |   22   0.000      0|         lcmintest := true;
  28 |   22   0.000      0|         for i to m do
  29 |  110   0.000   1881|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   22   0.000     88|     st := time();
  32 |   22   5.423 49659454|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   22   0.000    352|     pt := pt+time()-st;
  34 |   22   0.000  54178|     Rand := rand(1 .. p-1);
  35 |   22   0.000     66|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   22   0.000   1290|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   22   0.000   2002|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   22   0.139 168080|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   22   0.000     88|         st := time();
  42 |   22   0.361 4655486|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   22   0.000    352|         laminpolytime := laminpolytime+time()-st;
  44 |   22   0.000     66|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   22   0.000     88|         M, phimatrix, invphimatrix := LA;
  47 |   22   0.000     88|         st := time();
  48 |   22  10.982 161769099|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   22   9.892 161763549|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   22   0.000    352|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   22   0.000     88|     st := time();
  52 |   22  22.203 207669968|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   22   0.000    352|     pgcdtime := pgcdtime+time()-st;
  54 |   22   0.000    132|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   22   0.031   6644|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   22   0.000     66|     if 1 &lt; m then
  62 |   22   0.000     88|         st := time();
  63 |   22   6.422 70695944|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   22   0.000    352|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   22   0.000     88|     st := time();
  66 |   22   0.047   2288|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   22   1.219 11974748|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   22   0.000    352|     lmt := lmt+time()-st;
  69 |   22   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   21   0.000   1029|         summon := lmCp+minmon;
  76 |   21   0.016 105861|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   21   0.125 626220|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   21   0.000    252|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   21   0.000    375|             H := [op(H), Cp];
  84 |   21   0.000    354|             Np := [op(Np), p];
  85 |   21   0.000     84|             st := time();
  86 |   21  21.328 127752787|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   21   0.000    332|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   22   0.000     88|     st := time();
  89 |   22   1.219 35714292|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   22   0.000    348|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   22   0.000     66|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2456|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.078 1867926|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.015 431772|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

</Text-field>
</Output>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUkqbWNvbXBsZXRlRzYjL0krbW9kdWxlbmFtZUc2IkksVHlwZXNldHRpbmdHSShfc3lzbGliR0YnNiQtSSVtcm93R0YkNiYtSSNtaUdGJDYlUSJSRicvJSdpdGFsaWNHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ2l0YWxpY0YnLUkjbW9HRiQ2LlEpJkFzc2lnbjtGJy9GNlEnbm9ybWFsRicvJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHRkAvJSlzdHJldGNoeUdGQC8lKnN5bW1ldHJpY0dGQC8lKGxhcmdlb3BHRkAvJS5tb3ZhYmxlbGltaXRzR0ZALyUnYWNjZW50R0ZALyUnbHNwYWNlR1EsMC4yNzc3Nzc4ZW1GJy8lJ3JzcGFjZUdGTy8lKWVxdWFsaXR5R0ZALUYsNiYtRiw2Ji1JKG1mZW5jZWRHRiQ2KC1GLDYmLUktbXNjcm9sbHRhYmxlR0YkNmpvLUkqbXNjcm9sbHRyR0YkNjItSSptc2Nyb2xsdGRHRiQ2Ki1JI21zR0YkNiNRI2RGRicvJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnLyUpcmVhZG9ubHlHRkAvJSlyb3dhbGlnbkdRIUYnLyUsY29sdW1uYWxpZ25HRltwLyUrZ3JvdXBhbGlnbkdGW3AvJShyb3dzcGFuR1EiMUYnLyUrY29sdW1uc3BhbkdGYnAtRl5vNiotRmFvNiNRJSNleHRGJ0Zkb0Znb0Zpb0ZccEZecEZgcEZjcC1GXm82Ki1GYW82I1ElI3ZhckYnRmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZebzYqLUZhbzYjUSlUZGVnKGYxKUYnRmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZebzYqLUZhbzYjUSlUZGVnKGYyKUYnRmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZebzYqLUZhbzYjUShUZGVnKGcpRidGZG9GZ29GaW9GXHBGXnBGYHBGY3AtRl5vNiotRmFvNiNRKFRkZWcoYSlGJ0Zkb0Znb0Zpb0ZccEZecEZgcEZjcC1GXm82Ki1GYW82I1EoVGRlZyhiKUYnRmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZebzYqLUZhbzYjUSpUZGVnKEdDRClGJ0Zkb0Znb0Zpb0ZccEZecEZgcEZjcC1GXm82Ki1GYW82I1ElVGltZUYnRmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZebzYqLUZhbzYjUSNOcEYnRmRvRmdvRmlvRlxwRl5wRmBwRmNwRmRvRmdvRmlvRlxwRl5wLUZbbzYyLUZebzYqLUkjbW5HRiQ2JFEiNEYnRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3AtRl5vNiotRlx0NiRRIjJGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRl90LUZebzYqLUZcdDYkUSM0OEYnRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGZHRGX3QtRl5vNiotRlx0NiRRIzQ2RidGPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZpdEZfdC1GXm82Ki1GXHQ2JFEmMC4yNjVGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZebzYqLUZcdDYkRmJwRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGZG9GZ29GaW9GXHBGXnAtRltvNjJGaXNGX3RGX3RGZHRGZHQtRl5vNiotRlx0NiRRIzEyRidGPEZkb0Znb0Zpb0ZccEZecEZgcEZjcC1GXm82Ki1GXHQ2JFEjMzZGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRl52Rml1LUZebzYqLUZcdDYkUSYwLjM0NEYnRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGY3VGZG9GZ29GaW9GXHBGXnAtRltvNjJGaXNGX3RGX3RGZHRGZHQtRl5vNiotRlx0NiRRIzI0RidGPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZqdkZqdkZqdi1GXm82Ki1GXHQ2JFEmMC42NDFGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmN1RmRvRmdvRmlvRlxwRl5wLUZbbzYyRmlzRl90Rl90RmR0RmR0Rl52Rml1Rml1Rl52LUZebzYqLUZcdDYkUSYyLjEyNUYnRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGY3VGZG9GZ29GaW9GXHBGXnAtRltvNjItRl5vNiotRlx0NiRRIjhGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZebzYqLUZcdDYkUSIzRidGPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZfdEZkdEZkdEZfdEZpdEZpdEZfdC1GXm82Ki1GXHQ2JFEmMS4zMjhGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmlzRmRvRmdvRmlvRlxwRl5wLUZbbzYyRl14RmJ4Rl90RmR0RmR0Rml1Rl52Rl52Rml1LUZebzYqLUZcdDYkUSYyLjg2MEYnRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGaXNGZG9GZ29GaW9GXHBGXnAtRltvNjJGXXhGYnhGX3RGZHRGZHRGanZGanZGanZGanYtRl5vNiotRlx0NiRRJjMuNDUzRidGPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZpc0Zkb0Znb0Zpb0ZccEZecC1GW282MkZdeEZieEZfdEZkdEZkdEZedkZpdUZpdUZedi1GXm82Ki1GXHQ2JFEmNS41NzhGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmlzRmRvRmdvRmlvRlxwRl5wLUZbbzYyRml1RmJ4Rl90RmR0RmR0Rl90Rml0Rml0Rl90LUZebzYqLUZcdDYkUSYzLjU5NEYnRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3AtRl5vNiotRlx0NiRRIjZGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmRvRmdvRmlvRlxwRl5wLUZbbzYyRml1RmJ4Rl90RmR0RmR0Rml1Rl52Rl52Rml1LUZebzYqLUZcdDYkUSY0LjQzN0YnRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGaHpGZG9GZ29GaW9GXHBGXnAtRltvNjJGaXVGYnhGX3RGZHRGZHRGanZGanZGanZGanYtRl5vNiotRlx0NiRRJjcuODEzRidGPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZoekZkb0Znb0Zpb0ZccEZecC1GW282MkZpdUZieEZfdEZkdEZkdEZedkZpdUZpdUZedi1GXm82Ki1GXHQ2JFEnMTIuMjgyRidGPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZoekZkb0Znb0Zpb0ZccEZecC1GW282Mi1GXm82Ki1GXHQ2JFEjMTZGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmlzRl90RmR0RmR0Rl90Rml0Rml0Rl90LUZebzYqLUZcdDYkUSY2LjI1MEYnRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3AtRl5vNiotRlx0NiRRIjlGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmRvRmdvRmlvRlxwRl5wLUZbbzYyRmRcbEZpc0ZfdEZkdEZkdEZpdUZedkZedkZpdS1GXm82Ki1GXHQ2JFEmOC4yODFGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRl14RmRvRmdvRmlvRlxwRl5wLUZbbzYyRmRcbEZpc0ZfdEZkdEZkdEZqdkZqdkZqdkZqdi1GXm82Ki1GXHQ2JFEnMTQuMzI4RidGPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZeXWxGZG9GZ29GaW9GXHBGXnAtRltvNjJGZFxsRmlzRl90RmR0RmR0Rl52Rml1Rml1Rl52LUZebzYqLUZcdDYkUScyMS43MzRGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRl14RmRvRmdvRmlvRlxwRl5wLUZbbzYyRmp2RmlzRl90RmR0RmR0Rl90Rml0Rml0Rl90LUZebzYqLUZcdDYkUScxOC4wMDBGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZebzYqLUZcdDYkUSMxNUYnRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGZG9GZ29GaW9GXHBGXnAtRltvNjJGanZGaXNGX3RGZHRGZHRGaXVGXnZGXnZGaXUtRl5vNiotRlx0NiRRJzIzLjkwNkYnRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGX19sRmRvRmdvRmlvRlxwRl5wLUZbbzYyRmp2RmlzRl90RmR0RmR0Rmp2Rmp2Rmp2Rmp2LUZebzYqLUZcdDYkUSczNy4xNTdGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZebzYqLUZcdDYkUSMxNEYnRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGZG9GZ29GaW9GXHBGXnAtRltvNjJGanZGaXNGX3RGZHRGZHRGXnZGaXVGaXVGXnYtRl5vNiotRlx0NiRRJzY3LjY0MUYnRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGX19sRmRvRmdvRmlvRlxwRl5wLUZbbzYyLUZebzYqLUZcdDYkUSMzMkYnRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3AtRl5vNiotRlx0NiRRIjVGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRl90RmR0RmR0Rl90Rml0Rml0Rl90LUZebzYqLUZcdDYkUSczNC4yNTBGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZebzYqLUZcdDYkUSMyMkYnRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGZG9GZ29GaW9GXHBGXnAtRltvNjJGYGFsRmVhbEZfdEZkdEZkdEZpdUZedkZedkZpdS1GXm82Ki1GXHQ2JFEnMzkuMjAzRidGPEZkb0Znb0Zpb0ZccEZecEZgcEZjcC1GXm82Ki1GXHQ2JFEjMTlGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmRvRmdvRmlvRlxwRl5wLUZbbzYyRmBhbEZlYWxGX3RGZHRGZHRGanZGanZGanZGanYtRl5vNiotRlx0NiRRJzc5LjgxMkYnRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3AtRl5vNiotRlx0NiRRIzIxRidGPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZkb0Znb0Zpb0ZccEZecC1GW282MkZgYWxGZWFsRl90RmR0RmR0Rl52Rml1Rml1LUZebzYqLUYvNiVRJUZBSUxGJ0YyRjVGZG9GZ29GaW9GXHBGXnBGYHBGY3BGXmRsRmdjbEZkb0Znb0Zpb0ZccEZecC1GW282Mi1GXm82Ki1GXHQ2JFEjNjRGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmh6Rl90RmR0RmR0Rl90Rml0Rml0Rl5kbEZeZGxGZ2NsRmRvRmdvRmlvRlxwRl5wLUZbbzYyRmVkbEZoekZfdEZkdEZkdEZpdUZedkZedkZeZGxGXmRsRmdjbEZkb0Znb0Zpb0ZccEZecC1GW282MkZlZGxGaHpGX3RGZHRGZHRGanZGanZGanZGXmRsRl5kbEZnY2xGZG9GZ29GaW9GXHBGXnAtRltvNjJGZWRsRmh6Rl90RmR0RmR0Rl52Rml1Rml1Rl5kbEZeZGxGZ2NsRmRvRmdvRmlvRlxwRl5wLUZbbzYyLUZebzYqLUZcdDYkUSM3MkYnRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGZWFsRl90RmR0RmR0Rl90Rml0Rml0Rl5kbEZeZGxGZ2NsRmRvRmdvRmlvRlxwRl5wLUZbbzYyRmJlbEZlYWxGX3RGZHRGZHRGaXVGXnZGXnZGXmRsRl5kbEZnY2xGZG9GZ29GaW9GXHBGXnAtRltvNjJGYmVsRmVhbEZfdEZkdEZkdEZqdkZqdkZqdkZeZGxGXmRsRmdjbEZkb0Znb0Zpb0ZccEZecC1GW282MkZiZWxGZWFsRl90RmR0RmR0Rl52Rml1Rml1Rl5kbEZeZGxGZ2NsRmRvRmdvRmlvRlxwRl5wLUZbbzYyLUZebzYqLUZcdDYkUSIwRidGPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZfZmxGX2ZsRl9mbEZfZmxGX2ZsRl9mbEZfZmxGX2ZsRl9mbEZfZmxGZG9GZ29GaW9GXHBGXnAvJSZhbGlnbkdRJWF4aXNGJy9Gam9RJ2NlbnRlckYnL0ZdcEZoZmwvRl9wUSd8ZnJsZWZ0fGhyRicvJS9hbGlnbm1lbnRzY29wZUdGNC8lLGNvbHVtbndpZHRoR1ElYXV0b0YnLyUmd2lkdGhHRmBnbC8lK3Jvd3NwYWNpbmdHUSYxLjBleEYnLyUuY29sdW1uc3BhY2luZ0dRJjAuOGVtRicvJSlyb3dsaW5lc0dRJW5vbmVGJy8lLGNvbHVtbmxpbmVzR0ZbaGwvJSZmcmFtZUdGW2hsLyUtZnJhbWVzcGFjaW5nR1EsMC40ZW1+MC41ZXhGJy8lKmVxdWFscm93c0dGQC8lLWVxdWFsY29sdW1uc0dGQC8lLWRpc3BsYXlzdHlsZUdGQC8lJXNpZGVHUSZyaWdodEYnLyUwbWlubGFiZWxzcGFjaW5nR0ZoZ2wvJTFzaG93Y29sdW1uaGVhZGVyR0ZALyUuc2hvd3Jvd2hlYWRlckdGQC8lLmZyb3plbmRpc3BsYXlHRkAvJS5udW1iZXJjb2x1bW5zR1EjMTFGJy8lK251bWJlcnJvd3NHUSMzNEYnLyU2ZGVmYXVsdHZpc2libGVjb2x1bW5zR0ZmaWwvJTNkZWZhdWx0dmlzaWJsZXJvd3NHRmlpbC8lMWNvbHVtbmxvd2VyYm91bmRHRmJwLyUxY29sdW1udXBwZXJib3VuZEdGZmlsLyUucm93bG93ZXJib3VuZEdGYnAvJS5yb3d1cHBlcmJvdW5kR0ZpaWwvJS1kaXNwbGF5d2lkdGhHUSQ3MTJGJy8lLmRpc3BsYXloZWlnaHRHUSQ4NTBGJy8lMHVzZXJkZWZpbmVkc2l6ZUdGQC8lOmRpc3BsYXlob3Jpem9udGFscG9zaXRpb25HRmNmbC8lOGRpc3BsYXl2ZXJ0aWNhbHBvc2l0aW9uR0ZjZmwvJTRkaXNwbGF5Y29sdW1ud2lkdGhzR1FNWzMwLH40MCx+NDAsfjY3LH42Nyx+NjIsfjYxLH42Mix+ODYsfjQ1LH4zMl1GJy8lNWRpc3BsYXljb2x1bW5zcGFjaW5nR1FJWzExLH4xMSx+MTEsfjExLH4xMSx+MTEsfjExLH4xMSx+MTEsfjExXUYnLyU4dXNlcmRlZmluZWRjb2x1bW53aWR0aHNHUWhvW2ZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZV1GJy8lMmRpc3BsYXlyb3doZWlnaHRzR1Fjc1sxNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xN11GJy8lMmRpc3BsYXlyb3dzcGFjaW5nR1FecVs4LH44LH44LH44LH44LH44LH44LH44LH44LH44LH44LH44LH44LH44LH44LH44LH44LH44LH44LH44LH44LH44LH44LH44LH44LH44LH44LH44LH44LH44LH44LH44LH44XUYnLyU2dXNlcmRlZmluZWRyb3doZWlnaHRzR1FpeVtmYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZV1GJy8lKnRhYmxldHlwZUdGY2ZsLyUycm93aW5kZXhpbmdvZmZzZXRHRmNmbC8lNWNvbHVtbmluZGV4aW5nb2Zmc2V0R0ZjZmwvJTJhcnJheXNsaWNlaW5kaWNlc0dRI1tdRidGZG9GZ29GPEY8L0krbXNlbWFudGljc0dGJFEnTWF0cml4RicvJSVvcGVuR1EnJmxzcWI7RicvJSZjbG9zZUdRJyZyc3FiO0YnRl1dbUZkb0Znb0Y8RmRvRmdvRjxGPC1GWTYoLUYsNiYtSSdtdGFibGVHRiQ2WC1JJG10ckdGJDYyLUkkbXRkR0YkRl9vLUZhXm1GZnAtRmFebUZbcS1GYV5tRmBxLUZhXm1GZXEtRmFebUZqcS1GYV5tRl9yLUZhXm1GZHItRmFebUZpci1GYV5tRl5zLUZhXm1GY3NGZG9GZ29GaW9GXHBGXnAtRl5ebTYyLUZhXm02Ki1GXHQ2JkZedEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZhXm02Ki1GXHQ2JkZjdEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmJfbS1GYV5tNiotRlx0NiZGaHRGZG9GZ29GPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZmX21GYl9tLUZhXm02Ki1GXHQ2JkZddUZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmpfbUZiX20tRmFebTYqLUZcdDYmRmJ1RmRvRmdvRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3AtRmFebTYqLUZcdDYmRmJwRmRvRmdvRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGZG9GZ29GaW9GXHBGXnAtRl5ebTYyRl5fbUZiX21GYl9tRmZfbUZmX20tRmFebTYqLUZcdDYmRl12RmRvRmdvRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3AtRmFebTYqLUZcdDYmRmJ2RmRvRmdvRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGXGFtRmhgbS1GYV5tNiotRlx0NiZGZ3ZGZG9GZ29GPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZiYG1GZG9GZ29GaW9GXHBGXnAtRl5ebTYyRl5fbUZiX21GYl9tRmZfbUZmX20tRmFebTYqLUZcdDYmRl53RmRvRmdvRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGZmFtRmZhbUZmYW0tRmFebTYqLUZcdDYmRmN3RmRvRmdvRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGYmBtRmRvRmdvRmlvRlxwRl5wLUZeXm02MkZeX21GYl9tRmJfbUZmX21GZl9tRlxhbUZoYG1GaGBtRlxhbS1GYV5tNiotRlx0NiZGandGZG9GZ29GPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZiYG1GZG9GZ29GaW9GXHBGXnAtRl5ebTYyLUZhXm02Ki1GXHQ2JkZheEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZhXm02Ki1GXHQ2JkZmeEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmJfbUZmX21GZl9tRmJfbUZqX21Gal9tRmJfbS1GYV5tNiotRlx0NiZGW3lGZG9GZ29GPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZeX21GZG9GZ29GaW9GXHBGXnAtRl5ebTYyRmZibUZqYm1GYl9tRmZfbUZmX21GaGBtRlxhbUZcYW1GaGBtLUZhXm02Ki1GXHQ2JkZieUZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRl5fbUZkb0Znb0Zpb0ZccEZecC1GXl5tNjJGZmJtRmpibUZiX21GZl9tRmZfbUZmYW1GZmFtRmZhbUZmYW0tRmFebTYqLUZcdDYmRml5RmRvRmdvRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGXl9tRmRvRmdvRmlvRlxwRl5wLUZeXm02MkZmYm1GamJtRmJfbUZmX21GZl9tRlxhbUZoYG1GaGBtRlxhbS1GYV5tNiotRlx0NiZGYHpGZG9GZ29GPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZeX21GZG9GZ29GaW9GXHBGXnAtRl5ebTYyRmhgbUZqYm1GYl9tRmZfbUZmX21GYl9tRmpfbUZqX21GYl9tLUZhXm02Ki1GXHQ2JkZnekZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZhXm02Ki1GXHQ2JkZcW2xGZG9GZ29GPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZkb0Znb0Zpb0ZccEZecC1GXl5tNjJGaGBtRmpibUZiX21GZl9tRmZfbUZoYG1GXGFtRlxhbUZoYG0tRmFebTYqLUZcdDYmRmNbbEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmpkbUZkb0Znb0Zpb0ZccEZecC1GXl5tNjJGaGBtRmpibUZiX21GZl9tRmZfbUZmYW1GZmFtRmZhbUZmYW0tRmFebTYqLUZcdDYmRmpbbEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmpkbUZkb0Znb0Zpb0ZccEZecC1GXl5tNjJGaGBtRmpibUZiX21GZl9tRmZfbUZcYW1GaGBtRmhgbUZcYW0tRmFebTYqLUZcdDYmRmFcbEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmpkbUZkb0Znb0Zpb0ZccEZecC1GXl5tNjItRmFebTYqLUZcdDYmRmhcbEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRl5fbUZiX21GZl9tRmZfbUZiX21Gal9tRmpfbUZiX20tRmFebTYqLUZcdDYmRl1dbEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZhXm02Ki1GXHQ2JkZiXWxGZG9GZ29GPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZkb0Znb0Zpb0ZccEZecC1GXl5tNjJGYmZtRl5fbUZiX21GZl9tRmZfbUZoYG1GXGFtRlxhbUZoYG0tRmFebTYqLUZcdDYmRmldbEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmZibUZkb0Znb0Zpb0ZccEZecC1GXl5tNjJGYmZtRl5fbUZiX21GZl9tRmZfbUZmYW1GZmFtRmZhbUZmYW0tRmFebTYqLUZcdDYmRmBebEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmpmbUZkb0Znb0Zpb0ZccEZecC1GXl5tNjJGYmZtRl5fbUZiX21GZl9tRmZfbUZcYW1GaGBtRmhgbUZcYW0tRmFebTYqLUZcdDYmRmdebEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmZibUZkb0Znb0Zpb0ZccEZecC1GXl5tNjJGZmFtRl5fbUZiX21GZl9tRmZfbUZiX21Gal9tRmpfbUZiX20tRmFebTYqLUZcdDYmRl5fbEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZhXm02Ki1GXHQ2JkZjX2xGZG9GZ29GPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZkb0Znb0Zpb0ZccEZecC1GXl5tNjJGZmFtRl5fbUZiX21GZl9tRmZfbUZoYG1GXGFtRlxhbUZoYG0tRmFebTYqLUZcdDYmRmpfbEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmZobUZkb0Znb0Zpb0ZccEZecC1GXl5tNjJGZmFtRl5fbUZiX21GZl9tRmZfbUZmYW1GZmFtRmZhbUZmYW0tRmFebTYqLUZcdDYmRmFgbEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZhXm02Ki1GXHQ2JkZmYGxGZG9GZ29GPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZkb0Znb0Zpb0ZccEZecC1GXl5tNjJGZmFtRl5fbUZiX21GZl9tRmZfbUZcYW1GaGBtRmhgbUZcYW0tRmFebTYqLUZcdDYmRl1hbEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmZobUZkb0Znb0Zpb0ZccEZecC1GXl5tNjItRmFebTYqLUZcdDYmRmRhbEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZhXm02Ki1GXHQ2JkZpYWxGZG9GZ29GPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZiX21GZl9tRmZfbUZiX21Gal9tRmpfbUZiX20tRmFebTYqLUZcdDYmRl5ibEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZhXm02Ki1GXHQ2JkZjYmxGZG9GZ29GPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZkb0Znb0Zpb0ZccEZecC1GXl5tNjJGYmptRmZqbUZiX21GZl9tRmZfbUZoYG1GXGFtRlxhbUZoYG0tRmFebTYqLUZcdDYmRmpibEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZhXm02Ki1GXHQ2JkZfY2xGZG9GZ29GPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZkb0Znb0Zpb0ZccEZecC1GXl5tNjJGYmptRmZqbUZiX21GZl9tRmZfbUZmYW1GZmFtRmZhbUZmYW0tRmFebTYqLUZcdDYmRmZjbEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZhXm02Ki1GXHQ2JkZbZGxGZG9GZ29GPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZkb0Znb0Zpb0ZccEZecC1GXl5tNjJGYmptRmZqbUZiX21GZl9tRmZfbUZcYW1GaGBtRmhgbS1GYV5tNiotRi82J0ZiZGxGMkZkb0Znb0Y1RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmhcbkZiXG5GZG9GZ29GaW9GXHBGXnAtRl5ebTYyLUZhXm02Ki1GXHQ2JkZpZGxGZG9GZ29GPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZqZG1GYl9tRmZfbUZmX21GYl9tRmpfbUZqX21GaFxuRmhcbkZiXG5GZG9GZ29GaW9GXHBGXnAtRl5ebTYyRl5dbkZqZG1GYl9tRmZfbUZmX21GaGBtRlxhbUZcYW1GaFxuRmhcbkZiXG5GZG9GZ29GaW9GXHBGXnAtRl5ebTYyRl5dbkZqZG1GYl9tRmZfbUZmX21GZmFtRmZhbUZmYW1GaFxuRmhcbkZiXG5GZG9GZ29GaW9GXHBGXnAtRl5ebTYyRl5dbkZqZG1GYl9tRmZfbUZmX21GXGFtRmhgbUZoYG1GaFxuRmhcbkZiXG5GZG9GZ29GaW9GXHBGXnAtRl5ebTYyLUZhXm02Ki1GXHQ2JkZmZWxGZG9GZ29GPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZmam1GYl9tRmZfbUZmX21GYl9tRmpfbUZqX21GaFxuRmhcbkZiXG5GZG9GZ29GaW9GXHBGXnAtRl5ebTYyRmpdbkZmam1GYl9tRmZfbUZmX21GaGBtRlxhbUZcYW1GaFxuRmhcbkZiXG5GZG9GZ29GaW9GXHBGXnAtRl5ebTYyRmpdbkZmam1GYl9tRmZfbUZmX21GZmFtRmZhbUZmYW1GaFxuRmhcbkZiXG5GZG9GZ29GaW9GXHBGXnAtRl5ebTYyRmpdbkZmam1GYl9tRmZfbUZmX21GXGFtRmhgbUZoYG1GaFxuRmhcbkZiXG5GZG9GZ29GaW9GXHBGXnAtRl5ebTYyLUZhXm02Ki1GXHQ2JkZjZmxGZG9GZ29GPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZmXm5GZl5uRmZebkZmXm5GZl5uRmZebkZmXm5GZl5uRmZebkZmXm5GZG9GZ29GaW9GXHBGXnBGZG9GZ29GZGZsL0Zqb1EpYmFzZWxpbmVGJ0ZpZmxGamZsRlxnbEZeZ2xGYWdsRmNnbEZmZ2xGaWdsRlxobEZeaGxGYGhsRmNobEZlaGxGZ2hsRmlobEZcaWxGZG9GZ29GPEZkb0Znb0Y8L0ZhXW1RIltGJy9GZF1tUSJdRic=">LV9JLFR5cGVzZXR0aW5nRzYkJSpwcm90ZWN0ZWRHSShfc3lzbGliRzYiSSxtcHJpbnRzbGFzaEdGKDYkNyM+SSJSR0YoS0knUlRBQkxFR0YoNiUiNW9JO1JmOCFcJCpvJC1JJ01BVFJJWEdGKDYjN0Q3LS1JI21zRzYkRiYvSSttb2R1bGVuYW1lR0YoRiQ2I1EjZEZGKC1GODYjUSUjZXh0RigtRjg2I1ElI3ZhckYoLUY4NiNRKVRkZWcoZjEpRigtRjg2I1EpVGRlZyhmMilGKC1GODYjUShUZGVnKGcpRigtRjg2I1EoVGRlZyhhKUYoLUY4NiNRKFRkZWcoYilGKC1GODYjUSpUZGVnKEdDRClGKC1GODYjUSVUaW1lRigtRjg2I1EjTnBGKDctLUkjbW5HRjk2I1EiNEYoLUZobjYjUSIyRihGW28tRmhuNiNRIzQ4RihGXm9GW28tRmhuNiNRIzQ2RihGYW9GW28tRmhuNiNRJjAuMjY1RigtRmhuNiNRIjFGKDctRmduRltvRltvRl5vRl5vLUZobjYjUSMxMkYoLUZobjYjUSMzNkYoRl5wRltwLUZobjYjUSYwLjM0NEYoRmdvNy1GZ25GW29GW29GXm9GXm8tRmhuNiNRIzI0RihGZXBGZXBGZXAtRmhuNiNRJjAuNjQxRihGZ283LUZnbkZbb0Zbb0Zeb0Zeb0ZecEZbcEZbcEZecC1GaG42I1EmMi4xMjVGKEZnbzctLUZobjYjUSI4RigtRmhuNiNRIjNGKEZbb0Zeb0Zeb0Zbb0Zhb0Zhb0Zbby1GaG42I1EmMS4zMjhGKEZnbjctRmBxRmNxRltvRl5vRl5vRltwRl5wRl5wRltwLUZobjYjUSYyLjg2MEYoRmduNy1GYHFGY3FGW29GXm9GXm9GZXBGZXBGZXBGZXAtRmhuNiNRJjMuNDUzRihGZ243LUZgcUZjcUZbb0Zeb0Zeb0ZecEZbcEZbcEZecC1GaG42I1EmNS41NzhGKEZnbjctRltwRmNxRltvRl5vRl5vRltvRmFvRmFvRltvLUZobjYjUSYzLjU5NEYoLUZobjYjUSI2Rig3LUZbcEZjcUZbb0Zeb0Zeb0ZbcEZecEZecEZbcC1GaG42I1EmNC40MzdGKEZpcjctRltwRmNxRltvRl5vRl5vRmVwRmVwRmVwRmVwLUZobjYjUSY3LjgxM0YoRmlyNy1GW3BGY3FGW29GXm9GXm9GXnBGW3BGW3BGXnAtRmhuNiNRJzEyLjI4MkYoRmlyNy0tRmhuNiNRIzE2RihGZ25GW29GXm9GXm9GW29GYW9GYW9GW28tRmhuNiNRJjYuMjUwRigtRmhuNiNRIjlGKDctRmlzRmduRltvRl5vRl5vRltwRl5wRl5wRltwLUZobjYjUSY4LjI4MUYoRmBxNy1GaXNGZ25GW29GXm9GXm9GZXBGZXBGZXBGZXAtRmhuNiNRJzE0LjMyOEYoRl90Ny1GaXNGZ25GW29GXm9GXm9GXnBGW3BGW3BGXnAtRmhuNiNRJzIxLjczNEYoRmBxNy1GZXBGZ25GW29GXm9GXm9GW29GYW9GYW9GW28tRmhuNiNRJzE4LjAwMEYoLUZobjYjUSMxNUYoNy1GZXBGZ25GW29GXm9GXm9GW3BGXnBGXnBGW3AtRmhuNiNRJzIzLjkwNkYoRmJ1Ny1GZXBGZ25GW29GXm9GXm9GZXBGZXBGZXBGZXAtRmhuNiNRJzM3LjE1N0YoLUZobjYjUSMxNEYoNy1GZXBGZ25GW29GXm9GXm9GXnBGW3BGW3BGXnAtRmhuNiNRJzY3LjY0MUYoRmJ1Ny0tRmhuNiNRIzMyRigtRmhuNiNRIjVGKEZbb0Zeb0Zeb0Zbb0Zhb0Zhb0Zbby1GaG42I1EnMzQuMjUwRigtRmhuNiNRIzIyRig3LUZldkZodkZbb0Zeb0Zeb0ZbcEZecEZecEZbcC1GaG42I1EnMzkuMjAzRigtRmhuNiNRIzE5Rig3LUZldkZodkZbb0Zeb0Zeb0ZlcEZlcEZlcEZlcC1GaG42I1EnNzkuODEyRigtRmhuNiNRIzIxRig3LUZldkZodkZbb0Zeb0Zeb0ZecEZbcEZbcC1JI21pR0Y5NiNRJUZBSUxGKEZgeEZceDctLUZobjYjUSM2NEYoRmlyRltvRl5vRl5vRltvRmFvRmFvRmB4RmB4Rlx4Ny1GZXhGaXJGW29GXm9GXm9GW3BGXnBGXnBGYHhGYHhGXHg3LUZleEZpckZbb0Zeb0Zeb0ZlcEZlcEZlcEZgeEZgeEZceDctRmV4RmlyRltvRl5vRl5vRl5wRltwRltwRmB4RmB4Rlx4Ny0tRmhuNiNRIzcyRihGaHZGW29GXm9GXm9GW29GYW9GYW9GYHhGYHhGXHg3LUZceUZodkZbb0Zeb0Zeb0ZbcEZecEZecEZgeEZgeEZceDctRlx5Rmh2RltvRl5vRl5vRmVwRmVwRmVwRmB4RmB4Rlx4Ny1GXHlGaHZGW29GXm9GXm9GXnBGW3BGW3BGYHhGYHhGXHg3LS1GaG42I1EiMEYoRmN5RmN5RmN5RmN5RmN5RmN5RmN5RmN5RmN5RmN5SSdNYXRyaXhHRiVGKDcjLUZmeTYjL0kkJWlkR0YoRjE=</Equation></Text-field>
</Output>
</Group>
<Group hide-input="false" labelreference="L706" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font opaque="true" size="16" background="[255,255,153]" foreground="[0,0,255]">#4 </Font><Font opaque="true" background="[255,255,153]" foreground="[0,0,128]">Number of extensions for a field of degree 64 is changing from 1..6 
</Font>R:=<Font foreground="[128,0,0]">Benchmain(flagalg,2</Font>,24,12,32,[seq(1..5)],0);
Export(R,&quot;MGCD.xls&quot;,&quot;#exts&quot;);</Text-field>
</Input>
<Output><Text-field style="Line Printed Output" layout="Line Printed Output">MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |   35 4231.060 54491310591|
   1 |   35   0.000      0| timings := true;
   2 |   35   0.000    140| tt := time();
   3 |   35   0.000      0| pt := 0;
   4 |   35   0.000      0| lmt := 0;
   5 |   35   0.000      0| laminpolytime := 0;
   6 |   35   0.000      0| phigammatime := 0;
   7 |   35   0.000      0| pgcdtime := 0;
   8 |   35   0.000      0| CRTRNRtime := 0;
   9 |   35   0.000      0| divtime := 0;
  10 |   35   0.546   2555| A1, B1, ring := ConvRing(A0,B0);
  11 |   35   4.890 43086976| A := semi(A1);
  12 |   35   5.501 43087775| B := semi(B1);
  13 |   35   0.000    140| Char, X, E := op(ring);
  14 |   35   0.000      0| n := nops(X);
  15 |   35   0.000      0| m := nops(E);
  16 |   35   0.000      0| k := n-m;
  17 |   35   0.000    280| Xpoly := X[1 .. k];
  18 |   35   0.000    665| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |   35   0.000  19725| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |   35   0.000  79030| minpolys := map(convert,MP,POLYNOMIAL);
  21 |   35   0.000      0| H := [];
  22 |   35   0.000      0| Np := [];
  23 |   35   0.000      0| p := 2147483648;
  24 |   35   0.000      0| do
  25 | 1188   9.482 5322710|     do
  26 | 1188   0.079 496129|         p := nextprime(p);
  27 | 1188   0.000      0|         lcmintest := true;
  28 | 1188   0.000      0|         for i to m do
  29 | 3664   0.031  63478|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 | 1188   0.016   4752|     st := time();
  32 | 1188 216.928 1937662120|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 | 1186   0.016  18968|     pt := pt+time()-st;
  34 | 1186   0.141 2918149|     Rand := rand(1 .. p-1);
  35 | 1186   0.000   3558|     if m &lt;= 1 then
  36 |  425   0.000      0|         PhiAp := Ap;
  37 |  425   0.000      0|         PhiBp := Bp
                                else
  38 |  761   0.016  35302|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |  761   0.000  58200|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |  761   7.463 4817967|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |  761   0.016   3044|         st := time();
  42 |  761  37.932 474985134|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |  761   0.000  12176|         laminpolytime := laminpolytime+time()-st;
  44 |  761   0.000   2283|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |  761   0.000   3044|         M, phimatrix, invphimatrix := LA;
  47 |  761   0.000   3044|         st := time();
  48 |  761 879.560 16466402501|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |  757 889.487 16343936609|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |  749   0.015  11984|         phigammatime := phigammatime+time()-st
                                end if;
  51 | 1174   0.000   4696|     st := time();
  52 | 1174 1194.140 10948057704|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 | 1164   0.000  18624|     pgcdtime := pgcdtime+time()-st;
  54 | 1164   0.000   6988|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 | 1164   0.705 224212|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 | 1164   0.000   3492|     if 1 &lt; m then
  62 |  742   0.000   2968|         st := time();
  63 |  742 203.129 3003034798|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |  742   0.000  11872|         phigammatime := phigammatime+time()-st
                                end if;
  65 | 1164   0.000   4656|     st := time();
  66 | 1164   1.612 118810|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 | 1164  42.152 402386051|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 | 1164   0.000  18116|     lmt := lmt+time()-st;
  69 | 1164   0.000      0|     if not assigned(minmon) then
  70 |   35   0.000      0|         CRT := Cp;
  71 |   35   0.000      0|         minmon := lmCp;
  72 |   35   0.000      0|         summon := minmon;
  73 |   35   0.000      0|         least := minmon;
  74 |   35   0.000    140|         H := [Cp]
                                else
  75 | 1129   0.000  29537|         summon := lmCp+minmon;
  76 | 1129   0.265 3546920|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 | 1129   2.973 20310608|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 | 1129   0.000  13548|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 | 1129   0.000  41341|             H := [op(H), Cp];
  84 | 1129   0.000  40212|             Np := [op(Np), p];
  85 | 1129   0.000   4516|             st := time();
  86 | 1129 731.451 4757562878|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 | 1119   0.000  17528|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 | 1154   0.000   4616|     st := time();
  89 | 1154   2.468 31719423|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 | 1154   0.015  18088|     CRTRNRtime := CRTRNRtime+time()-st;
  91 | 1154   0.000   3462|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2442|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.016 1060196|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.015   3338|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    4 400.031 5001811056|
   1 |    4   0.000      0| timings := true;
   2 |    4   0.000     16| tt := time();
   3 |    4   0.000      0| pt := 0;
   4 |    4   0.000      0| lmt := 0;
   5 |    4   0.000      0| laminpolytime := 0;
   6 |    4   0.000      0| phigammatime := 0;
   7 |    4   0.000      0| pgcdtime := 0;
   8 |    4   0.000      0| CRTRNRtime := 0;
   9 |    4   0.000      0| divtime := 0;
  10 |    4   0.015    292| A1, B1, ring := ConvRing(A0,B0);
  11 |    4   0.142 1618811| A := semi(A1);
  12 |    4   0.156 1618831| B := semi(B1);
  13 |    4   0.000     16| Char, X, E := op(ring);
  14 |    4   0.000      0| n := nops(X);
  15 |    4   0.000      0| m := nops(E);
  16 |    4   0.000      0| k := n-m;
  17 |    4   0.000     32| Xpoly := X[1 .. k];
  18 |    4   0.000     54| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    4   0.016    719| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    4   0.000   5268| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    4   0.000      0| H := [];
  22 |    4   0.000      0| Np := [];
  23 |    4   0.000      0| p := 2147483648;
  24 |    4   0.016      0| do
  25 |  255   0.682 456868|     do
  26 |  255   0.000 112149|         p := nextprime(p);
  27 |  255   0.000      0|         lcmintest := true;
  28 |  255   0.000      0|         for i to m do
  29 |  313   0.015   5757|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |  255   0.000   1020|     st := time();
  32 |  255   4.062 49644485|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |  255   0.000   4072|     pt := pt+time()-st;
  34 |  255   0.015 627221|     Rand := rand(1 .. p-1);
  35 |  255   0.000    765|     if m &lt;= 1 then
  36 |  197   0.000      0|         PhiAp := Ap;
  37 |  197   0.000      0|         PhiBp := Bp
                                else
  38 |   58   0.000   1311|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   58   0.000   1740|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   58   0.186 110374|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   58   0.000    232|         st := time();
  42 |   58   0.187 5897851|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   58   0.000    928|         laminpolytime := laminpolytime+time()-st;
  44 |   58   0.000    174|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   58   0.000    232|         M, phimatrix, invphimatrix := LA;
  47 |   58   0.000    232|         st := time();
  48 |   58  15.628 383997340|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   58  15.371 383946551|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   58   0.000    928|         phigammatime := phigammatime+time()-st
                                end if;
  51 |  255   0.000   1020|     st := time();
  52 |  255 144.150 1771292630|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |  255   0.000   4080|     pgcdtime := pgcdtime+time()-st;
  54 |  255   0.000   1530|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |  255   0.126  59564|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |  255   0.000    765|     if 1 &lt; m then
  62 |   58   0.000    232|         st := time();
  63 |   58   0.232 3136057|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   58   0.000    928|         phigammatime := phigammatime+time()-st
                                end if;
  65 |  255   0.000   1020|     st := time();
  66 |  255   0.094  25558|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |  255   3.481 43428555|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |  255   0.000   3936|     lmt := lmt+time()-st;
  69 |  255   0.000      0|     if not assigned(minmon) then
  70 |    4   0.000      0|         CRT := Cp;
  71 |    4   0.000      0|         minmon := lmCp;
  72 |    4   0.000      0|         summon := minmon;
  73 |    4   0.000      0|         least := minmon;
  74 |    4   0.000     16|         H := [Cp]
                                else
  75 |  251   0.000   9791|         summon := lmCp+minmon;
  76 |  251   0.077 752445|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |  251   0.249 4247096|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |  251   0.000   3012|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |  251   0.000  10804|             H := [op(H), Cp];
  84 |  251   0.000  10553|             Np := [op(Np), p];
  85 |  251   0.000   1004|             st := time();
  86 |  251 214.537 2342391761|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |  248   0.000   3900|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |  252   0.000   1008|     st := time();
  89 |  252   0.563 7359580|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |  252   0.000   3964|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |  252   0.000    756|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2455|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.031 979964|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000  22430|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  81.156 1385738406|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.015     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.032 438916| A := semi(A1);
  12 |    1   0.047 438916| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     18| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    284| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   1149| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   60   0.157 120060|     do
  26 |   60   0.000  27158|         p := nextprime(p);
  27 |   60   0.000      0|         lcmintest := true;
  28 |   60   0.000      0|         for i to m do
  29 |  120   0.000   2106|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   60   0.000    240|     st := time();
  32 |   60   1.348 18766560|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   60   0.000    960|     pt := pt+time()-st;
  34 |   60   0.031 147600|     Rand := rand(1 .. p-1);
  35 |   60   0.000    180|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   60   0.000   1280|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   60   0.000   1800|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   60   0.155 114180|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   60   0.000    240|         st := time();
  42 |   60   0.357 6101225|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   60   0.000    960|         laminpolytime := laminpolytime+time()-st;
  44 |   60   0.000    180|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   60   0.000    240|         M, phimatrix, invphimatrix := LA;
  47 |   60   0.000    240|         st := time();
  48 |   60  15.503 397590907|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   60  18.406 397579761|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   60   0.000    960|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   60   0.000    240|     st := time();
  52 |   60  17.983 215125066|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   60   0.000    960|     pgcdtime := pgcdtime+time()-st;
  54 |   60   0.000    360|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   60   0.016  12000|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   60   0.000    180|     if 1 &lt; m then
  62 |   60   0.000    240|         st := time();
  63 |   60   1.564 29269939|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   60   0.000    960|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   60   0.000    240|     st := time();
  66 |   60   0.000   6060|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   60   0.358 5001313|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   60   0.000    952|     lmt := lmt+time()-st;
  69 |   60   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   59   0.000   2891|         summon := lmCp+minmon;
  76 |   59   0.032 171778|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   59   0.016 217710|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   59   0.000    708|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   59   0.000   2180|             H := [op(H), Cp];
  84 |   59   0.000   2121|             Np := [op(Np), p];
  85 |   59   0.000    236|             st := time();
  86 |   59  24.121 264054766|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   59   0.000    932|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   60   0.000    240|     st := time();
  89 |   60   0.984 49212322|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   60   0.000    948|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   60   0.000    180|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2459|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     30|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.031 1236019|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000  77810|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    3 272.906 3978991163|
   1 |    3   0.000      0| timings := true;
   2 |    3   0.000     12| tt := time();
   3 |    3   0.000      0| pt := 0;
   4 |    3   0.000      0| lmt := 0;
   5 |    3   0.000      0| laminpolytime := 0;
   6 |    3   0.000      0| phigammatime := 0;
   7 |    3   0.000      0| pgcdtime := 0;
   8 |    3   0.000      0| CRTRNRtime := 0;
   9 |    3   0.000      0| divtime := 0;
  10 |    3   0.016    219| A1, B1, ring := ConvRing(A0,B0);
  11 |    3   0.125 1387990| A := semi(A1);
  12 |    3   0.140 1388013| B := semi(B1);
  13 |    3   0.000     12| Char, X, E := op(ring);
  14 |    3   0.000      0| n := nops(X);
  15 |    3   0.000      0| m := nops(E);
  16 |    3   0.000      0| k := n-m;
  17 |    3   0.000     24| Xpoly := X[1 .. k];
  18 |    3   0.000     55| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    3   0.000    996| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    3   0.000   3608| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    3   0.000      0| H := [];
  22 |    3   0.000      0| Np := [];
  23 |    3   0.000      0| p := 2147483648;
  24 |    3   0.000      0| do
  25 |  117   0.236 249021|     do
  26 |  117   0.000  51510|         p := nextprime(p);
  27 |  117   0.000      0|         lcmintest := true;
  28 |  117   0.000      0|         for i to m do
  29 |  270   0.000   4808|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |  117   0.000    468|     st := time();
  32 |  117   4.537 47598612|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |  117   0.000   1872|     pt := pt+time()-st;
  34 |  117   0.000 287972|     Rand := rand(1 .. p-1);
  35 |  117   0.000    351|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |  117   0.000   2955|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |  117   0.000   4482|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |  117   0.314 272331|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |  117   0.000    468|         st := time();
  42 |  117   0.734 13023006|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |  117   0.000   1808|         laminpolytime := laminpolytime+time()-st;
  44 |  117   0.000    351|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |  117   0.000    468|         M, phimatrix, invphimatrix := LA;
  47 |  117   0.000    468|         st := time();
  48 |  117  32.808 791141823|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |  117  33.266 791063888|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |  117   0.015   1872|         phigammatime := phigammatime+time()-st
                                end if;
  51 |  117   0.000    468|     st := time();
  52 |  117  88.820 1166981940|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |  116   0.000   1856|     pgcdtime := pgcdtime+time()-st;
  54 |  116   0.000    696|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |  116   0.016  31456|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |  116   0.000    348|     if 1 &lt; m then
  62 |  116   0.000    464|         st := time();
  63 |  116   9.863 194264111|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |  116   0.000   1856|         phigammatime := phigammatime+time()-st
                                end if;
  65 |  116   0.000    464|     st := time();
  66 |  116   0.047  11752|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |  116   2.802 33620212|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |  116   0.015   1808|     lmt := lmt+time()-st;
  69 |  116   0.000      0|     if not assigned(minmon) then
  70 |    3   0.000      0|         CRT := Cp;
  71 |    3   0.000      0|         minmon := lmCp;
  72 |    3   0.000      0|         summon := minmon;
  73 |    3   0.000      0|         least := minmon;
  74 |    3   0.000     12|         H := [Cp]
                                else
  75 |  113   0.000   3997|         summon := lmCp+minmon;
  76 |  113   0.000 424497|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |  113   0.203 1086557|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |  113   0.000   1356|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |  113   0.000   3036|             H := [op(H), Cp];
  84 |  113   0.000   2923|             Np := [op(Np), p];
  85 |  113   0.000    452|             st := time();
  86 |  113  98.403 932901050|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |  112   0.000   1732|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |  115   0.000    460|     st := time();
  89 |  115   0.515 2090353|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |  115   0.000   1780|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |  115   0.000    345|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2456|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.031 1019424|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000  43466|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  45.829 794351527|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.047 510154| A := semi(A1);
  12 |    1   0.047 510154| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     19| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    428| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   1310| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   36   0.157  86940|     do
  26 |   36   0.000  15893|         p := nextprime(p);
  27 |   36   0.000      0|         lcmintest := true;
  28 |   36   0.000      0|         for i to m do
  29 |  108   0.000   1839|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   36   0.000    144|     st := time();
  32 |   36   1.436 22262904|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   36   0.000    576|     pt := pt+time()-st;
  34 |   36   0.016  88531|     Rand := rand(1 .. p-1);
  35 |   36   0.000    108|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   36   0.000   1208|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   36   0.000   2052|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   36   0.126 118188|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   36   0.000    144|         st := time();
  42 |   36   0.316 4786349|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   36   0.000    568|         laminpolytime := laminpolytime+time()-st;
  44 |   36   0.000    108|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   36   0.000    144|         M, phimatrix, invphimatrix := LA;
  47 |   36   0.000    144|         st := time();
  48 |   36   9.717 254822950|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   36  10.293 255118442|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   36   0.000    576|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   36   0.000    144|     st := time();
  52 |   36  11.767 128895536|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   36   0.000    576|     pgcdtime := pgcdtime+time()-st;
  54 |   36   0.000    216|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   36   0.000   7200|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   36   0.000    108|     if 1 &lt; m then
  62 |   36   0.000    144|         st := time();
  63 |   36   0.784 21259472|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   36   0.000    576|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   36   0.000    144|     st := time();
  66 |   36   0.000   3672|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   36   0.294 3558901|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   36   0.000    576|     lmt := lmt+time()-st;
  69 |   36   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   35   0.000   1715|         summon := lmCp+minmon;
  76 |   35   0.000 113367|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   35   0.000 164220|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   35   0.000    420|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   35   0.016    872|             H := [op(H), Cp];
  84 |   35   0.000    837|             Np := [op(Np), p];
  85 |   35   0.000    140|             st := time();
  86 |   35  10.516 80001787|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   35   0.000    548|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   36   0.000    144|     st := time();
  89 |   36   0.250 20687993|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   36   0.000    564|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   36   0.000    108|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2435|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.031 1177817|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.016 140956|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  80.719 1221397517|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.047 510154| A := semi(A1);
  12 |    1   0.047 510154| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     19| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    428| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   1310| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   34   0.123  82110|     do
  26 |   34   0.000  14591|         p := nextprime(p);
  27 |   34   0.000      0|         lcmintest := true;
  28 |   34   0.000      0|         for i to m do
  29 |  102   0.000   1793|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   34   0.000    136|     st := time();
  32 |   34   1.860 21026495|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   34   0.000    544|     pt := pt+time()-st;
  34 |   34   0.000  83619|     Rand := rand(1 .. p-1);
  35 |   34   0.000    102|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   34   0.000   1092|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   34   0.000   1938|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   34   0.125 111622|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   34   0.000    136|         st := time();
  42 |   34   0.170 4520441|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   34   0.000    536|         laminpolytime := laminpolytime+time()-st;
  44 |   34   0.000    102|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   34   0.000    136|         M, phimatrix, invphimatrix := LA;
  47 |   34   0.000    136|         st := time();
  48 |   34  11.058 240672682|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   34   9.503 240720110|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   34   0.000    544|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   34   0.000    136|     st := time();
  52 |   34  23.891 321980556|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   34   0.000    544|     pgcdtime := pgcdtime+time()-st;
  54 |   34   0.000    204|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   34   0.000  10268|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   34   0.000    102|     if 1 &lt; m then
  62 |   34   0.000    136|         st := time();
  63 |   34   3.671 67784695|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   34   0.000    544|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   34   0.000    136|     st := time();
  66 |   34   0.031   3468|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   34   0.752 11571497|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   34   0.000    544|     lmt := lmt+time()-st;
  69 |   34   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   33   0.000   1617|         summon := lmCp+minmon;
  76 |   33   0.000 143465|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   33   0.062 413028|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   33   0.000    396|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   33   0.000    789|             H := [op(H), Cp];
  84 |   33   0.000    756|             Np := [op(Np), p];
  85 |   33   0.000    132|             st := time();
  86 |   33  26.941 242817035|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   33   0.000    524|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   34   0.000    136|     st := time();
  89 |   34   2.360 66528654|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   34   0.000    540|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   34   0.000    102|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2435|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     50|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.062 1689760|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.016 183892|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    2 147.266 2104891652|
   1 |    2   0.000      0| timings := true;
   2 |    2   0.000      8| tt := time();
   3 |    2   0.000      0| pt := 0;
   4 |    2   0.000      0| lmt := 0;
   5 |    2   0.000      0| laminpolytime := 0;
   6 |    2   0.000      0| phigammatime := 0;
   7 |    2   0.000      0| pgcdtime := 0;
   8 |    2   0.000      0| CRTRNRtime := 0;
   9 |    2   0.000      0| divtime := 0;
  10 |    2   0.015    146| A1, B1, ring := ConvRing(A0,B0);
  11 |    2   0.079 1142808| A := semi(A1);
  12 |    2   0.141 1142808| B := semi(B1);
  13 |    2   0.000      8| Char, X, E := op(ring);
  14 |    2   0.000      0| n := nops(X);
  15 |    2   0.000      0| m := nops(E);
  16 |    2   0.000      0| k := n-m;
  17 |    2   0.000     16| Xpoly := X[1 .. k];
  18 |    2   0.000     39| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    2   0.000   1005| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    2   0.000   3022| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    2   0.000      0| H := [];
  22 |    2   0.000      0| Np := [];
  23 |    2   0.000      0| p := 2147483648;
  24 |    2   0.000      0| do
  25 |   56   0.154 154865|     do
  26 |   56   0.000  25564|         p := nextprime(p);
  27 |   56   0.000      0|         lcmintest := true;
  28 |   56   0.000      0|         for i to m do
  29 |  193   0.016   3325|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   56   0.000    224|     st := time();
  32 |   56   5.032 49904762|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   56   0.000    896|     pt := pt+time()-st;
  34 |   56   0.000 137744|     Rand := rand(1 .. p-1);
  35 |   56   0.000    168|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   56   0.000   2083|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   56   0.000   3617|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   56   0.219 231073|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   56   0.000    224|         st := time();
  42 |   56   0.425 8462009|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   56   0.000    792|         laminpolytime := laminpolytime+time()-st;
  44 |   56   0.000    168|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   56   0.000    224|         M, phimatrix, invphimatrix := LA;
  47 |   56   0.000    224|         st := time();
  48 |   56  16.656 409050811|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   56  16.656 408808022|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   56   0.000    896|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   56   0.000    224|     st := time();
  52 |   56  54.310 676849883|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   56   0.000    896|     pgcdtime := pgcdtime+time()-st;
  54 |   56   0.000    336|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   56   0.031  15324|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   56   0.000    168|     if 1 &lt; m then
  62 |   56   0.000    224|         st := time();
  63 |   56   5.954 134834213|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   56   0.000    896|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   56   0.000    224|     st := time();
  66 |   56   0.094   5737|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   56   1.454 22782378|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   56   0.000    700|     lmt := lmt+time()-st;
  69 |   56   0.000      0|     if not assigned(minmon) then
  70 |    2   0.000      0|         CRT := Cp;
  71 |    2   0.000      0|         minmon := lmCp;
  72 |    2   0.000      0|         summon := minmon;
  73 |    2   0.000      0|         least := minmon;
  74 |    2   0.000      8|         H := [Cp]
                                else
  75 |   54   0.000   1590|         summon := lmCp+minmon;
  76 |   54   0.030 224833|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   54   0.136 801960|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   54   0.000    648|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   54   0.000   1137|             H := [op(H), Cp];
  84 |   54   0.000   1083|             Np := [op(Np), p];
  85 |   54   0.000    216|             st := time();
  86 |   54  45.722 388186680|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   53   0.000    784|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   55   0.000    220|     st := time();
  89 |   55   0.095 952455|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   55   0.000    816|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   55   0.000    165|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2452|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.047 1084452|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000  63026|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  38.234 637246606|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.016     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.046 632654| A := semi(A1);
  12 |    1   0.063 632654| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     20| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    577| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   1712| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   27   0.077  86400|     do
  26 |   27   0.000  12750|         p := nextprime(p);
  27 |   27   0.000      0|         lcmintest := true;
  28 |   27   0.000      0|         for i to m do
  29 |  108   0.000   1824|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   27   0.000    108|     st := time();
  32 |   27   2.741 33191688|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   27   0.000    432|     pt := pt+time()-st;
  34 |   27   0.000  66452|     Rand := rand(1 .. p-1);
  35 |   27   0.000     81|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   27   0.000   1208|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   27   0.000   1998|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   27   0.155 139644|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   27   0.000    108|         st := time();
  42 |   27   0.202 4687664|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   27   0.000    432|         laminpolytime := laminpolytime+time()-st;
  44 |   27   0.000     81|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   27   0.000    108|         M, phimatrix, invphimatrix := LA;
  47 |   27   0.000    108|         st := time();
  48 |   27   9.373 208004671|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   27   8.921 209374225|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   27   0.000    432|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   27   0.000    108|     st := time();
  52 |   27   8.767 96210913|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   27   0.000    432|     pgcdtime := pgcdtime+time()-st;
  54 |   27   0.000    162|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   27   0.016   5400|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   27   0.000     81|     if 1 &lt; m then
  62 |   27   0.000    108|         st := time();
  63 |   27   1.222 19499015|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   27   0.000    432|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   27   0.000    108|     st := time();
  66 |   27   0.000   2781|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   27   0.215 3481258|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   27   0.000    432|     lmt := lmt+time()-st;
  69 |   27   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   26   0.000   1274|         summon := lmCp+minmon;
  76 |   26   0.000  92872|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   26   0.031 170820|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   26   0.000    312|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   26   0.000    530|             H := [op(H), Cp];
  84 |   26   0.000    504|             Np := [op(Np), p];
  85 |   26   0.000    104|             st := time();
  86 |   26   5.796 46293496|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   26   0.000    412|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   27   0.000    108|     st := time();
  89 |   27   0.546 13209308|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   27   0.000    428|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   27   0.000     81|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2449|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.032 1229225|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.015 204956|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  72.078 1003136344|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.062 632654| A := semi(A1);
  12 |    1   0.047 632654| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     20| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.016    577| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   1712| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   27   0.016  86400|     do
  26 |   27   0.000  12750|         p := nextprime(p);
  27 |   27   0.000      0|         lcmintest := true;
  28 |   27   0.000      0|         for i to m do
  29 |  108   0.000   1864|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   27   0.000    108|     st := time();
  32 |   27   4.296 33192526|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   27   0.000    432|     pt := pt+time()-st;
  34 |   27   0.000  66491|     Rand := rand(1 .. p-1);
  35 |   27   0.000     81|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   27   0.000   1123|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   27   0.000   1998|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   27   0.078 139644|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   27   0.000    108|         st := time();
  42 |   27   0.248 4687664|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   27   0.000    432|         laminpolytime := laminpolytime+time()-st;
  44 |   27   0.000     81|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   27   0.000    108|         M, phimatrix, invphimatrix := LA;
  47 |   27   0.000    108|         st := time();
  48 |   27   9.515 211576311|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   27  12.564 209459279|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   27   0.000    432|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   27   0.000    108|     st := time();
  52 |   27  19.577 253844042|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   27   0.000    432|     pgcdtime := pgcdtime+time()-st;
  54 |   27   0.000    162|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   27   0.016   8154|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   27   0.000     81|     if 1 &lt; m then
  62 |   27   0.000    108|         st := time();
  63 |   27   2.802 65994354|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   27   0.000    432|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   27   0.000    108|     st := time();
  66 |   27   0.061   2781|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   27   1.119 12019340|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   27   0.000    432|     lmt := lmt+time()-st;
  69 |   27   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   26   0.000   1274|         summon := lmCp+minmon;
  76 |   26   0.032 121992|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   26   0.158 477204|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   26   0.000    312|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   26   0.000    530|             H := [op(H), Cp];
  84 |   26   0.000    504|             Np := [op(Np), p];
  85 |   26   0.000    104|             st := time();
  86 |   26  19.814 161108297|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   26   0.000    412|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   27   0.000    108|     st := time();
  89 |   27   1.594 47102031|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   27   0.000    428|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   27   0.000     81|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2449|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     30|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.047 1686623|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.016 267428|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    2 154.828 2038923236|
   1 |    2   0.000      0| timings := true;
   2 |    2   0.000      8| tt := time();
   3 |    2   0.000      0| pt := 0;
   4 |    2   0.000      0| lmt := 0;
   5 |    2   0.000      0| laminpolytime := 0;
   6 |    2   0.000      0| phigammatime := 0;
   7 |    2   0.000      0| pgcdtime := 0;
   8 |    2   0.000      0| CRTRNRtime := 0;
   9 |    2   0.000      0| divtime := 0;
  10 |    2   0.016    146| A1, B1, ring := ConvRing(A0,B0);
  11 |    2   0.141 1490308| A := semi(A1);
  12 |    2   0.125 1490308| B := semi(B1);
  13 |    2   0.000      8| Char, X, E := op(ring);
  14 |    2   0.000      0| n := nops(X);
  15 |    2   0.000      0| m := nops(E);
  16 |    2   0.000      0| k := n-m;
  17 |    2   0.000     16| Xpoly := X[1 .. k];
  18 |    2   0.000     41| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    2   0.000   1308| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    2   0.000   3996| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    2   0.000      0| H := [];
  22 |    2   0.000      0| Np := [];
  23 |    2   0.000      0| p := 2147483648;
  24 |    2   0.000      0| do
  25 |   50   0.234 166992|     do
  26 |   50   0.000  23426|         p := nextprime(p);
  27 |   50   0.000      0|         lcmintest := true;
  28 |   50   0.000      0|         for i to m do
  29 |  223   0.000   3780|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   50   0.000    200|     st := time();
  32 |   50   7.559 85063007|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   50   0.000    800|     pt := pt+time()-st;
  34 |   50   0.000 122946|     Rand := rand(1 .. p-1);
  35 |   50   0.000    150|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   50   0.000   2638|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   50   0.000   4091|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   50   0.204 315364|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   50   0.000    200|         st := time();
  42 |   50   0.550 9554763|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   50   0.000    800|         laminpolytime := laminpolytime+time()-st;
  44 |   50   0.000    150|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   50   0.000    200|         M, phimatrix, invphimatrix := LA;
  47 |   50   0.000    200|         st := time();
  48 |   50  16.907 369492610|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   50  18.685 366244492|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   50   0.016    800|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   50   0.000    200|     st := time();
  52 |   50  48.358 589994099|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   50   0.000    800|     pgcdtime := pgcdtime+time()-st;
  54 |   50   0.000    300|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   50   0.016  13484|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   50   0.000    150|     if 1 &lt; m then
  62 |   50   0.000    200|         st := time();
  63 |   50   7.126 144114730|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   50   0.000    800|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   50   0.000    200|     st := time();
  66 |   50   0.111   5173|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   50   2.000 25956289|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   50   0.000    696|     lmt := lmt+time()-st;
  69 |   50   0.000      0|     if not assigned(minmon) then
  70 |    2   0.000      0|         CRT := Cp;
  71 |    2   0.000      0|         minmon := lmCp;
  72 |    2   0.000      0|         summon := minmon;
  73 |    2   0.000      0|         least := minmon;
  74 |    2   0.000      8|         H := [Cp]
                                else
  75 |   48   0.000   1384|         summon := lmCp+minmon;
  76 |   48   0.000 214344|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   48   0.171 1030426|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   48   0.000    576|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   48   0.000    934|             H := [op(H), Cp];
  84 |   48   0.000    886|             Np := [op(Np), p];
  85 |   48   0.000    192|             st := time();
  86 |   48  49.142 347529428|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   48   0.000    712|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   50   0.000    200|     st := time();
  89 |   50   3.405 94672143|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   49   0.000    728|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   49   0.000    147|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2445|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.062 1296087|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.000 101354|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  38.047 564508948|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.016     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.093 857654| A := semi(A1);
  12 |    1   0.079 857654| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   24   0.154  84096|     do
  26 |   24   0.000  11762|         p := nextprime(p);
  27 |   24   0.000      0|         lcmintest := true;
  28 |   24   0.000      0|         for i to m do
  29 |  120   0.000   2001|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   24   0.000     96|     st := time();
  32 |   24   5.097 54126983|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   24   0.000    384|     pt := pt+time()-st;
  34 |   24   0.000  59033|     Rand := rand(1 .. p-1);
  35 |   24   0.000     72|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   24   0.000   1350|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   24   0.000   2184|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   24   0.186 183360|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   24   0.000     96|         st := time();
  42 |   24   0.262 5078712|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   24   0.000    376|         laminpolytime := laminpolytime+time()-st;
  44 |   24   0.000     72|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   24   0.000     96|         M, phimatrix, invphimatrix := LA;
  47 |   24   0.000     96|         st := time();
  48 |   24   8.580 166890514|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   24   7.939 166869911|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   24   0.000    384|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   24   0.000     96|     st := time();
  52 |   24   7.624 84961265|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   24   0.000    384|     pgcdtime := pgcdtime+time()-st;
  54 |   24   0.000    144|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   24   0.016   4800|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   24   0.000     72|     if 1 &lt; m then
  62 |   24   0.000     96|         st := time();
  63 |   24   1.593 22689031|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   24   0.000    384|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   24   0.000     96|     st := time();
  66 |   24   0.000   2496|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   24   0.315 3777986|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   24   0.000    384|     lmt := lmt+time()-st;
  69 |   24   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   23   0.000   1127|         summon := lmCp+minmon;
  76 |   23   0.000  89882|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   23   0.031 235428|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   23   0.000    276|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   23   0.000    434|             H := [op(H), Cp];
  84 |   23   0.000    411|             Np := [op(Np), p];
  85 |   23   0.000     92|             st := time();
  86 |   23   5.797 44586159|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   23   0.000    364|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   24   0.000     96|     st := time();
  89 |   24   0.187 11365587|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   24   0.000    380|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   24   0.000     72|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2438|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.062 1427776|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.016 330804|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  65.328 834481473|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.016     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.078 857654| A := semi(A1);
  12 |    1   0.078 857654| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   22   0.140  77088|     do
  26 |   22   0.000  10068|         p := nextprime(p);
  27 |   22   0.000      0|         lcmintest := true;
  28 |   22   0.000      0|         for i to m do
  29 |  110   0.000   1876|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   22   0.000     88|     st := time();
  32 |   22   3.595 49655892|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   22   0.000    352|     pt := pt+time()-st;
  34 |   22   0.000  54173|     Rand := rand(1 .. p-1);
  35 |   22   0.000     66|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   22   0.000   1215|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   22   0.000   2002|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   22   0.154 168080|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   22   0.000     88|         st := time();
  42 |   22   0.237 4655486|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   22   0.000    352|         laminpolytime := laminpolytime+time()-st;
  44 |   22   0.000     66|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   22   0.000     88|         M, phimatrix, invphimatrix := LA;
  47 |   22   0.000     88|         st := time();
  48 |   22   8.108 161033249|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   22   7.591 161030051|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   22   0.000    352|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   22   0.000     88|     st := time();
  52 |   22  15.770 208467945|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   22   0.000    352|     pgcdtime := pgcdtime+time()-st;
  54 |   22   0.000    132|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   22   0.000   6644|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   22   0.000     66|     if 1 &lt; m then
  62 |   22   0.000     88|         st := time();
  63 |   22   6.562 70685231|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   22   0.000    352|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   22   0.000     88|     st := time();
  66 |   22   0.031   2288|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   22   1.328 11975141|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   22   0.000    352|     lmt := lmt+time()-st;
  69 |   22   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   21   0.000   1029|         summon := lmCp+minmon;
  76 |   21   0.000 105835|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   21   0.141 626220|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   21   0.000    252|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   21   0.000    375|             H := [op(H), Cp];
  84 |   21   0.000    354|             Np := [op(Np), p];
  85 |   21   0.000     84|             st := time();
  86 |   21  20.218 127753302|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   21   0.000    332|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   22   0.000     88|     st := time();
  89 |   22   1.187 34130379|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   22   0.000    348|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   22   0.000     66|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2435|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.063 1880305|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.031 431772|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD
MGCD := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, PhiAp, PhiBp, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter,
  j, s, nfac, fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, 
  randfunction, minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, 
  phigammatime, lmt, Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1 126.453 1359192535|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| laminpolytime := 0;
   6 |    1   0.000      0| phigammatime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000      0| CRTRNRtime := 0;
   9 |    1   0.000      0| divtime := 0;
  10 |    1   0.016     73| A1, B1, ring := ConvRing(A0,B0);
  11 |    1   0.078 857654| A := semi(A1);
  12 |    1   0.078 857654| B := semi(B1);
  13 |    1   0.000      4| Char, X, E := op(ring);
  14 |    1   0.000      0| n := nops(X);
  15 |    1   0.000      0| m := nops(E);
  16 |    1   0.000      0| k := n-m;
  17 |    1   0.000      8| Xpoly := X[1 .. k];
  18 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  19 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  20 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  21 |    1   0.000      0| H := [];
  22 |    1   0.000      0| Np := [];
  23 |    1   0.000      0| p := 2147483648;
  24 |    1   0.000      0| do
  25 |   22   0.124  77088|     do
  26 |   22   0.000  10068|         p := nextprime(p);
  27 |   22   0.000      0|         lcmintest := true;
  28 |   22   0.000      0|         for i to m do
  29 |  110   0.000   1881|             if den(minpolys[i]) mod p = 0 then
  30 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  31 |   22   0.000     88|     st := time();
  32 |   22   4.110 49615662|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  33 |   22   0.000    352|     pt := pt+time()-st;
  34 |   22   0.000  54149|     Rand := rand(1 .. p-1);
  35 |   22   0.000     66|     if m &lt;= 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   22   0.000   1105|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   22   0.000   2002|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   22   0.156 168080|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   22   0.000     88|         st := time();
  42 |   22   0.235 4655486|         LA := LAMinpoly(minpolys,gamma,Xmin,X[n],p
                                      );
  43 |   22   0.000    336|         laminpolytime := laminpolytime+time()-st;
  44 |   22   0.000     66|         if LA = FAIL then
  45 |    0   0.000      0|             next
                                    end if;
  46 |   22   0.000     88|         M, phimatrix, invphimatrix := LA;
  47 |   22   0.000     88|         st := time();
  48 |   22   8.014 158857819|         PhiAp := Phi(Ap,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  49 |   22   7.768 158870760|         PhiBp := Phi(Bp,minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix);
  50 |   22   0.000    352|         phigammatime := phigammatime+time()-st
                                end if;
  51 |   22   0.000     88|     st := time();
  52 |   22  38.673 457139421|     Cp := traperror(PGCDAlg(PhiAp,PhiBp,p));
  53 |   22   0.000    352|     pgcdtime := pgcdtime+time()-st;
  54 |   22   0.000    132|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  55 |    0   0.000      0|         ZD := Cp[2];
  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   22   0.015   8888|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  59 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  60 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  61 |   22   0.000     66|     if 1 &lt; m then
  62 |   22   0.000     88|         st := time();
  63 |   22   9.421 152059809|         Cp := Phi(Cp,minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p);
  64 |   22   0.000    352|         phigammatime := phigammatime+time()-st
                                end if;
  65 |   22   0.000     88|     st := time();
  66 |   22   0.125   2288|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  67 |   22   1.858 25576372|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  68 |   22   0.000    352|     lmt := lmt+time()-st;
  69 |   22   0.000      0|     if not assigned(minmon) then
  70 |    1   0.000      0|         CRT := Cp;
  71 |    1   0.000      0|         minmon := lmCp;
  72 |    1   0.000      0|         summon := minmon;
  73 |    1   0.000      0|         least := minmon;
  74 |    1   0.000      4|         H := [Cp]
                                else
  75 |   21   0.000   1029|         summon := lmCp+minmon;
  76 |   21   0.000 129549|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  77 |   21   0.189 1283940|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  78 |   21   0.000    252|         if lmCp = least and minmon &lt;&gt; least then
  79 |    0   0.000      0|             H := [Cp];
  80 |    0   0.000      0|             CRT := Cp;
  81 |    0   0.000      0|             Np := [p];
  82 |    0   0.000      0|             minmon := least
                                    elif lmCp = least and minmon = least then
  83 |   21   0.000    375|             H := [op(H), Cp];
  84 |   21   0.000    354|             Np := [op(Np), p];
  85 |   21   0.000     84|             st := time();
  86 |   21  51.736 273451329|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  87 |   21   0.000    332|             CRTRNRtime := CRTRNRtime+time()-st
                                    end if
                                end if;
  88 |   22   0.000     88|     st := time();
  89 |   22   3.732 72557723|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  90 |   22   0.000    348|     CRTRNRtime := CRTRNRtime+time()-st;
  91 |   22   0.000     66|     if irat &lt;&gt; FAIL then
  92 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  93 |    1   0.000   2456|         randfunction := rand(p);
  94 |    1   0.000      4|         st := time();
  95 |    1   0.000    295|         do
  96 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  97 |    1   0.109 2599364|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  98 |    1   0.016 342516|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  99 |    1   0.000     16|             divtime := divtime+time()-st;
 100 |    1   0.000     12|             tt := time()-tt;
 101 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8"> 102 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  LAminpoly=%.3f PGCDAlg=\134
                                              %.3f lm=%.3f  Phigamma=%.3f  CRT\134
                                               and RNR=%.3f Division test=%.3f\134
                                              \134n&quot;,tt,pt,laminpolytime,pgcdtime
</Font>                                              ,lmt,phigammatime,CRTRNRtime,
                                              divtime)
                                        end if;
 103 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

</Text-field>
</Output>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUkqbWNvbXBsZXRlRzYjL0krbW9kdWxlbmFtZUc2IkksVHlwZXNldHRpbmdHSShfc3lzbGliR0YnNiQtSSVtcm93R0YkNiYtSSNtaUdGJDYlUSJSRicvJSdpdGFsaWNHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ2l0YWxpY0YnLUkjbW9HRiQ2LlEpJkFzc2lnbjtGJy9GNlEnbm9ybWFsRicvJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHRkAvJSlzdHJldGNoeUdGQC8lKnN5bW1ldHJpY0dGQC8lKGxhcmdlb3BHRkAvJS5tb3ZhYmxlbGltaXRzR0ZALyUnYWNjZW50R0ZALyUnbHNwYWNlR1EsMC4yNzc3Nzc4ZW1GJy8lJ3JzcGFjZUdGTy8lKWVxdWFsaXR5R0ZALUYsNiYtRiw2Ji1JKG1mZW5jZWRHRiQ2KC1GLDYmLUktbXNjcm9sbHRhYmxlR0YkNl5vLUkqbXNjcm9sbHRyR0YkNjItSSptc2Nyb2xsdGRHRiQ2Ki1JI21zR0YkNiNRI2RGRicvJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnLyUpcmVhZG9ubHlHRkAvJSlyb3dhbGlnbkdRIUYnLyUsY29sdW1uYWxpZ25HRltwLyUrZ3JvdXBhbGlnbkdGW3AvJShyb3dzcGFuR1EiMUYnLyUrY29sdW1uc3BhbkdGYnAtRl5vNiotRmFvNiNRJSNleHRGJ0Zkb0Znb0Zpb0ZccEZecEZgcEZjcC1GXm82Ki1GYW82I1ElI3ZhckYnRmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZebzYqLUZhbzYjUSlUZGVnKGYxKUYnRmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZebzYqLUZhbzYjUSlUZGVnKGYyKUYnRmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZebzYqLUZhbzYjUShUZGVnKGcpRidGZG9GZ29GaW9GXHBGXnBGYHBGY3AtRl5vNiotRmFvNiNRKFRkZWcoYSlGJ0Zkb0Znb0Zpb0ZccEZecEZgcEZjcC1GXm82Ki1GYW82I1EoVGRlZyhiKUYnRmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZebzYqLUZhbzYjUSpUZGVnKEdDRClGJ0Zkb0Znb0Zpb0ZccEZecEZgcEZjcC1GXm82Ki1GYW82I1ElVGltZUYnRmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZebzYqLUZhbzYjUSNOcEYnRmRvRmdvRmlvRlxwRl5wRmBwRmNwRmRvRmdvRmlvRlxwRl5wLUZbbzYyLUZebzYqLUkjbW5HRiQ2JFEjMzJGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZebzYqLUZcdDYkRmJwRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3AtRl5vNiotRlx0NiRRIjJGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZebzYqLUZcdDYkUSM0OEYnRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGaHRGY3QtRl5vNiotRlx0NiRRIzQ2RidGPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZddUZjdC1GXm82Ki1GXHQ2JFEnMzIuMTQwRidGPEZkb0Znb0Zpb0ZccEZecEZgcEZjcC1GXm82Ki1GXHQ2JFEkMTIzRidGPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZkb0Znb0Zpb0ZccEZecC1GW282MkZpc0ZfdEZjdEZodEZodC1GXm82Ki1GXHQ2JFEjMTJGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZebzYqLUZcdDYkUSMzNkYnRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGY3YtRl5vNiotRi82JVElRkFJTEYnRjJGNUZkb0Znb0Zpb0ZccEZecEZgcEZjcEZodkZndUZkb0Znb0Zpb0ZccEZecC1GW282MkZpc0ZfdEZjdEZodEZodC1GXm82Ki1GXHQ2JFEjMjRGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRl93Rl93Rmh2Rmh2Rmd1RmRvRmdvRmlvRlxwRl5wLUZbbzYyRmlzRl90RmN0Rmh0Rmh0RmN2Rl52Rl52Rmh2Rmh2Rmd1RmRvRmdvRmlvRlxwRl5wLUZbbzYyRmlzRmN0RmN0Rmh0Rmh0RmN0Rl11Rl11RmN0LUZebzYqLUZcdDYkUSc0NS4zNTlGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZebzYqLUZcdDYkUSM1N0YnRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGZG9GZ29GaW9GXHBGXnAtRltvNjJGaXNGY3RGY3RGaHRGaHRGXnZGY3ZGY3ZGXnYtRl5vNiotRlx0NiRRJzgxLjE1NkYnRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3AtRl5vNiotRlx0NiRRIzU5RidGPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZkb0Znb0Zpb0ZccEZecC1GW282MkZpc0ZjdEZjdEZodEZodEZfd0Zfd0Zfd0ZodkZodkZpeEZkb0Znb0Zpb0ZccEZecC1GW282MkZpc0ZjdEZjdEZodEZodEZjdkZedkZedkZodkZodkZpeEZkb0Znb0Zpb0ZccEZecC1GW282MkZpcy1GXm82Ki1GXHQ2JFEiM0YnRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGY3RGaHRGaHRGY3RGXXVGXXVGY3QtRl5vNiotRlx0NiRRJzMxLjUzMUYnRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3AtRl5vNiotRlx0NiRRIzM1RidGPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZkb0Znb0Zpb0ZccEZecC1GW282MkZpc0ZkeUZjdEZodEZodEZedkZjdkZjdkZedi1GXm82Ki1GXHQ2JFEnNDUuODI5RidGPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZeekZkb0Znb0Zpb0ZccEZecC1GW282MkZpc0ZkeUZjdEZodEZodEZfd0Zfd0Zfd0Zfdy1GXm82Ki1GXHQ2JFEnODAuNzE5RidGPEZkb0Znb0Zpb0ZccEZecEZgcEZjcC1GXm82Ki1GXHQ2JFEjMzNGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmRvRmdvRmlvRlxwRl5wLUZbbzYyRmlzRmR5RmN0Rmh0Rmh0RmN2Rl52Rl52Rmh2Rmh2RmFbbEZkb0Znb0Zpb0ZccEZecC1GW282MkZpcy1GXm82Ki1GXHQ2JFEiNEYnRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGY3RGaHRGaHRGY3RGXXVGXXVGY3QtRl5vNiotRlx0NiRRJzI0LjY0MUYnRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGX3dGZG9GZ29GaW9GXHBGXnAtRltvNjJGaXNGaltsRmN0Rmh0Rmh0Rl52RmN2RmN2Rl52LUZebzYqLUZcdDYkUSczOC4yMzRGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZebzYqLUZcdDYkUSMyNkYnRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGZG9GZ29GaW9GXHBGXnAtRltvNjJGaXNGaltsRmN0Rmh0Rmh0Rl93Rl93Rl93Rl93LUZebzYqLUZcdDYkUSc3Mi4wNzhGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRltdbEZkb0Znb0Zpb0ZccEZecC1GW282MkZpc0ZqW2xGY3RGaHRGaHRGY3ZGXnZGXnZGaHZGaHZGW11sRmRvRmdvRmlvRlxwRl5wLUZbbzYyRmlzLUZebzYqLUZcdDYkUSI1RidGPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZjdEZodEZodEZjdEZddUZddUZjdC1GXm82Ki1GXHQ2JFEnMjUuNzk3RidGPEZkb0Znb0Zpb0ZccEZecEZgcEZjcC1GXm82Ki1GXHQ2JFEjMjJGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmRvRmdvRmlvRlxwRl5wLUZbbzYyRmlzRltebEZjdEZodEZodEZedkZjdkZjdkZedi1GXm82Ki1GXHQ2JFEnMzguMDQ3RidGPEZkb0Znb0Zpb0ZccEZecEZgcEZjcC1GXm82Ki1GXHQ2JFEjMjNGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmRvRmdvRmlvRlxwRl5wLUZbbzYyRmlzRltebEZjdEZodEZodEZfd0Zfd0Zfd0Zfdy1GXm82Ki1GXHQ2JFEnNjUuMzI4RidGPEZkb0Znb0Zpb0ZccEZecEZgcEZjcC1GXm82Ki1GXHQ2JFEjMjFGJ0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmRvRmdvRmlvRlxwRl5wLUZbbzYyRmlzRltebEZjdEZodEZodEZjdkZedkZedkZjdi1GXm82Ki1GXHQ2JFEoMTI2LjQ1M0YnRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGXWBsRmRvRmdvRmlvRlxwRl5wLUZbbzYyLUZebzYqLUZcdDYkUSIwRidGPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZbYWxGW2FsRlthbEZbYWxGW2FsRlthbEZbYWxGW2FsRlthbEZbYWxGZG9GZ29GaW9GXHBGXnAvJSZhbGlnbkdRJWF4aXNGJy9Gam9RJ2NlbnRlckYnL0ZdcEZkYWwvRl9wUSd8ZnJsZWZ0fGhyRicvJS9hbGlnbm1lbnRzY29wZUdGNC8lLGNvbHVtbndpZHRoR1ElYXV0b0YnLyUmd2lkdGhHRlxibC8lK3Jvd3NwYWNpbmdHUSYxLjBleEYnLyUuY29sdW1uc3BhY2luZ0dRJjAuOGVtRicvJSlyb3dsaW5lc0dRJW5vbmVGJy8lLGNvbHVtbmxpbmVzR0ZnYmwvJSZmcmFtZUdGZ2JsLyUtZnJhbWVzcGFjaW5nR1EsMC40ZW1+MC41ZXhGJy8lKmVxdWFscm93c0dGQC8lLWVxdWFsY29sdW1uc0dGQC8lLWRpc3BsYXlzdHlsZUdGQC8lJXNpZGVHUSZyaWdodEYnLyUwbWlubGFiZWxzcGFjaW5nR0ZkYmwvJTFzaG93Y29sdW1uaGVhZGVyR0ZALyUuc2hvd3Jvd2hlYWRlckdGQC8lLmZyb3plbmRpc3BsYXlHRkAvJS5udW1iZXJjb2x1bW5zR1EjMTFGJy8lK251bWJlcnJvd3NHRmlebC8lNmRlZmF1bHR2aXNpYmxlY29sdW1uc0dGYmRsLyUzZGVmYXVsdHZpc2libGVyb3dzR0ZpXmwvJTFjb2x1bW5sb3dlcmJvdW5kR0ZicC8lMWNvbHVtbnVwcGVyYm91bmRHRmJkbC8lLnJvd2xvd2VyYm91bmRHRmJwLyUucm93dXBwZXJib3VuZEdGaV5sLyUtZGlzcGxheXdpZHRoR1EkNzE3RicvJS5kaXNwbGF5aGVpZ2h0R1EkNTUwRicvJTB1c2VyZGVmaW5lZHNpemVHRkAvJTpkaXNwbGF5aG9yaXpvbnRhbHBvc2l0aW9uR0ZfYWwvJThkaXNwbGF5dmVydGljYWxwb3NpdGlvbkdGX2FsLyU0ZGlzcGxheWNvbHVtbndpZHRoc0dRTVszMCx+NDAsfjQwLH42Nyx+NjcsfjYyLH42MSx+NjIsfjg2LH41MCx+MzJdRicvJTVkaXNwbGF5Y29sdW1uc3BhY2luZ0dRSVsxMSx+MTEsfjExLH4xMSx+MTEsfjExLH4xMSx+MTEsfjExLH4xMV1GJy8lOHVzZXJkZWZpbmVkY29sdW1ud2lkdGhzR1Fob1tmYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2VdRicvJTJkaXNwbGF5cm93aGVpZ2h0c0dRY3BbMTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTcsfjE3LH4xNyx+MTddRicvJTJkaXNwbGF5cm93c3BhY2luZ0dRam5bOCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OCx+OF1GJy8lNnVzZXJkZWZpbmVkcm93aGVpZ2h0c0dRZXRbZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2UsfmZhbHNlLH5mYWxzZSx+ZmFsc2VdRicvJSp0YWJsZXR5cGVHRl9hbC8lMnJvd2luZGV4aW5nb2Zmc2V0R0ZfYWwvJTVjb2x1bW5pbmRleGluZ29mZnNldEdGX2FsLyUyYXJyYXlzbGljZWluZGljZXNHUSNbXUYnRmRvRmdvRjxGPC9JK21zZW1hbnRpY3NHRiRRJ01hdHJpeEYnLyUlb3BlbkdRJyZsc3FiO0YnLyUmY2xvc2VHUScmcnNxYjtGJ0ZoZ2xGZG9GZ29GPEZkb0Znb0Y8RjwtRlk2KC1GLDYmLUknbXRhYmxlR0YkNkwtSSRtdHJHRiQ2Mi1JJG10ZEdGJEZfby1GXGlsRmZwLUZcaWxGW3EtRlxpbEZgcS1GXGlsRmVxLUZcaWxGanEtRlxpbEZfci1GXGlsRmRyLUZcaWxGaXItRlxpbEZecy1GXGlsRmNzRmRvRmdvRmlvRlxwRl5wLUZpaGw2Mi1GXGlsNiotRlx0NiZGXnRGZG9GZ29GPEZkb0Znb0Zpb0ZccEZecEZgcEZjcC1GXGlsNiotRlx0NiZGYnBGZG9GZ29GPEZkb0Znb0Zpb0ZccEZecEZgcEZjcC1GXGlsNiotRlx0NiZGZ3RGZG9GZ29GPEZkb0Znb0Zpb0ZccEZecEZgcEZjcC1GXGlsNiotRlx0NiZGXHVGZG9GZ29GPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZlamxGYWpsLUZcaWw2Ki1GXHQ2JkZhdUZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmlqbEZhamwtRlxpbDYqLUZcdDYmRmZ1RmRvRmdvRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3AtRlxpbDYqLUZcdDYmRlt2RmRvRmdvRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGZG9GZ29GaW9GXHBGXnAtRmlobDYyRmlpbEZdamxGYWpsRmVqbEZlamwtRlxpbDYqLUZcdDYmRmJ2RmRvRmdvRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3AtRlxpbDYqLUZcdDYmRmd2RmRvRmdvRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGW1xtLUZcaWw2Ki1GLzYnRlx3RjJGZG9GZ29GNUZkb0Znb0Zpb0ZccEZecEZgcEZjcEZfXG1GYVttRmRvRmdvRmlvRlxwRl5wLUZpaGw2MkZpaWxGXWpsRmFqbEZlamxGZWpsLUZcaWw2Ki1GXHQ2JkZjd0Zkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmVcbUZlXG1GX1xtRl9cbUZhW21GZG9GZ29GaW9GXHBGXnAtRmlobDYyRmlpbEZdamxGYWpsRmVqbEZlamxGW1xtRmdbbUZnW21GX1xtRl9cbUZhW21GZG9GZ29GaW9GXHBGXnAtRmlobDYyRmlpbEZhamxGYWpsRmVqbEZlamxGYWpsRmlqbEZpamxGYWpsLUZcaWw2Ki1GXHQ2JkZceEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwLUZcaWw2Ki1GXHQ2JkZheEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmRvRmdvRmlvRlxwRl5wLUZpaGw2MkZpaWxGYWpsRmFqbEZlamxGZWpsRmdbbUZbXG1GW1xtRmdbbS1GXGlsNiotRlx0NiZGaHhGZG9GZ29GPEZkb0Znb0Zpb0ZccEZecEZgcEZjcC1GXGlsNiotRlx0NiZGXXlGZG9GZ29GPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZkb0Znb0Zpb0ZccEZecC1GaWhsNjJGaWlsRmFqbEZhamxGZWpsRmVqbEZlXG1GZVxtRmVcbUZfXG1GX1xtRltebUZkb0Znb0Zpb0ZccEZecC1GaWhsNjJGaWlsRmFqbEZhamxGZWpsRmVqbEZbXG1GZ1ttRmdbbUZfXG1GX1xtRltebUZkb0Znb0Zpb0ZccEZecC1GaWhsNjJGaWlsLUZcaWw2Ki1GXHQ2JkZoeUZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmFqbEZlamxGZWpsRmFqbEZpamxGaWpsRmFqbC1GXGlsNiotRlx0NiZGXXpGZG9GZ29GPEZkb0Znb0Zpb0ZccEZecEZgcEZjcC1GXGlsNiotRlx0NiZGYnpGZG9GZ29GPEZkb0Znb0Zpb0ZccEZecEZgcEZjcEZkb0Znb0Zpb0ZccEZecC1GaWhsNjJGaWlsRmVebUZhamxGZWpsRmVqbEZnW21GW1xtRltcbUZnW20tRlxpbDYqLUZcdDYmRml6RmRvRmdvRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGXV9tRmRvRmdvRmlvRlxwRl5wLUZpaGw2MkZpaWxGZV5tRmFqbEZlamxGZWpsRmVcbUZlXG1GZVxtRmVcbS1GXGlsNiotRlx0NiZGYFtsRmRvRmdvRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3AtRlxpbDYqLUZcdDYmRmVbbEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmRvRmdvRmlvRlxwRl5wLUZpaGw2MkZpaWxGZV5tRmFqbEZlamxGZWpsRltcbUZnW21GZ1ttRl9cbUZfXG1GXWBtRmRvRmdvRmlvRlxwRl5wLUZpaGw2MkZpaWwtRlxpbDYqLUZcdDYmRl5cbEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmFqbEZlamxGZWpsRmFqbEZpamxGaWpsRmFqbC1GXGlsNiotRlx0NiZGY1xsRmRvRmdvRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGZVxtRmRvRmdvRmlvRlxwRl5wLUZpaGw2MkZpaWxGZWBtRmFqbEZlamxGZWpsRmdbbUZbXG1GW1xtRmdbbS1GXGlsNiotRlx0NiZGalxsRmRvRmdvRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3AtRlxpbDYqLUZcdDYmRl9dbEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmRvRmdvRmlvRlxwRl5wLUZpaGw2MkZpaWxGZWBtRmFqbEZlamxGZWpsRmVcbUZlXG1GZVxtRmVcbS1GXGlsNiotRlx0NiZGZl1sRmRvRmdvRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGY2FtRmRvRmdvRmlvRlxwRl5wLUZpaGw2MkZpaWxGZWBtRmFqbEZlamxGZWpsRltcbUZnW21GZ1ttRl9cbUZfXG1GY2FtRmRvRmdvRmlvRlxwRl5wLUZpaGw2MkZpaWwtRlxpbDYqLUZcdDYmRl9ebEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmFqbEZlamxGZWpsRmFqbEZpamxGaWpsRmFqbC1GXGlsNiotRlx0NiZGZF5sRmRvRmdvRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3AtRlxpbDYqLUZcdDYmRmlebEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmRvRmdvRmlvRlxwRl5wLUZpaGw2MkZpaWxGYWJtRmFqbEZlamxGZWpsRmdbbUZbXG1GW1xtRmdbbS1GXGlsNiotRlx0NiZGYF9sRmRvRmdvRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3AtRlxpbDYqLUZcdDYmRmVfbEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmRvRmdvRmlvRlxwRl5wLUZpaGw2MkZpaWxGYWJtRmFqbEZlamxGZWpsRmVcbUZlXG1GZVxtRmVcbS1GXGlsNiotRlx0NiZGXGBsRmRvRmdvRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3AtRlxpbDYqLUZcdDYmRmFgbEZkb0Znb0Y8RmRvRmdvRmlvRlxwRl5wRmBwRmNwRmRvRmdvRmlvRlxwRl5wLUZpaGw2MkZpaWxGYWJtRmFqbEZlamxGZWpsRltcbUZnW21GZ1ttRltcbS1GXGlsNiotRlx0NiZGaGBsRmRvRmdvRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGXWRtRmRvRmdvRmlvRlxwRl5wLUZpaGw2Mi1GXGlsNiotRlx0NiZGX2FsRmRvRmdvRjxGZG9GZ29GaW9GXHBGXnBGYHBGY3BGaWRtRmlkbUZpZG1GaWRtRmlkbUZpZG1GaWRtRmlkbUZpZG1GaWRtRmRvRmdvRmlvRlxwRl5wRmRvRmdvRmBhbC9Gam9RKWJhc2VsaW5lRidGZWFsRmZhbEZoYWxGamFsRl1ibEZfYmxGYmJsRmVibEZoYmxGamJsRlxjbEZfY2xGYWNsRmNjbEZlY2xGaGNsRmRvRmdvRjxGZG9GZ29GPC9GXGhsUSJbRicvRl9obFEiXUYn">LUkobWZlbmNlZEc2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUklbXJvd0dGJDYjLUknbXRhYmxlR0YkNkwtSSRtdHJHRiQ2MC1JJG10ZEdGJDYoLUkjbXNHRiQ2I1EjZEZGJy8lKXJvd2FsaWduR1EhRicvJSxjb2x1bW5hbGlnbkdGPS8lK2dyb3VwYWxpZ25HRj0vJShyb3dzcGFuR1EiMUYnLyUrY29sdW1uc3BhbkdGRC1GNTYoLUY4NiNRJSNleHRGJ0Y7Rj5GQEZCRkUtRjU2KC1GODYjUSUjdmFyRidGO0Y+RkBGQkZFLUY1NigtRjg2I1EpVGRlZyhmMSlGJ0Y7Rj5GQEZCRkUtRjU2KC1GODYjUSlUZGVnKGYyKUYnRjtGPkZARkJGRS1GNTYoLUY4NiNRKFRkZWcoZylGJ0Y7Rj5GQEZCRkUtRjU2KC1GODYjUShUZGVnKGEpRidGO0Y+RkBGQkZFLUY1NigtRjg2I1EoVGRlZyhiKUYnRjtGPkZARkJGRS1GNTYoLUY4NiNRKlRkZWcoR0NEKUYnRjtGPkZARkJGRS1GNTYoLUY4NiNRJVRpbWVGJ0Y7Rj5GQEZCRkUtRjU2KC1GODYjUSNOcEYnRjtGPkZARkJGRUY7Rj5GQC1GMjYwLUY1NigtSSNtbkdGJDYmUSMzMkYnLyUrZm9yZWdyb3VuZEdRKFswLDAsMF1GJy8lKXJlYWRvbmx5R1EmZmFsc2VGJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRidGO0Y+RkBGQkZFLUY1NigtRmhwNiZGREZbcUZecUZhcUY7Rj5GQEZCRkUtRjU2KC1GaHA2JlEiMkYnRltxRl5xRmFxRjtGPkZARkJGRS1GNTYoLUZocDYmUSM0OEYnRltxRl5xRmFxRjtGPkZARkJGRUZdckZocS1GNTYoLUZocDYmUSM0NkYnRltxRl5xRmFxRjtGPkZARkJGRUZickZocS1GNTYoLUZocDYmUSczMi4xNDBGJ0ZbcUZecUZhcUY7Rj5GQEZCRkUtRjU2KC1GaHA2JlEkMTIzRidGW3FGXnFGYXFGO0Y+RkBGQkZFRjtGPkZALUYyNjBGZXBGZHFGaHFGXXJGXXItRjU2KC1GaHA2JlEjMTJGJ0ZbcUZecUZhcUY7Rj5GQEZCRkUtRjU2KC1GaHA2JlEjMzZGJ0ZbcUZecUZhcUY7Rj5GQEZCRkVGaHMtRjU2KC1JI21pR0YkNidRJUZBSUxGJy8lJ2l0YWxpY0dRJXRydWVGJ0ZbcUZecS9GYnFRJ2l0YWxpY0YnRjtGPkZARkJGRUZddEZcc0Y7Rj5GQC1GMjYwRmVwRmRxRmhxRl1yRl1yLUY1NigtRmhwNiZRIzI0RidGW3FGXnFGYXFGO0Y+RkBGQkZFRmp0Rmp0Rl10Rl10RlxzRjtGPkZALUYyNjBGZXBGZHFGaHFGXXJGXXJGaHNGY3NGY3NGXXRGXXRGXHNGO0Y+RkAtRjI2MEZlcEZocUZocUZdckZdckZocUZickZickZocS1GNTYoLUZocDYmUSc0NS4zNTlGJ0ZbcUZecUZhcUY7Rj5GQEZCRkUtRjU2KC1GaHA2JlEjNTdGJ0ZbcUZecUZhcUY7Rj5GQEZCRkVGO0Y+RkAtRjI2MEZlcEZocUZocUZdckZdckZjc0Zoc0Zoc0Zjcy1GNTYoLUZocDYmUSc4MS4xNTZGJ0ZbcUZecUZhcUY7Rj5GQEZCRkUtRjU2KC1GaHA2JlEjNTlGJ0ZbcUZecUZhcUY7Rj5GQEZCRkVGO0Y+RkAtRjI2MEZlcEZocUZocUZdckZdckZqdEZqdEZqdEZddEZddEZkdkY7Rj5GQC1GMjYwRmVwRmhxRmhxRl1yRl1yRmhzRmNzRmNzRl10Rl10RmR2RjtGPkZALUYyNjBGZXAtRjU2KC1GaHA2JlEiM0YnRltxRl5xRmFxRjtGPkZARkJGRUZocUZdckZdckZocUZickZickZocS1GNTYoLUZocDYmUSczMS41MzFGJ0ZbcUZecUZhcUY7Rj5GQEZCRkUtRjU2KC1GaHA2JlEjMzVGJ0ZbcUZecUZhcUY7Rj5GQEZCRkVGO0Y+RkAtRjI2MEZlcEZfd0ZocUZdckZdckZjc0Zoc0Zoc0Zjcy1GNTYoLUZocDYmUSc0NS44MjlGJ0ZbcUZecUZhcUY7Rj5GQEZCRkVGaXdGO0Y+RkAtRjI2MEZlcEZfd0ZocUZdckZdckZqdEZqdEZqdEZqdC1GNTYoLUZocDYmUSc4MC43MTlGJ0ZbcUZecUZhcUY7Rj5GQEZCRkUtRjU2KC1GaHA2JlEjMzNGJ0ZbcUZecUZhcUY7Rj5GQEZCRkVGO0Y+RkAtRjI2MEZlcEZfd0ZocUZdckZdckZoc0Zjc0Zjc0ZddEZddEZceUY7Rj5GQC1GMjYwRmVwLUY1NigtRmhwNiZRIjRGJ0ZbcUZecUZhcUY7Rj5GQEZCRkVGaHFGXXJGXXJGaHFGYnJGYnJGaHEtRjU2KC1GaHA2JlEnMjQuNjQxRidGW3FGXnFGYXFGO0Y+RkBGQkZFRmp0RjtGPkZALUYyNjBGZXBGZXlGaHFGXXJGXXJGY3NGaHNGaHNGY3MtRjU2KC1GaHA2JlEnMzguMjM0RidGW3FGXnFGYXFGO0Y+RkBGQkZFLUY1NigtRmhwNiZRIzI2RidGW3FGXnFGYXFGO0Y+RkBGQkZFRjtGPkZALUYyNjBGZXBGZXlGaHFGXXJGXXJGanRGanRGanRGanQtRjU2KC1GaHA2JlEnNzIuMDc4RidGW3FGXnFGYXFGO0Y+RkBGQkZFRmZ6RjtGPkZALUYyNjBGZXBGZXlGaHFGXXJGXXJGaHNGY3NGY3NGXXRGXXRGZnpGO0Y+RkAtRjI2MEZlcC1GNTYoLUZocDYmUSI1RidGW3FGXnFGYXFGO0Y+RkBGQkZFRmhxRl1yRl1yRmhxRmJyRmJyRmhxLUY1NigtRmhwNiZRJzI1Ljc5N0YnRltxRl5xRmFxRjtGPkZARkJGRS1GNTYoLUZocDYmUSMyMkYnRltxRl5xRmFxRjtGPkZARkJGRUY7Rj5GQC1GMjYwRmVwRmZbbEZocUZdckZdckZjc0Zoc0Zoc0Zjcy1GNTYoLUZocDYmUSczOC4wNDdGJ0ZbcUZecUZhcUY7Rj5GQEZCRkUtRjU2KC1GaHA2JlEjMjNGJ0ZbcUZecUZhcUY7Rj5GQEZCRkVGO0Y+RkAtRjI2MEZlcEZmW2xGaHFGXXJGXXJGanRGanRGanRGanQtRjU2KC1GaHA2JlEnNjUuMzI4RidGW3FGXnFGYXFGO0Y+RkBGQkZFLUY1NigtRmhwNiZRIzIxRidGW3FGXnFGYXFGO0Y+RkBGQkZFRjtGPkZALUYyNjBGZXBGZltsRmhxRl1yRl1yRmhzRmNzRmNzRmhzLUY1NigtRmhwNiZRKDEyNi40NTNGJ0ZbcUZecUZhcUY7Rj5GQEZCRkVGaF1sRjtGPkZALUYyNjAtRjU2KC1GaHA2JlEiMEYnRltxRl5xRmFxRjtGPkZARkJGRUZmXmxGZl5sRmZebEZmXmxGZl5sRmZebEZmXmxGZl5sRmZebEZmXmxGO0Y+RkBGW3FGXnEvJSZhbGlnbkdRJWF4aXNGJy9GPFEpYmFzZWxpbmVGJy9GP1EnY2VudGVyRicvRkFRJ3xmcmxlZnR8aHJGJy8lL2FsaWdubWVudHNjb3BlR0ZldC8lLGNvbHVtbndpZHRoR1ElYXV0b0YnLyUmd2lkdGhHRmhfbC8lK3Jvd3NwYWNpbmdHUSYxLjBleEYnLyUuY29sdW1uc3BhY2luZ0dRJjAuOGVtRicvJSlyb3dsaW5lc0dRJW5vbmVGJy8lLGNvbHVtbmxpbmVzR0ZjYGwvJSZmcmFtZUdGY2BsLyUtZnJhbWVzcGFjaW5nR1EsMC40ZW1+MC41ZXhGJy8lKmVxdWFscm93c0dGYHEvJS1lcXVhbGNvbHVtbnNHRmBxLyUtZGlzcGxheXN0eWxlR0ZgcS8lJXNpZGVHUSZyaWdodEYnLyUwbWlubGFiZWxzcGFjaW5nR0ZgYGxGW3FGXnFGYXEvJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRic=</Equation></Text-field>
</Output>
</Group>
<Group hide-input="false" labelreference="L708" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group><RTable handle="36893489716941766652">TTdSMApJQVJUQUJMRV9TQVZFLzM2ODkzNDg5NzE2OTQxNzY2NjUyWCwlKWFueXRoaW5nRzYiRiVbZ2whIiUhISEjYV1tIlMiLFEjZEZGJSIjS0YnRidGJ0YnRidGJ0YnRidGJ0YnRidGJ0YnRidGJ0YnRidGJ0YnRidGJ0YnRidGJ0YnRidGJ0YnRidGJ0YnRidGJ0YnRidGJ0YnRidGJ0YnRidGJ0YnRidGJ0YnRiciIiFRJSNleHRGJSIiJkYqRipGKkYqRipGKkYqRipGKkYqRipGKkYqRipGKkYqRipGKkYqRipGKkYqRipGKkYqRipGKkYqRipGKkYqRipGKkYqRipGKkYqRipGKkYqRipGKkYqRipGKkYqRipGKFElI3ZhckYlIiIjRixGLEYsRixGLEYsRixGLEYsRixGLEYsRixGLEYsRixGLEYsRixGLEYsRixGLEYsRixGLEYsRixGLEYsRixGLEYsRixGLEYsRixGLEYsRixGLEYsRixGLEYsRixGLEYoUSlUZGVnKGYxKUYlIiIpRi5GLkYuIiM3Ri9GL0YvIiM7RjBGMEYwIiM/RjFGMUYxIiNDRjJGMkYyRidGJ0YnRiciI1NGM0YzRjMiI1tGNEY0RjQiI2NGNUY1RjUiI2tGNkY2RjYiI3NGN0Y3RjciIyEpRjhGOEY4RihRKVRkZWcoZjIpRiVGLkYuRi5GLkYvRi9GL0YvRjBGMEYwRjBGMUYxRjFGMUYyRjJGMkYyRidGJ0YnRidGM0YzRjNGM0Y0RjRGNEY0RjVGNUY1RjVGNkY2RjZGNkY3RjdGN0Y3RjhGOEY4RjhGKFEoVGRlZyhnKUYlRixGLCIiJSIiJ0YsRixGPCIjNUYsRjtGLkYvRixGO0Y9RjBGLEY8Ri8iIz1GLEYuRjBGMkYsRj1GMSIjSUYsRi9GMiIjT0YsIiM5IiNHIiNVRixGMEYnRjRGLEY+RkAiI2FGLEYxRjMiI2dGKFEoVGRlZyhhKUYlRjxGPEY7RixGPUY9RjxGLEZBRi9GLkY7Rj5GMEY9RjsiI0FGPkYvRjxGP0YyRjBGLiIjUUY/RjFGPSIjWUZARjJGL0ZERkNGQkZBIiNpRjRGJ0YwIiNxRkRGQEY+IiN5RkVGM0YxRihRKFRkZWcoYilGJUY8RjxGO0YsRj1GPUY8RixGQUYvRi5GO0Y+RjBGPUY7RkdGPkYvRjxGP0YyRjBGLkZIRj9GMUY9RklGQEYyRi9GREZDRkJGQUZKRjRGJ0YwRktGREZARj5GTEZFRjNGMUYoUSpUZGVnKEdDRClGJUYsRixGO0Y8RixGLEY8Rj1GLEY7Ri5GL0YsRjtGPUYwRixGPEYvRj5GLEYuRjBGMkYsRj1GMUY/RixGL0YyJSVGQUlMR0YsRkFGQkZPRixGMEZPRk9GLEY+Rk9GT0YsRjFGT0ZPRihRJVRpbWVGJSQiJWpEISIkJCIldj1GUyQiJVBSRlMkIiUlNCZGUyQiJVdRRlMkIiVBUkZTJCIleXFGUyQiJkc4IkZTJCIlY2NGUyQiJXpnRlMkIiUpbypGUyQiJk0oPUZTJCIlV3RGUyQiJT4oKUZTJCImIlI5RlMkIiY+cyNGUyQiJSUpKipGUyQiJiJHNkZTJCImJSk0I0ZTJCImVDYkRlMkIiZ2USJGUyQiJiVmPUZTJCImNTYkRlMkIiZmQihGUyQiJjU2I0ZTJCImcDkkRlMkIiZwLydGUyQiJys/OEZTJCImVy4kRlMkIiYiUlZGUyQiJnAlKilGU0ZPJCImNDElRlMkIiZ5PydGUyQiJmYpKSpGU0ZPJCImaSZlRlMkIiZ5PyhGU0ZPRk8kIiYkZnZGUyQiJiJSKCpGU0ZPRk8kIiYiKikqKkZTJCInVCJHIkZTRk9GT0YoUSNOcEYlRjFGMSIjQiIjQEZHRkdGXXNGXnNGMkZec0YxRkdGXnNGR0Zec0Zec0YyRl5zRkdGMUYxRjEiIz5GXXNGXnNGR0ZHRjJGMUZec0ZHRkdGX3NGXnNGPkY+Rl5zRl9zRl9zRl9zRkdGMUYxRjFGXXNGMUYxRjFGKEYl</RTable>
</Worksheet>