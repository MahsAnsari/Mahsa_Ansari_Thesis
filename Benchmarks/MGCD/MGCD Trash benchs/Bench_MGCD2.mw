<?xml version="1.0" encoding="UTF-8"?>
<Worksheet>
<Version major="2025" minor="1"/>
<Label-Scheme value="2" prefix=""/>
<View-Properties presentation="false" autoexpanding_sections="true" UserProfileName="Maple Default Profile" NumericFormat-ApplyInteger="true" NumericFormat-ApplyRational="true" NumericFormat-ApplyExponent="false" editable="true">
</View-Properties>
<MapleNet-Properties prettyprint="3" compactdisplay="false" preplot="" helpbrowser="standard" echo="1" scientificx="true" unitattributes="&quot;fontweight&quot; = &quot;bold&quot;" writeScrollableTableTypesetting="true" imaginaryunit="I" longdelim="true" elisiontermsthreshold="10000" elisiondigitsbefore="100" plotdevice="inline" elisiontermsbefore="100" historytimestamp="false" indentamount="4" plotoutput="terminal" screenpixelheight="1080" rtablesize="40" useclientjvm="true" format="worksheet" labelwidth="20" postplot="" typesetting="extended" elisiondigitsthreshold="10000" ansilprint="false" labelling="true" verboseproc="1" latexwidth="8.0" warnlevel="3" displayprecision="-1" elisiondigitsafter="100" errorbreak="1" plotoptions="" plotdriver="opengl" quiet="false" elisiontermsafter="100" screenwidth="79" ansi="false" ansicolor="[]" showassumed="1" trailingsemicolon="true" errorcursor="false" screenheight="25" prompt="&gt; " ShowLabels="true"/>
<Styles>
<Font name="Heading 1" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Warning" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="2D Output" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Heading 4" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Line Printed Output" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Heading 2" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="16" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Maple Output" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="2D Inert Output" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[144,144,144]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Heading 3" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="14" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Diagnostic" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[40,120,40]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Ordered List 1" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Maple Input" background="[255,255,255]" bold="true" executable="true" family="Courier New" foreground="[120,0,14]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Text Output" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Ordered List 2" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Ordered List 3" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Ordered List 4" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Ordered List 5" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Annotation Title" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Header and Footer" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="HyperlinkError" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="true" strikethrough="false" placeholder="false"/>
<Font name="Atomic Variable" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[175,0,175]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="HyperlinkWarning" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="true" strikethrough="false" placeholder="false"/>
<Font name="Dictionary Hyperlink" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[147,0,15]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" strikethrough="false" placeholder="false"/>
<Font name="2D Math" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Bullet Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Maple Plot" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Annotation Text" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="List Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Dash Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="2D Input" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Error" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Title" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Text" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Normal" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Caption Reference" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Code" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Maple Input Placeholder" background="[255,255,255]" bold="true" executable="true" family="Courier New" foreground="[200,0,200]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="true"/>
<Font name="Equation Label" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Author" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Font name="Hyperlink" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,128,128]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" strikethrough="false" placeholder="false"/>
<Font name="Caption Text" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" strikethrough="false" placeholder="false"/>
<Layout name="Heading 1" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="4" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Warning" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 4" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Line Printed Output" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="any" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 2" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="2" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Maple Output" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.3" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 3" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Diagnostic" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="any" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Ordered List 1" alignment="left" bullet="numeric" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Text Output" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="newline" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Ordered List 2" alignment="left" bullet="alphabetic" firstindent="0" leftmargin="36" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Ordered List 3" alignment="left" bullet="roman" firstindent="0" leftmargin="72" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Ordered List 4" alignment="left" bullet="ALPHABETIC" firstindent="0" leftmargin="108" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Ordered List 5" alignment="left" bullet="ROMAN" firstindent="0" leftmargin="144" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Annotation Title" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="12" spacebelow="12" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="HyperlinkError" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="HyperlinkWarning" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Bullet Item" alignment="left" bullet="dot" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Maple Plot" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="List Item" alignment="left" bullet="indent" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Dash Item" alignment="left" bullet="dash" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Error" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Title" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="12" spacebelow="12" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Normal" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Author" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="8" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Pencil-style name="Pencil 1" pen-color="[0,0,0]" pen-height="1.0" pen-width="1.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 2" pen-color="[0,0,255]" pen-height="1.0" pen-width="1.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 3" pen-color="[0,0,0]" pen-height="3.0" pen-width="3.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 4" pen-color="[0,0,255]" pen-height="3.0" pen-width="3.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 5" pen-color="[255,0,0]" pen-height="5.0" pen-width="5.0" pen-opacity="1.0"/>
<Highlighter-style name="Highlighter 5" pen-color="[255,255,0]" pen-height="48.0" pen-width="48.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 3" pen-color="[51,255,0]" pen-height="24.0" pen-width="24.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 4" pen-color="[0,255,255]" pen-height="32.0" pen-width="32.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 1" pen-color="[255,153,255]" pen-height="12.0" pen-width="8.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 2" pen-color="[255,204,0]" pen-height="14.0" pen-width="14.0" pen-opacity="0.8"/>
</Styles>
<Startup-Code startupcode=""/>
<Task-table>
	<Task-category name="&lt;default&gt;"/>
</Task-table>
<Task/>
<Group hide-input="false" labelreference="L113" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">restart;
with(PolynomialTools):
interface(rtablesize=40):
with(ExcelTools):
<Font foreground="[0,128,128]">#LAMinpolyMaple file contains the LAMinpoly algorithm to get M(z).
#PhigammaMaple file maps phi_p(f1), phi_p(f2) to their corresponding polynomials in Z_p[z]/&lt;M(z)&gt; using phi_{gamma} isomorphism.
#Get contains getvars, getring,..., and conv2cons for basic operations regarding the ring and extensions
#MonOpMaple 
#ContMaple
#PGCD
#MGCD
</Font></Text-field>
</Input>
</Group>
<Group hide-input="false" labelreference="L226" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[0,128,128]">#Read subrutines</Font>
currentdir():
read &quot;Get&quot;; read &quot;LAMinpolyMaple&quot;; read &quot;PhigammaMaple&quot;; read &quot;MonOpMaple&quot;;  read &quot;PGCDMaple&quot;; read &quot;MGCD1&quot;; read &quot;MGCD2&quot;; read &quot;Bench.mpl&quot;;
RDP:=Algebraic:-RecursiveDensePolynomials;</Text-field>
</Input>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUkjbWlHRiQ2JVEkUkRQRicvJSdpdGFsaWNHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ2l0YWxpY0YnLUkjbW9HRiQ2LlEpJkFzc2lnbjtGJy9GM1Enbm9ybWFsRicvJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHRj0vJSlzdHJldGNoeUdGPS8lKnN5bW1ldHJpY0dGPS8lKGxhcmdlb3BHRj0vJS5tb3ZhYmxlbGltaXRzR0Y9LyUnYWNjZW50R0Y9LyUnbHNwYWNlR1EsMC4yNzc3Nzc4ZW1GJy8lJ3JzcGFjZUdGTC8lKWVxdWFsaXR5R0Y9LUYsNiVRKkFsZ2VicmFpY0YnRi9GMi1GNjYuUS8mY29sb247Jm1pbnVzO0YnRjlGO0Y+RkBGQkZERkZGSC9GS1EmMC4wZW1GJy9GTkZYRk8tRiw2JVE6UmVjdXJzaXZlRGVuc2VQb2x5bm9taWFsc0YnRi9GMkY5">LV9JLFR5cGVzZXR0aW5nRzYkJSpwcm90ZWN0ZWRHSShfc3lzbGliRzYiSSxtcHJpbnRzbGFzaEdGKDYkNyM+SSRSRFBHRihJOlJlY3Vyc2l2ZURlbnNlUG9seW5vbWlhbHNHNiQvSSttb2R1bGVuYW1lR0YoSSpBbGdlYnJhaWNHRiVGJjcjRi4=</Equation></Text-field>
</Output>
</Group>
<Group hide-input="false" labelreference="L339" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font opaque="true" size="16" background="[255,255,153]" foreground="[0,0,255]">#1</Font><Font opaque="true" background="[255,255,153]" foreground="[0,0,255]">:Number of Variables changing from 1 to 5</Font></Text-field>
</Input>
</Group>
<Group hide-input="false" labelreference="L711" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font opaque="true" background="[204,255,204]">flagalg:=MGCD2; #Using RDP=Algebraic:-RecursiveDensePolynomials
#vars:=</Font><Font foreground="[128,0,0]">[seq(</Font>1..4)];<Font opaque="true" background="[204,255,204]">
#</Font>R:=<Font foreground="[128,0,0]">Benchmain(flagalg,vars</Font>,24,12,24,4,0);
#Export(R,&quot;MGCD2.xls&quot;,&quot;#var&quot;);</Text-field>
</Input>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUkjbWlHRiQ2JVEoZmxhZ2FsZ0YnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy1JI21vR0YkNi5RKSZBc3NpZ247RicvRjNRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y9LyUpc3RyZXRjaHlHRj0vJSpzeW1tZXRyaWNHRj0vJShsYXJnZW9wR0Y9LyUubW92YWJsZWxpbWl0c0dGPS8lJ2FjY2VudEdGPS8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkwvJSllcXVhbGl0eUdGPS1GLDYlUSZNR0NEMkYnRi9GMkY5">LV9JLFR5cGVzZXR0aW5nRzYkJSpwcm90ZWN0ZWRHSShfc3lzbGliRzYiSSxtcHJpbnRzbGFzaEdGKDYkNyM+SShmbGFnYWxnR0YoSSZNR0NEMkdGKDcjRi4=</Equation></Text-field>
</Output>
</Group>
<Group hide-input="false" labelreference="L709" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font opaque="true" size="16" background="[255,255,153]" foreground="[0,0,255]">#2: </Font><Font opaque="true" background="[255,255,153]" foreground="[0,0,128]">Total degree of the polynomials are changing from 1 to 15
tdeg:=</Font><Font foreground="[128,0,0]">[4,6,8,10,12,16,20,24,28,32,36,40</Font>];<Font opaque="true" background="[255,255,153]" foreground="[0,0,128]">
</Font>R:=<Font foreground="[128,0,0]">Benchmain(flagalg,2</Font>,tdeg,10,32,5,0);
Export(R,&quot;MGCD2.xls&quot;,&quot;Tdeg&quot;);
</Text-field>
</Input>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUkjbWlHRiQ2JVEldGRlZ0YnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy1JI21vR0YkNi5RKSZBc3NpZ247RicvRjNRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y9LyUpc3RyZXRjaHlHRj0vJSpzeW1tZXRyaWNHRj0vJShsYXJnZW9wR0Y9LyUubW92YWJsZWxpbWl0c0dGPS8lJ2FjY2VudEdGPS8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkwvJSllcXVhbGl0eUdGPS1JKG1mZW5jZWRHRiQ2Ji1GIzY8LUkjbW5HRiQ2JFEiNEYnRjktRjY2LlEiLEYnRjlGOy9GP0YxRkBGQkZERkZGSC9GS1EmMC4wZW1GJy9GTlEsMC4zMzMzMzMzZW1GJ0ZPLUZXNiRRIjZGJ0Y5RlotRlc2JFEiOEYnRjlGWi1GVzYkUSMxMEYnRjlGWi1GVzYkUSMxMkYnRjlGWi1GVzYkUSMxNkYnRjlGWi1GVzYkUSMyMEYnRjlGWi1GVzYkUSMyNEYnRjlGWi1GVzYkUSMyOEYnRjlGWi1GVzYkUSMzMkYnRjlGWi1GVzYkUSMzNkYnRjlGWi1GVzYkUSM0MEYnRjkvJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnLyUpcmVhZG9ubHlHRj1GOUY5LyUlb3BlbkdRJyZsc3FiO0YnLyUmY2xvc2VHUScmcnNxYjtGJ0Y5">LV9JLFR5cGVzZXR0aW5nRzYkJSpwcm90ZWN0ZWRHSShfc3lzbGliRzYiSSxtcHJpbnRzbGFzaEdGKDYkNyM+SSV0ZGVnR0YoNy4iIiUiIiciIikiIzUiIzciIzsiIz8iI0MiI0ciI0siI08iI1M3I0Yu</Equation></Text-field>
</Output>
<Output><Text-field style="Line Printed Output" layout="Line Printed Output">MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   1.312 14957244|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.015  36073| A := semi(A1);
  10 |    1   0.000  35435| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000   1682| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   4345| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.000      0| do
  23 |   21   0.000  73591|     do
  24 |   21   0.000  12679|         p := nextprime(p);
  25 |   21   0.000      0|         lcmintest := true;
  26 |   21   0.000      0|         for i to m do
  27 |  105   0.000   1710|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   21   0.000     84|     st := time();
  30 |   21   0.110 1978789|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   21   0.000    328|     pt := pt+time()-st;
  32 |   21   0.829 9490362|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   21   0.000    336|     pgcdtime := pgcdtime+time()-st;
  34 |   21   0.000     67|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   21   0.000   2922|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   21   0.000     84|     st := time();
  41 |   21   0.000   2234|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   21   0.046 247590|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   21   0.000    312|     lmt := lmt+time()-st;
  44 |   21   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   20   0.000    100|         summon := lmCp+minmon;
  51 |   20   0.000  57451|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   20   0.000  57620|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   20   0.000    240|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   20   0.000    347|             H := [op(H), Cp];
  59 |   20   0.000     80|             st := time();
  60 |   20   0.297 2236461|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   20   0.000    276|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   20   0.000    327|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   21   0.000     84|     st := time();
  64 |   21   0.000 630673|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   21   0.000    292|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   21   0.000     63|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2460|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     25|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.015  62101|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.000  19554|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     16|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   1.282 13882184|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.000  35435| A := semi(A1);
  10 |    1   0.000  35435| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.016      0| do
  23 |   21   0.016  73584|     do
  24 |   21   0.000   1818|         p := nextprime(p);
  25 |   21   0.000      0|         lcmintest := true;
  26 |   21   0.000      0|         for i to m do
  27 |  105   0.000   1749|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   21   0.000     84|     st := time();
  30 |   21   0.173 1977651|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   21   0.000    320|     pt := pt+time()-st;
  32 |   21   0.842 8435291|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   21   0.000    336|     pgcdtime := pgcdtime+time()-st;
  34 |   21   0.016     63|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   21   0.000   2352|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   21   0.000     84|     st := time();
  41 |   21   0.000   2184|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   21   0.000 247590|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   21   0.000    172|     lmt := lmt+time()-st;
  44 |   21   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   20   0.000    100|         summon := lmCp+minmon;
  51 |   20   0.000  57451|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   20   0.000  57620|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   20   0.000    240|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   20   0.000    347|             H := [op(H), Cp];
  59 |   20   0.000     80|             st := time();
  60 |   20   0.203 2234274|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   20   0.000    268|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   20   0.000    327|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   21   0.000     84|     st := time();
  64 |   21   0.016 629295|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   21   0.000    284|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   21   0.000     63|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2445|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     25|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.000  62101|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.000  19554|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     12|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   2.735 32545262|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.000  35435| A := semi(A1);
  10 |    1   0.000  35435| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.000      0| do
  23 |   24   0.047  84096|     do
  24 |   24   0.000   3988|         p := nextprime(p);
  25 |   24   0.000      0|         lcmintest := true;
  26 |   24   0.000      0|         for i to m do
  27 |  120   0.000   1961|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   24   0.000     96|     st := time();
  30 |   24   0.094 4356947|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   24   0.000    360|     pt := pt+time()-st;
  32 |   24   1.529 17477517|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   24   0.000    384|     pgcdtime := pgcdtime+time()-st;
  34 |   24   0.000     72|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   24   0.000   3168|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   24   0.000     96|     st := time();
  41 |   24   0.000   2496|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   24   0.047 674184|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   24   0.000    288|     lmt := lmt+time()-st;
  44 |   24   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   23   0.000   1127|         summon := lmCp+minmon;
  51 |   23   0.015  72482|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   23   0.000  85100|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   23   0.000    276|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   23   0.000    434|             H := [op(H), Cp];
  59 |   23   0.000     92|             st := time();
  60 |   23   0.955 7632318|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   23   0.000    348|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   23   0.000    411|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   24   0.000     96|     st := time();
  64 |   24   0.048 1966935|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   24   0.000    364|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   24   0.000     72|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2452|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.000  79562|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.000  23172|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     12|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   3.985 45626399|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.000  35435| A := semi(A1);
  10 |    1   0.000  35435| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.016   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.000      0| do
  23 |   22   0.000  77088|     do
  24 |   22   0.000   1914|         p := nextprime(p);
  25 |   22   0.000      0|         lcmintest := true;
  26 |   22   0.000      0|         for i to m do
  27 |  110   0.000   1806|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   22   0.000     88|     st := time();
  30 |   22   0.249 2072063|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   22   0.000    344|     pt := pt+time()-st;
  32 |   22   2.143 27146537|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   22   0.000    352|     pgcdtime := pgcdtime+time()-st;
  34 |   22   0.000     66|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   22   0.000   3278|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   22   0.000     88|     st := time();
  41 |   22   0.000   2288|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   22   0.110 1117427|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   22   0.000    328|     lmt := lmt+time()-st;
  44 |   22   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   21   0.000   1029|         summon := lmCp+minmon;
  51 |   21   0.000  70160|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   21   0.000 101745|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   21   0.000    252|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   21   0.000    375|             H := [op(H), Cp];
  59 |   21   0.000     84|             st := time();
  60 |   21   1.357 11606408|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   21   0.000    324|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   21   0.000    354|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   22   0.000     88|     st := time();
  64 |   22   0.094 3217945|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   22   0.000    340|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   22   0.000     66|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2453|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     30|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.000 105225|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.000  21506|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     12|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.016      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   2.047 21129166|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.000  67580| A := semi(A1);
  10 |    1   0.015  67580| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.000      0| do
  23 |   23   0.016  80592|     do
  24 |   23   0.000   2021|         p := nextprime(p);
  25 |   23   0.000      0|         lcmintest := true;
  26 |   23   0.000      0|         for i to m do
  27 |  115   0.000   1861|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   23   0.000     92|     st := time();
  30 |   23   0.286 4156974|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   23   0.000    368|     pt := pt+time()-st;
  32 |   23   1.343 12665114|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   23   0.000    368|     pgcdtime := pgcdtime+time()-st;
  34 |   23   0.000     69|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   23   0.000   2576|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   23   0.000     92|     st := time();
  41 |   23   0.000   2392|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   23   0.047 271170|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   23   0.000    328|     lmt := lmt+time()-st;
  44 |   23   0.015      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   22   0.000    110|         summon := lmCp+minmon;
  51 |   22   0.015  63174|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   22   0.000  63382|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   22   0.000    264|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   22   0.000    404|             H := [op(H), Cp];
  59 |   22   0.000     88|             st := time();
  60 |   22   0.294 2737345|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   22   0.000    340|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   22   0.000    382|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   23   0.000     92|     st := time();
  64 |   23   0.016 808327|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   23   0.000    356|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   23   0.000     69|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2431|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     40|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.000 101973|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.000  27734|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     12|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   2.172 21127034|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.000  67580| A := semi(A1);
  10 |    1   0.016  67580| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.000      0| do
  23 |   23   0.016  80592|     do
  24 |   23   0.000   2021|         p := nextprime(p);
  25 |   23   0.000      0|         lcmintest := true;
  26 |   23   0.000      0|         for i to m do
  27 |  115   0.000   1866|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   23   0.000     92|     st := time();
  30 |   23   0.269 4157228|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   23   0.000    360|     pt := pt+time()-st;
  32 |   23   1.477 12662891|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   23   0.000    368|     pgcdtime := pgcdtime+time()-st;
  34 |   23   0.000     69|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   23   0.000   2576|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   23   0.000     92|     st := time();
  41 |   23   0.000   2392|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   23   0.000 271170|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   23   0.000    188|     lmt := lmt+time()-st;
  44 |   23   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   22   0.000    110|         summon := lmCp+minmon;
  51 |   22   0.000  63191|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   22   0.000  63382|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   22   0.000    264|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   22   0.000    404|             H := [op(H), Cp];
  59 |   22   0.000     88|             st := time();
  60 |   22   0.363 2737345|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   22   0.000    316|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   22   0.000    382|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   23   0.000     92|     st := time();
  64 |   23   0.016 808327|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   23   0.000    332|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   23   0.000     69|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2438|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     40|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.015 101973|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.000  27734|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     16|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   5.343 58814420|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.015  67580| A := semi(A1);
  10 |    1   0.000  67580| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.000      0| do
  23 |   24   0.000  84096|     do
  24 |   24   0.000   2227|         p := nextprime(p);
  25 |   24   0.000      0|         lcmintest := true;
  26 |   24   0.000      0|         for i to m do
  27 |  120   0.000   1961|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   24   0.000     96|     st := time();
  30 |   24   0.315 4337712|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   24   0.000    384|     pt := pt+time()-st;
  32 |   24   3.156 34924014|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   24   0.000    384|     pgcdtime := pgcdtime+time()-st;
  34 |   24   0.000     72|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   24   0.000   3576|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   24   0.000     96|     st := time();
  41 |   24   0.000   2496|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   24   0.063 1219073|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   24   0.000    368|     lmt := lmt+time()-st;
  44 |   24   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   23   0.000   1127|         summon := lmCp+minmon;
  51 |   23   0.000  76806|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   23   0.000 111435|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   23   0.000    276|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   23   0.000    434|             H := [op(H), Cp];
  59 |   23   0.000     92|             st := time();
  60 |   23   1.701 14105162|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   23   0.000    364|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   23   0.000    411|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   24   0.000     96|     st := time();
  64 |   24   0.078 3616546|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   24   0.000    380|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   24   0.000     72|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2438|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.000 143310|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.015  40254|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     16|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  10.313 113055335|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.000  67580| A := semi(A1);
  10 |    1   0.000  67580| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.000      0| do
  23 |   22   0.016  77088|     do
  24 |   22   0.000   1914|         p := nextprime(p);
  25 |   22   0.000      0|         lcmintest := true;
  26 |   22   0.000      0|         for i to m do
  27 |  110   0.000   1831|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   22   0.000     88|     st := time();
  30 |   22   0.280 3976236|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   22   0.000    344|     pt := pt+time()-st;
  32 |   22   6.327 71654506|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   22   0.000    352|     pgcdtime := pgcdtime+time()-st;
  34 |   22   0.000     66|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   22   0.000   4026|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   22   0.000     88|     st := time();
  41 |   22   0.032   2288|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   22   0.139 2539724|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   22   0.000    352|     lmt := lmt+time()-st;
  44 |   22   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   21   0.000   1029|         summon := lmCp+minmon;
  51 |   21   0.016  78108|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   21   0.015 170373|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   21   0.000    252|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   21   0.000    375|             H := [op(H), Cp];
  59 |   21   0.000     84|             st := time();
  60 |   21   3.269 26800655|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   21   0.000    332|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   21   0.000    354|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   22   0.000     88|     st := time();
  64 |   22   0.203 7355933|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   22   0.000    348|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   22   0.000     66|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2446|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     30|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.016 215679|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.000  31638|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     16|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   3.234 31121403|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.000 111494| A := semi(A1);
  10 |    1   0.015 111494| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.000      0| do
  23 |   25   0.000  87600|     do
  24 |   25   0.000   2377|         p := nextprime(p);
  25 |   25   0.000      0|         lcmintest := true;
  26 |   25   0.000      0|         for i to m do
  27 |  125   0.000   2026|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   25   0.000    100|     st := time();
  30 |   25   0.581 7403144|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   25   0.000    400|     pt := pt+time()-st;
  32 |   25   2.122 18633719|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   25   0.000    400|     pgcdtime := pgcdtime+time()-st;
  34 |   25   0.000     75|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   25   0.016   2800|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   25   0.000    100|     st := time();
  41 |   25   0.000   2600|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   25   0.000 294750|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   25   0.000    204|     lmt := lmt+time()-st;
  44 |   25   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   24   0.000    120|         summon := lmCp+minmon;
  51 |   24   0.032  68931|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   24   0.000  69144|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   24   0.000    288|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   24   0.000    465|             H := [op(H), Cp];
  59 |   24   0.000     96|             st := time();
  60 |   24   0.421 3297487|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   24   0.000    372|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   24   0.000    441|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   25   0.000    100|     st := time();
  64 |   25   0.032 832133|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   25   0.000    388|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   25   0.000     75|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2445|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.015 156219|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.000  35914|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     16|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   4.078 41150220|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.000 111494| A := semi(A1);
  10 |    1   0.016 111494| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.000      0| do
  23 |   22   0.031  77088|     do
  24 |   22   0.000   1914|         p := nextprime(p);
  25 |   22   0.000      0|         lcmintest := true;
  26 |   22   0.000      0|         for i to m do
  27 |  110   0.000   1796|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   22   0.000     88|     st := time();
  30 |   22   0.423 6514244|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   22   0.000    352|     pt := pt+time()-st;
  32 |   22   2.765 25336435|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   22   0.000    352|     pgcdtime := pgcdtime+time()-st;
  34 |   22   0.000     66|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   22   0.000   2904|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   22   0.000     88|     st := time();
  41 |   22   0.015   2288|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   22   0.000 618015|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   22   0.000    208|     lmt := lmt+time()-st;
  44 |   22   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   21   0.000   1029|         summon := lmCp+minmon;
  51 |   21   0.000  66160|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   21   0.000  77700|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   21   0.000    252|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   21   0.000    375|             H := [op(H), Cp];
  59 |   21   0.000     84|             st := time();
  60 |   21   0.782 6281156|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   21   0.000    324|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   21   0.000    354|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   22   0.000     88|     st := time();
  64 |   22   0.031 1714530|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   22   0.000    340|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   22   0.000     66|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2445|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     25|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.000 172884|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.015  50100|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     16|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   7.656 83538911|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.016 111494| A := semi(A1);
  10 |    1   0.015 111494| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.000      0| do
  23 |   21   0.032  73584|     do
  24 |   21   0.000   1818|         p := nextprime(p);
  25 |   21   0.000      0|         lcmintest := true;
  26 |   21   0.000      0|         for i to m do
  27 |  105   0.000   1731|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   21   0.000     84|     st := time();
  30 |   21   0.532 6218650|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   21   0.000    336|     pt := pt+time()-st;
  32 |   21   4.622 53499318|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   21   0.000    336|     pgcdtime := pgcdtime+time()-st;
  34 |   21   0.000     63|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   21   0.000   3486|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   21   0.000     84|     st := time();
  41 |   21   0.016   2184|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   21   0.221 1678104|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   21   0.000    304|     lmt := lmt+time()-st;
  44 |   21   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   20   0.000    980|         summon := lmCp+minmon;
  51 |   20   0.000  70584|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   20   0.016 126320|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   20   0.000    240|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   20   0.000    347|             H := [op(H), Cp];
  59 |   20   0.000     80|             st := time();
  60 |   20   1.967 16608026|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   20   0.000    316|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   20   0.000    327|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   21   0.000     84|     st := time();
  64 |   21   0.204 4734874|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   21   0.000    332|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   21   0.000     63|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2453|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.000 224693|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.015  62620|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     16|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  15.953 177819599|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.016 111494| A := semi(A1);
  10 |    1   0.015 111494| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.000      0| do
  23 |   23   0.000  80592|     do
  24 |   23   0.000   2021|         p := nextprime(p);
  25 |   23   0.000      0|         lcmintest := true;
  26 |   23   0.000      0|         for i to m do
  27 |  115   0.000   1941|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   23   0.000     92|     st := time();
  30 |   23   0.486 6810600|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   23   0.000    368|     pt := pt+time()-st;
  32 |   23   9.219 115428173|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   23   0.000    368|     pgcdtime := pgcdtime+time()-st;
  34 |   23   0.000     69|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   23   0.015   4600|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   23   0.000     92|     st := time();
  41 |   23   0.000   2392|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   23   0.249 3620558|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   23   0.000    360|     lmt := lmt+time()-st;
  44 |   23   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   22   0.000   1078|         summon := lmCp+minmon;
  51 |   22   0.000  86034|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   22   0.016 225192|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   22   0.000    264|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   22   0.000    404|             H := [op(H), Cp];
  59 |   22   0.000     88|             st := time();
  60 |   22   5.718 40515714|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   22   0.000    348|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   22   0.000    382|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   23   0.000     92|     st := time();
  64 |   23   0.203 10440586|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   23   0.000    364|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   23   0.000     69|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2446|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.016 313818|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.000  54004|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     16|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   3.859 35456995|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.015 166376| A := semi(A1);
  10 |    1   0.016 166376| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.000      0| do
  23 |   22   0.016  77088|     do
  24 |   22   0.000   1914|         p := nextprime(p);
  25 |   22   0.000      0|         lcmintest := true;
  26 |   22   0.000      0|         for i to m do
  27 |  110   0.000   1791|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   22   0.000     88|     st := time();
  30 |   22   0.657 9685840|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   22   0.000    352|     pt := pt+time()-st;
  32 |   22   2.736 21509588|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   22   0.000    352|     pgcdtime := pgcdtime+time()-st;
  34 |   22   0.000     66|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   22   0.000   2464|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   22   0.000     88|     st := time();
  41 |   22   0.000   2288|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   22   0.016 259380|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   22   0.000    280|     lmt := lmt+time()-st;
  44 |   22   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   21   0.000    105|         summon := lmCp+minmon;
  51 |   21   0.000  60338|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   21   0.000  60501|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   21   0.000    252|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   21   0.000    375|             H := [op(H), Cp];
  59 |   21   0.000     84|             st := time();
  60 |   21   0.372 2479446|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   21   0.000    316|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   21   0.000    354|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   22   0.000     88|     st := time();
  64 |   22   0.016 703672|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   22   0.000    332|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   22   0.000     66|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2445|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     25|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.000 226689|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.015  44094|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     16|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   5.516 53629388|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.016 166376| A := semi(A1);
  10 |    1   0.016 166376| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.000      0| do
  23 |   23   0.030  80592|     do
  24 |   23   0.000   2021|         p := nextprime(p);
  25 |   23   0.000      0|         lcmintest := true;
  26 |   23   0.000      0|         for i to m do
  27 |  115   0.000   1881|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   23   0.000     92|     st := time();
  30 |   23   0.705 10126004|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   23   0.000    368|     pt := pt+time()-st;
  32 |   23   3.888 33182669|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   23   0.000    368|     pgcdtime := pgcdtime+time()-st;
  34 |   23   0.000     69|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   23   0.000   3036|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   23   0.000     92|     st := time();
  41 |   23   0.000   2392|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   23   0.032 646119|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   23   0.000    368|     lmt := lmt+time()-st;
  44 |   23   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   22   0.000   1078|         summon := lmCp+minmon;
  51 |   22   0.000  69321|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   22   0.000  81400|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   22   0.000    264|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   22   0.000    404|             H := [op(H), Cp];
  59 |   22   0.000     88|             st := time();
  60 |   22   0.782 6939129|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   22   0.000    324|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   22   0.000    382|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   23   0.000     92|     st := time();
  64 |   23   0.031 1847343|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   23   0.000    340|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   23   0.000     69|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2452|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.016 240813|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.000  63564|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     16|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  12.453 137260579|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.016 166376| A := semi(A1);
  10 |    1   0.015 166376| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.000      0| do
  23 |   22   0.030  77088|     do
  24 |   22   0.000   1914|         p := nextprime(p);
  25 |   22   0.000      0|         lcmintest := true;
  26 |   22   0.000      0|         for i to m do
  27 |  110   0.000   1841|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   22   0.000     88|     st := time();
  30 |   22   0.598 9685500|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   22   0.000    352|     pt := pt+time()-st;
  32 |   22   7.999 89975456|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   22   0.000    352|     pgcdtime := pgcdtime+time()-st;
  34 |   22   0.000     66|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   22   0.016   4026|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   22   0.000     88|     st := time();
  41 |   22   0.000   2288|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   22   0.172 2539750|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   22   0.000    352|     lmt := lmt+time()-st;
  44 |   22   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   21   0.000   1029|         summon := lmCp+minmon;
  51 |   21   0.016  78121|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   21   0.016 170373|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   21   0.000    252|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   21   0.000    375|             H := [op(H), Cp];
  59 |   21   0.000     84|             st := time();
  60 |   21   3.420 26793196|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   21   0.000    332|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   21   0.000    354|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   22   0.000     88|     st := time();
  64 |   22   0.124 7160965|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   22   0.000    348|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   22   0.000     66|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2439|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     35|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.016 336857|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.015  90270|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     16|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  27.531 304365520|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.016 166376| A := semi(A1);
  10 |    1   0.015 166376| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.000      0| do
  23 |   22   0.015  77088|     do
  24 |   22   0.000   1914|         p := nextprime(p);
  25 |   22   0.000      0|         lcmintest := true;
  26 |   22   0.000      0|         for i to m do
  27 |  110   0.000   1881|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   22   0.000     88|     st := time();
  30 |   22   0.644 9685500|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   22   0.000    352|     pt := pt+time()-st;
  32 |   22  17.280 209781742|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   22   0.000    352|     pgcdtime := pgcdtime+time()-st;
  34 |   22   0.000     66|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   22   0.000   5148|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   22   0.000     88|     st := time();
  41 |   22   0.015   2288|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   22   0.595 5734737|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   22   0.000    352|     lmt := lmt+time()-st;
  44 |   22   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   21   0.000   1029|         summon := lmCp+minmon;
  51 |   21   0.016  90069|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   21   0.032 324660|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   21   0.000    252|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   21   0.000    375|             H := [op(H), Cp];
  59 |   21   0.000     84|             st := time();
  60 |   21   8.466 60957660|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   21   0.000    332|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   21   0.000    354|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   22   0.000     88|     st := time();
  64 |   22   0.422 16789545|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   22   0.000    348|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   22   0.000     66|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2453|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     40|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.015 500915|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.000  69420|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     16|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   6.063 52273511|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.032 232226| A := semi(A1);
  10 |    1   0.015 232226| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.000      0| do
  23 |   25   0.080  87600|     do
  24 |   25   0.000   2257|         p := nextprime(p);
  25 |   25   0.000      0|         lcmintest := true;
  26 |   25   0.000      0|         for i to m do
  27 |  125   0.000   2041|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   25   0.000    100|     st := time();
  30 |   25   1.123 15329890|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   25   0.000    400|     pt := pt+time()-st;
  32 |   25   4.311 31445382|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   25   0.000    400|     pgcdtime := pgcdtime+time()-st;
  34 |   25   0.000     75|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   25   0.000   2800|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   25   0.000    100|     st := time();
  41 |   25   0.000   2600|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   25   0.016 294750|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   25   0.000    240|     lmt := lmt+time()-st;
  44 |   25   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   24   0.000    120|         summon := lmCp+minmon;
  51 |   24   0.000  68982|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   24   0.000  69144|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   24   0.000    288|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   24   0.000    465|             H := [op(H), Cp];
  59 |   24   0.000     96|             st := time();
  60 |   24   0.455 3301080|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   24   0.000    340|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   24   0.000    441|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   25   0.000    100|     st := time();
  64 |   25   0.015 831043|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   25   0.000    356|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   25   0.000     75|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2431|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     35|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.016 309672|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.000  52274|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     16|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   8.500 85468084|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.031 232226| A := semi(A1);
  10 |    1   0.016 232226| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.000      0| do
  23 |   22   0.031  77088|     do
  24 |   22   0.000   1914|         p := nextprime(p);
  25 |   22   0.000      0|         lcmintest := true;
  26 |   22   0.000      0|         for i to m do
  27 |  110   0.000   1811|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   22   0.000     88|     st := time();
  30 |   22   0.925 13490258|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   22   0.000    352|     pt := pt+time()-st;
  32 |   22   5.985 54932663|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   22   0.000    352|     pgcdtime := pgcdtime+time()-st;
  34 |   22   0.000     66|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   22   0.000   3278|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   22   0.000     88|     st := time();
  41 |   22   0.000   2288|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   22   0.076 1117173|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   22   0.000    288|     lmt := lmt+time()-st;
  44 |   22   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   21   0.000   1029|         summon := lmCp+minmon;
  51 |   21   0.000  70147|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   21   0.000 101745|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   21   0.000    252|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   21   0.000    375|             H := [op(H), Cp];
  59 |   21   0.000     84|             st := time();
  60 |   21   1.373 11602285|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   21   0.000    316|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   21   0.000    354|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   22   0.000     88|     st := time();
  64 |   22   0.047 3139837|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   22   0.000    332|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   22   0.000     66|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2432|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.016 356583|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.000  96498|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     16|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  19.437 211661452|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.015 232226| A := semi(A1);
  10 |    1   0.032 232226| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.000      0| do
  23 |   23   0.016  80592|     do
  24 |   23   0.000   2021|         p := nextprime(p);
  25 |   23   0.000      0|         lcmintest := true;
  26 |   23   0.000      0|         for i to m do
  27 |  115   0.000   1951|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   23   0.000     92|     st := time();
  30 |   23   1.017 14103440|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   23   0.000    368|     pt := pt+time()-st;
  32 |   23  12.154 141130405|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   23   0.000    368|     pgcdtime := pgcdtime+time()-st;
  34 |   23   0.000     69|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   23   0.016   4600|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   23   0.000     92|     st := time();
  41 |   23   0.016   2392|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   23   0.315 3620805|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   23   0.000    360|     lmt := lmt+time()-st;
  44 |   23   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   22   0.000   1078|         summon := lmCp+minmon;
  51 |   22   0.000  86047|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   22   0.015 225192|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   22   0.000    264|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   22   0.000    404|             H := [op(H), Cp];
  59 |   22   0.000     88|             st := time();
  60 |   22   5.560 40513088|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   22   0.000    348|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   22   0.000    382|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   23   0.000     92|     st := time();
  64 |   23   0.250 10824958|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   23   0.000    364|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   23   0.000     69|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2446|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.016 467919|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.015 123204|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     16|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  34.062 380998733|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.031 232226| A := semi(A1);
  10 |    1   0.016 232226| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.000      0| do
  23 |   21   0.016  73584|     do
  24 |   21   0.000   1818|         p := nextprime(p);
  25 |   21   0.000      0|         lcmintest := true;
  26 |   21   0.000      0|         for i to m do
  27 |  105   0.000   1796|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   21   0.000     84|     st := time();
  30 |   21   0.950 12877076|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   21   0.000    336|     pt := pt+time()-st;
  32 |   21  22.176 272690252|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   21   0.000    336|     pgcdtime := pgcdtime+time()-st;
  34 |   21   0.000     63|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   21   0.031   5271|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   21   0.000     84|     st := time();
  41 |   21   0.016   2184|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   21   0.513 6759994|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   21   0.000    336|     lmt := lmt+time()-st;
  44 |   21   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   20   0.000    980|         summon := lmCp+minmon;
  51 |   20   0.000  89540|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   20   0.016 371220|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   20   0.000    240|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   20   0.000    347|             H := [op(H), Cp];
  59 |   20   0.000     80|             st := time();
  60 |   20   9.829 67900592|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   20   0.000    316|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   20   0.000    327|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   21   0.000     84|     st := time();
  64 |   21   0.437 18998937|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   21   0.000    332|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   21   0.000     63|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2446|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.031 649707|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.000 102354|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     16|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1   7.469 67448303|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.094 397086| A := semi(A1);
  10 |    1   0.031 396830| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.000      0| do
  23 |   21   0.109  73584|     do
  24 |   21   0.000   1818|         p := nextprime(p);
  25 |   21   0.000      0|         lcmintest := true;
  26 |   21   0.000      0|         for i to m do
  27 |  105   0.000   1711|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   21   0.000     84|     st := time();
  30 |   21   1.519 21953691|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   21   0.000    336|     pt := pt+time()-st;
  32 |   21   5.311 40739829|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   21   0.000    336|     pgcdtime := pgcdtime+time()-st;
  34 |   21   0.000     63|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   21   0.000   2352|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   21   0.000     84|     st := time();
  41 |   21   0.000   2184|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   21   0.032 247590|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   21   0.000    336|     lmt := lmt+time()-st;
  44 |   21   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   20   0.000    100|         summon := lmCp+minmon;
  51 |   20   0.000  57468|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   20   0.016  57620|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   20   0.000    240|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   20   0.000    347|             H := [op(H), Cp];
  59 |   20   0.000     80|             st := time();
  60 |   20   0.201 2235419|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   20   0.000    276|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   20   0.000    327|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   21   0.000     84|     st := time();
  64 |   21   0.125 652768|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   21   0.000    292|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   21   0.000     63|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2453|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.031 550716|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.000  68634|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     16|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  13.610 142922523|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.016     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.125 397086| A := semi(A1);
  10 |    1   0.031 396830| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.000      0| do
  23 |   21   0.031  73584|     do
  24 |   21   0.000   1818|         p := nextprime(p);
  25 |   21   0.000      0|         lcmintest := true;
  26 |   21   0.000      0|         for i to m do
  27 |  105   0.000   1736|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   21   0.000     84|     st := time();
  30 |   21   1.518 21953612|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   21   0.000    336|     pt := pt+time()-st;
  32 |   21   9.672 96076926|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   21   0.000    336|     pgcdtime := pgcdtime+time()-st;
  34 |   21   0.000     63|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   21   0.000   3486|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   21   0.000     84|     st := time();
  41 |   21   0.016   2184|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   21   0.124 1677850|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   21   0.000    328|     lmt := lmt+time()-st;
  44 |   21   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   20   0.000    980|         summon := lmCp+minmon;
  51 |   20   0.000  70610|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   20   0.000 126320|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   20   0.000    240|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   20   0.000    347|             H := [op(H), Cp];
  59 |   20   0.000     80|             st := time();
  60 |   20   1.967 16610729|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   20   0.000    308|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   20   0.000    327|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   21   0.000     84|     st := time();
  64 |   21   0.063 4739292|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   21   0.000    324|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   21   0.000     63|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2460|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.031 621766|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.016 158748|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     16|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  30.172 332948524|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.047 396830| A := semi(A1);
  10 |    1   0.031 396830| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.000      0| do
  23 |   20   0.077  70080|     do
  24 |   20   0.000   1733|         p := nextprime(p);
  25 |   20   0.000      0|         lcmintest := true;
  26 |   20   0.000      0|         for i to m do
  27 |  100   0.016   1711|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   20   0.000     80|     st := time();
  30 |   20   1.642 20908715|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   20   0.000    320|     pt := pt+time()-st;
  32 |   20  20.171 240867610|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   20   0.000    320|     pgcdtime := pgcdtime+time()-st;
  34 |   20   0.000     60|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   20   0.000   4680|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   20   0.000     80|     st := time();
  41 |   20   0.000   2080|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   20   0.344 5212913|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   20   0.000    320|     lmt := lmt+time()-st;
  44 |   20   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   19   0.000    931|         summon := lmCp+minmon;
  51 |   19   0.000  81491|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   19   0.047 293740|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   19   0.000    228|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   19   0.000    320|             H := [op(H), Cp];
  59 |   19   0.000     76|             st := time();
  60 |   19   7.344 49245285|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   19   0.016    300|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   19   0.000    301|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   20   0.000     80|     st := time();
  64 |   20   0.406 14458513|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   20   0.000    316|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   20   0.000     60|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2453|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.031 791642|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.000 204924|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     16|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  87.359 876663023|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.015     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.032 396830| A := semi(A1);
  10 |    1   0.031 396830| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.000      0| do
  23 |   24   0.138  84096|     do
  24 |   24   0.000   2227|         p := nextprime(p);
  25 |   24   0.000      0|         lcmintest := true;
  26 |   24   0.000      0|         for i to m do
  27 |  120   0.000   2051|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   24   0.000     96|     st := time();
  30 |   24   1.937 25090060|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   24   0.000    384|     pt := pt+time()-st;
  32 |   24  54.111 640435088|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   24   0.000    384|     pgcdtime := pgcdtime+time()-st;
  34 |   24   0.000     72|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   24   0.015   7248|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   24   0.000     96|     st := time();
  41 |   24   0.015   2496|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   24   0.858 13063352|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   24   0.000    384|     lmt := lmt+time()-st;
  44 |   24   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   23   0.000   1127|         summon := lmCp+minmon;
  51 |   23   0.016 115943|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   23   0.095 685860|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   23   0.000    276|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   23   0.000    434|             H := [op(H), Cp];
  59 |   23   0.000     92|             st := time();
  60 |   23  29.065 155381972|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   23   0.000    364|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   23   0.000    411|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   24   0.000     96|     st := time();
  64 |   24   0.969 39677785|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   24   0.000    380|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   24   0.000     72|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2453|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.047 1144006|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.015 166556|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     16|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  11.640 101769725|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.015     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.047 605306| A := semi(A1);
  10 |    1   0.063 605306| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.000      0| do
  23 |   22   0.110  77088|     do
  24 |   22   0.000   1914|         p := nextprime(p);
  25 |   22   0.000      0|         lcmintest := true;
  26 |   22   0.000      0|         for i to m do
  27 |  110   0.000   1796|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   22   0.000     88|     st := time();
  30 |   22   2.638 35041341|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   22   0.000    352|     pt := pt+time()-st;
  32 |   22   8.469 60934262|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   22   0.000    352|     pgcdtime := pgcdtime+time()-st;
  34 |   22   0.000     66|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   22   0.000   2464|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   22   0.000     88|     st := time();
  41 |   22   0.000   2288|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   22   0.016 259380|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   22   0.000    264|     lmt := lmt+time()-st;
  44 |   22   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   21   0.000    105|         summon := lmCp+minmon;
  51 |   21   0.000  60372|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   21   0.000  60501|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   21   0.000    252|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   21   0.000    375|             H := [op(H), Cp];
  59 |   21   0.000     84|             st := time();
  60 |   21   0.236 2480607|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   21   0.000    316|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   21   0.000    354|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   22   0.000     88|     st := time();
  64 |   22   0.015 678533|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   22   0.000    332|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   22   0.000     66|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2442|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.031 864447|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.000  84994|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     16|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  23.735 257574017|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.016     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.047 605306| A := semi(A1);
  10 |    1   0.062 605306| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.000      0| do
  23 |   23   0.078  80592|     do
  24 |   23   0.000   2021|         p := nextprime(p);
  25 |   23   0.000      0|         lcmintest := true;
  26 |   23   0.000      0|         for i to m do
  27 |  115   0.000   1911|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   23   0.000     92|     st := time();
  30 |   23   3.062 36634513|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   23   0.000    368|     pt := pt+time()-st;
  32 |   23  16.175 178237954|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   23   0.000    368|     pgcdtime := pgcdtime+time()-st;
  34 |   23   0.000     69|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   23   0.000   4209|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   23   0.000     92|     st := time();
  41 |   23   0.000   2392|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   23   0.329 2655433|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   23   0.000    360|     lmt := lmt+time()-st;
  44 |   23   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   22   0.000   1078|         summon := lmCp+minmon;
  51 |   22   0.015  81807|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   22   0.047 178486|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   22   0.000    264|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   22   0.000    404|             H := [op(H), Cp];
  59 |   22   0.000     88|             st := time();
  60 |   22   3.591 29600940|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   22   0.000    352|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   22   0.000    382|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   23   0.000     92|     st := time();
  64 |   23   0.266 7673585|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   23   0.000    368|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   23   0.000     69|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2446|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.031 962318|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.016 236850|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     16|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  58.640 656533796|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.000     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.062 605306| A := semi(A1);
  10 |    1   0.047 605306| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.015      0| do
  23 |   23   0.063  80592|     do
  24 |   23   0.000   2021|         p := nextprime(p);
  25 |   23   0.000      0|         lcmintest := true;
  26 |   23   0.000      0|         for i to m do
  27 |  115   0.000   1966|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   23   0.000     92|     st := time();
  30 |   23   2.657 36633504|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   23   0.000    368|     pt := pt+time()-st;
  32 |   23  40.515 480507056|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   23   0.000    368|     pgcdtime := pgcdtime+time()-st;
  34 |   23   0.000     69|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   23   0.031   6164|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   23   0.000     92|     st := time();
  41 |   23   0.000   2392|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   23   0.764 8962026|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   23   0.000    368|     lmt := lmt+time()-st;
  44 |   23   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   22   0.000   1078|         summon := lmCp+minmon;
  51 |   22   0.000 102630|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   22   0.047 483736|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   22   0.000    264|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   22   0.000    404|             H := [op(H), Cp];
  59 |   22   0.000     88|             st := time();
  60 |   22  13.549 100905896|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   22   0.000    348|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   22   0.000    382|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   23   0.000     92|     st := time();
  64 |   23   0.812 26020040|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   23   0.000    364|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   23   0.000     69|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2449|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.016    295|         do
  71 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.047 1296984|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.015 307780|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     16|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    2 134.828 1427287132|
   1 |    2   0.000      0| timings := true;
   2 |    2   0.000      8| tt := time();
   3 |    2   0.000      0| pt := 0;
   4 |    2   0.000      0| lmt := 0;
   5 |    2   0.000      0| pgcdtime := 0;
   6 |    2   0.000      0| CRTRNRtime := 0;
   7 |    2   0.000      0| divtime := 0;
   8 |    2   0.030    146| A1, B1, ring := ConvRing(A0,B0);
   9 |    2   0.125 1462960| A := semi(A1);
  10 |    2   0.142 1462960| B := semi(B1);
  11 |    2   0.000      8| Char, X, E := op(ring);
  12 |    2   0.000      0| n := nops(X);
  13 |    2   0.000      0| m := nops(E);
  14 |    2   0.000      0| k := n-m;
  15 |    2   0.000     16| Xpoly := X[1 .. k];
  16 |    2   0.000     42| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    2   0.000   1462| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    2   0.000   4568| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    2   0.000      0| H := [];
  20 |    2   0.000      0| p := 2147483648;
  21 |    2   0.000      0| Np := [];
  22 |    2   0.000      0| do
  23 |   43   0.174 150672|     do
  24 |   43   0.000   3732|         p := nextprime(p);
  25 |   43   0.000      0|         lcmintest := true;
  26 |   43   0.000      0|         for i to m do
  27 |  215   0.000   3607|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   43   0.000    172|     st := time();
  30 |   43   6.440 82402015|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   43   0.000    688|     pt := pt+time()-st;
  32 |   43  95.666 1125245424|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   43   0.000    688|     pgcdtime := pgcdtime+time()-st;
  34 |   43   0.000    129|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   43   0.031  10118|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   43   0.000    172|     st := time();
  41 |   43   0.048   4472|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   43   1.469 18387032|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   43   0.000    544|     lmt := lmt+time()-st;
  44 |   43   0.000      0|     if not assigned(minmon) then
  45 |    2   0.000      0|         CRT := Cp;
  46 |    2   0.000      0|         minmon := lmCp;
  47 |    2   0.000      0|         summon := minmon;
  48 |    2   0.000      0|         least := minmon;
  49 |    2   0.000      8|         H := [Cp]
                                else
  50 |   41   0.000   1129|         summon := lmCp+minmon;
  51 |   41   0.000 175207|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   41   0.141 981893|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   41   0.000    492|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   41   0.000    722|             H := [op(H), Cp];
  59 |   41   0.000    164|             st := time();
  60 |   41  30.468 194883445|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   40   0.000    580|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   40   0.000    654|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   42   0.000    168|     st := time();
  64 |   42   0.047 701760|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   42   0.000    612|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   42   0.000    126|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2445|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     30|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.047 1294355|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.000 101354|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     16|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  33.875 360100292|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.015     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.079 857654| A := semi(A1);
  10 |    1   0.078 857654| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.000      0| do
  23 |   22   0.139  77088|     do
  24 |   22   0.000   1914|         p := nextprime(p);
  25 |   22   0.000      0|         lcmintest := true;
  26 |   22   0.000      0|         for i to m do
  27 |  110   0.000   1851|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   22   0.000     88|     st := time();
  30 |   22   3.765 49616238|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   22   0.000    352|     pt := pt+time()-st;
  32 |   22  24.831 256411990|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   22   0.000    352|     pgcdtime := pgcdtime+time()-st;
  34 |   22   0.000     66|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   22   0.031   4400|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   22   0.000     88|     st := time();
  41 |   22   0.000   2288|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   22   0.248 3463156|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   22   0.000    336|     lmt := lmt+time()-st;
  44 |   22   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   21   0.000   1029|         summon := lmCp+minmon;
  51 |   21   0.000  82095|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   21   0.000 214956|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   21   0.000    252|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   21   0.000    375|             H := [op(H), Cp];
  59 |   21   0.000     84|             st := time();
  60 |   21   4.455 36667550|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   21   0.000    332|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   21   0.000    354|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   22   0.000     88|     st := time();
  64 |   22   0.171 10072421|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   22   0.000    348|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   22   0.000     66|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2439|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.047 1428082|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.016 330804|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     16|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

MGCD2
MGCD2 := proc(A0, B0, T::anything := NULL)
local A, B, ring, A1, B1, Char, E, X, Xpoly, cc, i, m, n, Xmin, conta, contb, k, 
  LCap, LCbp, lmap, lmbp, minmon, H, prod, p, Ap, Bp, Cp, lcCp, lmCp, least, 
  CRT, H2, test1, MP, test2, summon, timings, irat, M, gama, gamma, phimatrix,
  invphimatrix, lcmintest, xx, yy, ca, cb, nca, ncb, C, counter, j, s, nfac, 
  fac, ss, l, LA, Rand, ZD, L, AL, BL, GCDL, wt, LCH2, slc, randfunction, 
  minpolys, st, tt, pt, laminpolytime, pgcdtime, CRTRNRtime, phigammatime, lmt
  , Result, divtime, Np;
     |Calls Seconds  Words|
PROC |    1  90.219 1012350814|
   1 |    1   0.000      0| timings := true;
   2 |    1   0.000      4| tt := time();
   3 |    1   0.000      0| pt := 0;
   4 |    1   0.000      0| lmt := 0;
   5 |    1   0.000      0| pgcdtime := 0;
   6 |    1   0.000      0| CRTRNRtime := 0;
   7 |    1   0.000      0| divtime := 0;
   8 |    1   0.016     73| A1, B1, ring := ConvRing(A0,B0);
   9 |    1   0.078 857654| A := semi(A1);
  10 |    1   0.078 857654| B := semi(B1);
  11 |    1   0.000      4| Char, X, E := op(ring);
  12 |    1   0.000      0| n := nops(X);
  13 |    1   0.000      0| m := nops(E);
  14 |    1   0.000      0| k := n-m;
  15 |    1   0.000      8| Xpoly := X[1 .. k];
  16 |    1   0.000     21| Xmin := [seq(X[i],i = nops(X) .. nops(Xpoly)+1,-1)
                              ];
  17 |    1   0.000    731| MP := [seq(Algebraic:-RecursiveDensePolynomials:-
                              getalgext(ring,-i),i = 1 .. m)];
  18 |    1   0.000   2284| minpolys := map(convert,MP,POLYNOMIAL);
  19 |    1   0.000      0| H := [];
  20 |    1   0.000      0| p := 2147483648;
  21 |    1   0.000      0| Np := [];
  22 |    1   0.000      0| do
  23 |   23   0.078  80592|     do
  24 |   23   0.000   2021|         p := nextprime(p);
  25 |   23   0.000      0|         lcmintest := true;
  26 |   23   0.000      0|         for i to m do
  27 |  115   0.000   1966|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false
                                        end if
                                    end do
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  29 |   23   0.000     92|     st := time();
  30 |   23   4.562 51910789|     Ap, Bp := Algebraic:-RecursiveDensePolynomials
                                  :-phirpoly(A,p), Algebraic:-
                                  RecursiveDensePolynomials:-phirpoly(B,p);
  31 |   23   0.000    368|     pt := pt+time()-st;
  32 |   23  62.983 765150019|     Cp := traperror(PGCDAlg(Ap,Bp,p));
  33 |   23   0.000    368|     pgcdtime := pgcdtime+time()-st;
  34 |   23   0.000     69|     if Cp = lasterror and nops([Cp]) = 2 and
<Font encoding="UTF-8">                                [Cp][1] = &quot;inverse does not exist\134n&quot; then
</Font>  35 |    0   0.000      0|         ZD := Cp[2];
  36 |    0   0.000      0|         next
                                end if;
  37 |   23   0.000   6946|     if Algebraic:-RecursiveDensePolynomials:-
                                  tdegrpoly(Cp) = 0 then
  38 |    0   0.000      0|         printf(&quot;Cp=%a is a constant&quot;,Cp);
  39 |    0   0.000      0|         return Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(1,X)
                                end if;
  40 |   23   0.000     92|     st := time();
  41 |   23   0.048   2392|     lcCp := Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(Cp,Xpoly);
  42 |   23   0.829 12518972|     lmCp := Algebraic:-RecursiveDensePolynomials:-
                                  rpoly(lmrpoly(Cp,Xpoly[1 .. k-1],X));
  43 |   23   0.000    368|     lmt := lmt+time()-st;
  44 |   23   0.000      0|     if not assigned(minmon) then
  45 |    1   0.000      0|         CRT := Cp;
  46 |    1   0.000      0|         minmon := lmCp;
  47 |    1   0.000      0|         summon := minmon;
  48 |    1   0.000      0|         least := minmon;
  49 |    1   0.000      4|         H := [Cp]
                                else
  50 |   22   0.000   1078|         summon := lmCp+minmon;
  51 |   22   0.000 110902|         least := Algebraic:-
                                      RecursiveDensePolynomials:-rpoly(tmrpoly
                                      (Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(summon,X),Xpoly,X));
  52 |   22   0.109 656040|         Cp := Algebraic:-RecursiveDensePolynomials
                                      :-scarpoly(Algebraic:-
                                      RecursiveDensePolynomials:-invrpoly(lcCp
                                      ),Cp);
  53 |   22   0.000    264|         if lmCp = least and minmon &lt;&gt; least then
  54 |    0   0.000      0|             H := [Cp];
  55 |    0   0.000      0|             CRT := Cp;
  56 |    0   0.000      0|             minmon := least;
  57 |    0   0.000      0|             Np := [p]
                                    elif lmCp = least and minmon = least then
  58 |   22   0.000    404|             H := [op(H), Cp];
  59 |   22   0.000     88|             st := time();
  60 |   22  20.297 141160276|             CRT := Algebraic:-
                                          RecursiveDensePolynomials:-
                                          ichremrpoly(map(Algebraic:-
                                          RecursiveDensePolynomials:-
                                          retextsrpoly,H));
  61 |   22   0.000    348|             CRTRNRtime := CRTRNRtime+time()-st;
  62 |   22   0.000    382|             Np := [op(Np), p]
                                    end if
                                end if;
  63 |   23   0.000     92|     st := time();
  64 |   23   1.047 36702521|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  65 |   23   0.000    364|     CRTRNRtime := CRTRNRtime+time()-st;
  66 |   23   0.000     69|     if irat &lt;&gt; FAIL then
  67 |    1   0.000     12|         H2 := subsop(1 = ring,irat);
  68 |    1   0.000   2446|         randfunction := rand(p);
  69 |    1   0.000      4|         st := time();
  70 |    1   0.000    295|         do
  71 |    1   0.000     20|             L := {seq(Xpoly[i] = randfunction(),i
                                          = 2 .. k)};
  72 |    1   0.063 1889904|             AL, BL, GCDL := Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(A,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(B,L),p), Algebraic:-
                                          RecursiveDensePolynomials:-phirpoly(
                                          Algebraic:-RecursiveDensePolynomials
                                          :-evalrpoly(H2,L),p)
                                    until Algebraic:-RecursiveDensePolynomials:-
                                      degrpoly(GCDL,Xpoly[1]) = Algebraic:-
                                      RecursiveDensePolynomials:-degrpoly(H2,
                                      Xpoly[1]);
  73 |    1   0.031 431772|         if Algebraic:-
                                      RecursiveDensePolynomials:-
                                      divrpoly(AL,GCDL) and Algebraic
                                      :-RecursiveDensePolynomials:-
                                      divrpoly(BL,GCDL) then
  74 |    1   0.000     16|             divtime := divtime+time()-st;
  75 |    1   0.000     12|             tt := time()-tt;
  76 |    1   0.000      9|             if timings = true and T &lt;&gt; NULL then
<Font encoding="UTF-8">  77 |    0   0.000      0|                 printf(&quot;MGCD: time=%.3f Reduce mod\134
                                               p=%.3f  PGCDAlg=%.3f lm=%.3f  C\134
                                              RT and RNR=%.3f Division test=%.\134
                                              3f\134n&quot;,tt,pt,pgcdtime,lmt,
</Font>                                              phigammatime,CRTRNRtime,divtime)
                                        end if;
  78 |    1   0.000      5|             return [H2, nops(Np)]
                                    end if
                                end if
                            end do
end proc

</Text-field>
</Output>
</Group>
<Group hide-input="false" labelreference="L704" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font opaque="true" size="16" background="[255,255,153]" foreground="[0,0,255]">#3 </Font><Font opaque="true" background="[255,255,153]" foreground="[0,0,128]">Degree of the field is in [4,8,12,16,24,32,64,72] with max number of extensions
#numext will be chosen to be the maximum</Font>
dF:<Font opaque="true" foreground="[128,0,0]">=[4,8,12,16,24,32,64,72];
</Font>R:=<Font foreground="[128,0,0]">Benchmain(flagalg,2</Font>,24,12,dF,numext,0);<Font opaque="true" foreground="[128,0,0]">
</Font>Export(R,&quot;MGCD2.xls&quot;,&quot;dF&quot;);<Font opaque="true" foreground="[128,0,0]">
</Font></Text-field>
</Input>
</Group>
<Group hide-input="false" labelreference="L706" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font opaque="true" size="16" background="[255,255,153]" foreground="[0,0,255]">#4 </Font><Font opaque="true" background="[255,255,153]" foreground="[0,0,128]">Number of extensions for a field of degree 64 is changing from 1..6 
</Font>R:=<Font foreground="[128,0,0]">Benchmain(flagalg,2</Font>,24,12,32,[seq(1..5)],0);
Export(R,&quot;MGCD2.xls&quot;,&quot;#exts&quot;);</Text-field>
</Input>
</Group>
<Group hide-input="false" labelreference="L708" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
</Worksheet>