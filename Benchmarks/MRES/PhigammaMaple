#The isomorphism phi
#Let m=[m1(z1),m2(z2),..,mn(zn)] be the list of minimal polynomials in maple version.
#To build the ring of Q[z1,..zn]/<m1..mn> in RECDEN format,we need to present m2 as a polynomial
#over Q[z1]/<m1>, m3 as a polynomial over Q[z1,z2]/<m1,m2>,..,and m_n as a polynomial 
#over Q[z1,z2,..z_(n-1)]/<m1,m2,..,m_(n-1)>

phiminpoly:=proc(m,Xmin1,p) uses RDP=Algebraic:-RecursiveDensePolynomials,  LT=ListTools;
local n,M,i,Xmin;
   n:=nops(m);
   M:=[seq(1..n)];
   Xmin:=LT:-Reverse(Xmin1);
   M[1]:=RDP:-rpoly(m[1],Xmin[n]);
   for i from 2 to n do
      Xmin[-i..n]; 
	  m[1..i-1];
      M[i]:=RDP:-phirpoly(RDP:-rpoly(m[i],Xmin[-i..n],m[1..i-1]),p);
      getring(M[i]);
od;
return(M);
end:
with(ListTools):
with(PolynomialTools):
with(ArrayTools):
with(RandomTools):
#phi : L=Q(a1,..an)---->K=Q(gamma) is an isomorhism from Q[x1,..xn]/<m1,..mn> to Q[z]/<m(z)>. If  we want to call phi, then flag:=1 else if we want to call phi^(-1) then flag:=-1 
#X is the list of minimal polynomials' variables 
#If we call phi then the minpoly of the single extension is w.r.t Z:=op(indets(M)
#If we call phi^(-1) then we need to have the variable of the single extension
#Inputs: the polynomial f1, m=[m1,..mn]=list of minimal polynomials from Q[x1,..xn]/<m1,..mn>,Xmin=minimal polynomials' variables,  Xpoly=polynomial's variables, flag=1 or -1, gama,M,A,Ainv= The out puts of LAMinpoly
Phi:=proc(f1,m,Xmin,Xpoly,flag,M,A,Ainv,p)  uses RDP=Algebraic:-RecursiveDensePolynomials, LA=LinearAlgebra;
   local npmin,n,Z,deg,d,monombasis,F,final,newf,i,basis2,f,fmin,Ringfmin,Ring,R1,R2,R3,R33,Rfinal,R, phimin,XT,Xmin1,Rf,newvar, finalf;
        #The variable of the single extension's minimal polynomial
        Z:=op(indets(M));
        Ring:=getring(f1);
        #The characteristic of the field
        R1:=op(1,Ring);
        n:=nops(m); #nops(m)=nops(X)
        deg:=[seq(degree(m[i],Xmin[i]),i=1..n)];
        d:=degree(M);   #d:=mul(deg[i],i=1..n);
        monombasis:= Basemaker(Xmin,deg); #set it as an input
        f:=Expand(RDP:-rpoly(f1)) mod p;
        if flag=1 then #we want to calculate Phi(f) so f is in L and we need Ainv 
           R2:=[op(Xpoly),Z];
           #Get the RECDEN format of the minimal polynomial M
           fmin:=RDP:-phirpoly(RDP:-phirpoly(RDP:-rpoly(1,Z),RDP:-rpoly(M,[Z])),p); #Make the input M as RECDEN
           Ringfmin:=getring(fmin); 
           #This is the Minpoly of single extension in recden version [[],[],[]]
           R33:=[op(1,op(3,Ringfmin))];
           #The ring of single extension is Rfinal
           Rfinal:=[p,R2,R33];
           F:= Monomlist(f,monombasis,Xmin);
           final:=Ainv.F mod p;
           #write final as a polyomial w.r.t Z in Q[Z]/<m(Z)> 
           newf:=add(final[i]*Z^(i-1),i=1...d);
           return RDP:-rpoly(newf,Rfinal); #It is costly to convert
       elif flag=-1 then #We want to call phi^(-1)
#Note: Every two bases of a vector space have the same cardinality. Hence, if the base of Q[x,y]/<m1,m2> has d items then the basis of Q[z]/<m(z)> has d items too. Remember these two vector spaces are isomorphic.
#When we call phi^(-1) we have a polynomial over Q[Z]/<m(Z)> and we want to map it to the corresponding polynomial in Q[x,y]/<m1,m2>
# write f w.r.t the basis ord:=[1,Z,Z^2,..,Z^(d-1)] of Q[Z]/<m(Z)> where deg(M(Z))=d
          basis2:=Array(1..d);
          for i to d do
             basis2[i]:=Z^(i-1); #A basis for the single extension Q[Z]/<M(Z)>
          od;
          F:=Monomlist(f,basis2,Z); #The coordinate of f relative to basis2
          final:=A.F mod p;
          #newf:=Expand(RED((add(final[i]*monombasis[i],i=1..d)),m,Xmin)) mod p; #it's in Q[x,y]/<m1,m2>
		  add(final[i]*monombasis[i],i=1..d);
		  Xmin1:= [ seq( Xmin[-i], i=1..nops(Xmin) ) ]; #Reverse did not work here:(
		  newvar:=[op(Xpoly),op(Xmin1)]; #The variables [Xpoly,Xmin]
          newf:=RDP:-rpoly(add(final[i]*monombasis[i],i=1..d),newvar, m); 
          finalf:=RDP:-phirpoly(newf,p); #The final polynomial with correct ring mod p in the recden form

          #Now, we are to construct the ring of multiple extensions
		  #npmin:=nops(phiminpoly(m,Xmin,p));
		  #phimin:=[seq(1..npmin)];
		  #for i to npmin do
          #phimin[i]:=RDP:-rpoly(phiminpoly(m,Xmin,p)[i]);
		  
		  #od;
          
         # XT:=[op(Xpoly),op(Xmin1)];
          #R1; #The characteristic of the field
         # if R1<>0 then #If the characteristic of the field <>0
         # newf:=RDP:-phirpoly(RDP:-rpoly(newf,XT),op(phimin),R1);
        #  else #If the characteristic of the field =0
         # newf:=RDP:-phirpoly(RDP:-rpoly(newf,newvar,phimin),p);
         # fi;	
          return(finalf);
       fi;
end: