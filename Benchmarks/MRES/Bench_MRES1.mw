<?xml version="1.0" encoding="UTF-8"?>
<Worksheet>
<Version major="2023" minor="0"/>
<Label-Scheme value="2" prefix=""/>
<View-Properties presentation="false" autoexpanding_sections="true" UserProfileName="Maple Default Profile" NumericFormat-ApplyInteger="true" NumericFormat-ApplyRational="true" NumericFormat-ApplyExponent="false" editable="true">
</View-Properties>
<MapleNet-Properties prettyprint="3" warnlevel="3" compactdisplay="false" preplot="" helpbrowser="standard" displayprecision="-1" echo="1" scientificx="true" unitattributes="&quot;fontweight&quot; = &quot;bold&quot;" imaginaryunit="I" longdelim="true" elisiontermsthreshold="10000" elisiondigitsafter="100" elisiondigitsbefore="100" plotdevice="inline" errorbreak="1" plotoptions="" plotdriver="opengl" quiet="false" elisiontermsbefore="100" elisiontermsafter="100" historytimestamp="false" screenwidth="79" indentamount="4" plotoutput="terminal" screenpixelheight="1200" rtablesize="[10, 10]" useclientjvm="true" format="worksheet" labelwidth="20" postplot="" typesetting="extended" ansi="false" ansicolor="[]" elisiondigitsthreshold="10000" showassumed="1" ansilprint="false" trailingsemicolon="true" errorcursor="false" labelling="true" screenheight="25" prompt="&gt; " verboseproc="1" latexwidth="8.0" ShowLabels="true"/>
<Styles>
<Font name="Heading 1" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Warning" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Output" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 4" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Line Printed Output" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 2" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="16" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Output" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Inert Output" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[144,144,144]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 3" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="14" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Diagnostic" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[40,120,40]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 1" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Input" background="[255,255,255]" bold="true" executable="true" family="Courier New" foreground="[120,0,14]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Text Output" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 2" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 3" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 4" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 5" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Annotation Title" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Header and Footer" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="HyperlinkError" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Atomic Variable" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[175,0,175]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="HyperlinkWarning" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Dictionary Hyperlink" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[147,0,15]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="2D Math" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Bullet Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Plot" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Annotation Text" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="List Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Dash Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Input" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Error" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Title" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Text" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Normal" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Caption Reference" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Code" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Input Placeholder" background="[255,255,255]" bold="true" executable="true" family="Courier New" foreground="[200,0,200]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="true"/>
<Font name="Equation Label" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Author" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Hyperlink" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,128,128]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Caption Text" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Layout name="Heading 1" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="4" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Warning" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 4" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Line Printed Output" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="any" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 2" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="2" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Maple Output" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.3" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 3" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Diagnostic" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="any" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Ordered List 1" alignment="left" bullet="numeric" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Text Output" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="newline" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Ordered List 2" alignment="left" bullet="alphabetic" firstindent="0" leftmargin="36" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Ordered List 3" alignment="left" bullet="roman" firstindent="0" leftmargin="72" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Ordered List 4" alignment="left" bullet="ALPHABETIC" firstindent="0" leftmargin="108" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Ordered List 5" alignment="left" bullet="ROMAN" firstindent="0" leftmargin="144" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Annotation Title" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="12" spacebelow="12" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="HyperlinkError" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="HyperlinkWarning" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Bullet Item" alignment="left" bullet="dot" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Maple Plot" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="List Item" alignment="left" bullet="indent" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Dash Item" alignment="left" bullet="dash" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Error" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Title" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="12" spacebelow="12" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Normal" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Author" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="8" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Pencil-style name="Pencil 1" pen-color="[0,0,0]" pen-height="1.0" pen-width="1.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 2" pen-color="[0,0,255]" pen-height="1.0" pen-width="1.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 3" pen-color="[0,0,0]" pen-height="3.0" pen-width="3.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 4" pen-color="[0,0,255]" pen-height="3.0" pen-width="3.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 5" pen-color="[255,0,0]" pen-height="5.0" pen-width="5.0" pen-opacity="1.0"/>
<Highlighter-style name="Highlighter 5" pen-color="[255,255,0]" pen-height="48.0" pen-width="48.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 3" pen-color="[51,255,0]" pen-height="24.0" pen-width="24.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 4" pen-color="[0,255,255]" pen-height="32.0" pen-width="32.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 1" pen-color="[255,153,255]" pen-height="12.0" pen-width="8.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 2" pen-color="[255,204,0]" pen-height="14.0" pen-width="14.0" pen-opacity="0.8"/>
</Styles>
<Startup-Code startupcode=""/>
<Task-table>
	<Task-category name="&lt;default&gt;"/>
</Task-table>
<Task/>
<Group hide-input="false" labelreference="L113" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">restart;
with(PolynomialTools):
interface(rtablesize=40):
with(ExcelTools):
<Font foreground="[0,128,128]">#LAMinpolyMaple file contains the LAMinpoly algorithm to get M(z).
#PhigammaMaple file maps phi_p(f1), phi_p(f2) to their corresponding polynomials in Z_p[z]/&lt;M(z)&gt; using phi_{gamma} isomorphism.
#Get contains getvars, getring,..., and conv2cons for basic operations regarding the ring and extensions
#MonOpMaple 
#ContMaple
#PGCD
#MGCD
</Font></Text-field>
</Input>
</Group>
<Group hide-input="false" labelreference="L226" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[0,128,128]">#Read subrutines</Font>
currentdir(&quot;C:/Users/mahsa/OneDrive/Documents/GitHub/Maple-Thesis-MGCD-MRES/Maple Internship/Resultant/MRES Alg&quot;):
read &quot;Get&quot;; read &quot;LAMinpolyMaple&quot;; read &quot;PhigammaMaple&quot;; read &quot;MonOpMaple&quot;;  read &quot;PRESMaple&quot;; read &quot;URESMaple&quot;; read &quot;MRES1&quot;; read &quot;MRES2&quot;; read &quot;MRES_Bench.mpl&quot;;
RDP:=Algebraic:-RecursiveDensePolynomials;</Text-field>
</Input>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUkjbWlHRiQ2JVEkUkRQRicvJSdpdGFsaWNHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ2l0YWxpY0YnLUkjbW9HRiQ2LVEpJkFzc2lnbjtGJy9GM1Enbm9ybWFsRicvJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHRj0vJSlzdHJldGNoeUdGPS8lKnN5bW1ldHJpY0dGPS8lKGxhcmdlb3BHRj0vJS5tb3ZhYmxlbGltaXRzR0Y9LyUnYWNjZW50R0Y9LyUnbHNwYWNlR1EsMC4yNzc3Nzc4ZW1GJy8lJ3JzcGFjZUdGTC1GLDYlUSpBbGdlYnJhaWNGJ0YvRjItRjY2LVEvJmNvbG9uOyZtaW51cztGJ0Y5RjtGPkZARkJGREZGRkgvRktRJjAuMGVtRicvRk5GVi1GLDYlUTpSZWN1cnNpdmVEZW5zZVBvbHlub21pYWxzRidGL0YyRjk=">LV9JLFR5cGVzZXR0aW5nRzYkJSpwcm90ZWN0ZWRHSShfc3lzbGliRzYiSSxtcHJpbnRzbGFzaEdGKDYkNyM+SSRSRFBHRihJOlJlY3Vyc2l2ZURlbnNlUG9seW5vbWlhbHNHNiQvSSttb2R1bGVuYW1lR0YoSSpBbGdlYnJhaWNHRiVGJjcjRi4=</Equation></Text-field>
</Output>
</Group>
<Group hide-input="false" labelreference="L339" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font opaque="true" size="16" background="[255,255,153]" foreground="[0,0,255]">#1</Font><Font opaque="true" background="[255,255,153]" foreground="[0,0,255]">:Number of Variables changing from 1 to 5</Font></Text-field>
</Input>
</Group>
<Group hide-input="false" labelreference="L711" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font opaque="true" background="[204,255,204]">flagalg:=MRS1; #Using RDP=Algebraic:-RecursiveDensePolynomials
</Font><Font opaque="true">vars:=</Font><Font foreground="[128,0,0]">[seq(</Font>1..4)];<Font opaque="true" background="[204,255,204]">
</Font>R:=<Font foreground="[128,0,0]">Benchmain(flagalg,vars</Font>,24,12,24,4,0);
Export(R,&quot;MRES1.xls&quot;,&quot;#var&quot;);</Text-field>
</Input>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUkjbWlHRiQ2JVEoZmxhZ2FsZ0YnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy1JI21vR0YkNi1RKSZBc3NpZ247RicvRjNRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y9LyUpc3RyZXRjaHlHRj0vJSpzeW1tZXRyaWNHRj0vJShsYXJnZW9wR0Y9LyUubW92YWJsZWxpbWl0c0dGPS8lJ2FjY2VudEdGPS8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkwtRiw2JVElTVJTMUYnRi9GMkY5">LV9JLFR5cGVzZXR0aW5nRzYkJSpwcm90ZWN0ZWRHSShfc3lzbGliRzYiSSxtcHJpbnRzbGFzaEdGKDYkNyM+SShmbGFnYWxnR0YoSSVNUlMxR0YoNyNGLg==</Equation></Text-field>
</Output>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUkjbWlHRiQ2JVEldmFyc0YnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy1JI21vR0YkNi1RKSZBc3NpZ247RicvRjNRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y9LyUpc3RyZXRjaHlHRj0vJSpzeW1tZXRyaWNHRj0vJShsYXJnZW9wR0Y9LyUubW92YWJsZWxpbWl0c0dGPS8lJ2FjY2VudEdGPS8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkwtSShtZmVuY2VkR0YkNiYtRiM2KC1JI21uR0YkNiRRIjFGJ0Y5LUY2Ni1RIixGJ0Y5RjsvRj9GMUZARkJGREZGRkgvRktRJjAuMGVtRicvRk5RLDAuMzMzMzMzM2VtRictRlU2JFEiMkYnRjkvJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnLyUpcmVhZG9ubHlHRj1GOUY5LyUlb3BlbkdRJyZsc3FiO0YnLyUmY2xvc2VHUScmcnNxYjtGJ0Y5">LV9JLFR5cGVzZXR0aW5nRzYkJSpwcm90ZWN0ZWRHSShfc3lzbGliRzYiSSxtcHJpbnRzbGFzaEdGKDYkNyM+SSV2YXJzR0YoNyQiIiIiIiM3I0Yu</Equation></Text-field>
</Output>
<Output><Text-field style="Line Printed Output" layout="Line Printed Output">MRS1
MRS1 := proc(A1, B1, x)
local count, Np, previousresult, A, B, ringA, X, Xpoly, Minpolys, i, m, n, Xmin, k,
H, prod, p, Ap, Bp, Cp, CRT, H2, test1, test2, irat, M, gama, gamma, phimatrix
  , invphimatrix, PhiAp, PhiBp, lcmintest, ca, cb, nca, ncb, C, counter, j, s,
  LA, Rand, ZD, wt, randfunction, minpolys, st, tt, laminpolytime, pgcdtime, 
  PPresult;
     |Calls Seconds  Words|
PROC |    1   0.328 3656755|
   1 |    1   0.000      0| Np := 0;
   2 |    1   0.000      0| previousresult := 0;
   3 |    1   0.000      0| PPresult := 0;
   4 |    1   0.000      0| count := 0;
   5 |    1   0.000      4| tt := time();
   6 |    1   0.000      0| laminpolytime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000   4427| A := semi(A1);
   9 |    1   0.000   3365| B := semi(B1);
  10 |    1   0.000     10| checkconsistency(A,B);
  11 |    1   0.000      0| ringA := op(1,A);
  12 |    1   0.000      0| X := op([1, 2],A);
  13 |    1   0.000      0| n := nops(X);
  14 |    1   0.000   1769| minpolys := Algebraic:-RecursiveDensePolynomials:-
                              getalgexts(A);
  15 |    1   0.000      0| m := nops(minpolys);
  16 |    1   0.000      7| Xpoly := X[1 .. n-m];
  17 |    1   0.000     31| Xmin := ListTools:-Reverse(X[n-m+1 .. n]);
  18 |    1   0.000   2335| Minpolys := map(Algebraic:-
                              RecursiveDensePolynomials:-rpoly,map(semi,
                              minpolys));
  19 |    1   0.000      0| k := nops(Xpoly);
  20 |    1   0.000      0| H := [];
  21 |    1   0.000      0| p := 2147483648;
  22 |    1   0.000      0| do
  23 |   13   0.000  12201|     do
  24 |   13   0.000   9477|         p := nextprime(p);
  25 |   13   0.000      0|         lcmintest := true;
  26 |   13   0.000      0|         for i to m do
  27 |   39   0.000    649|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false;
<Font encoding="UTF-8">  29 |    0   0.000      0|                 printf(&quot;p=%d is an lc-bad prime mi\134
                                              npoly case\134n&quot;,p)
</Font>                                        end if
                                    end do;
  30 |   13   0.000  12162|         if Algebraic:-
                                      RecursiveDensePolynomials:-rpoly
                                      (Algebraic:-
                                      RecursiveDensePolynomials:-
                                      lcrpoly(A,Xpoly)) mod p = 0 then
<Font encoding="UTF-8">  31 |    0   0.000      0|             printf(&quot;p=%d is an lc-bad prime polyno\134
                                          mial case\134n&quot;,p)
</Font>                                    end if
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  32 |   13   0.015  64569|     Ap := Algebraic:-RecursiveDensePolynomials:-
                                  phirpoly(A,p);
  33 |   13   0.000  63167|     Bp := Algebraic:-RecursiveDensePolynomials:-
                                  phirpoly(B,p);
  34 |   13   0.000  27661|     Rand := rand(1 .. p-1);
  35 |   13   0.000     39|     if nops(minpolys) = 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   13   0.000    404|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   13   0.000    741|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   13   0.000  44388|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   13   0.000     52|         st := time();
  42 |   13   0.000 365663|         LA := LAMinpoly(Minpolys,p,gamma,Xmin,X[n]
                                      );
  43 |   13   0.000    108|         laminpolytime := laminpolytime+time()-st;
  44 |   13   0.000     39|         if LA = FAIL then
<Font encoding="UTF-8">  45 |    0   0.000      0|             printf(&quot;p=%d is a det-bad prime or C=%\134
                                          a is an inappropriate list of consta\134
                                          nts\134n&quot;,p,C);
</Font>  46 |    0   0.000      0|             next
                                    end if;
  47 |   13   0.000     52|         M, phimatrix, invphimatrix := LA;
  48 |   13   0.031 318383|         PhiAp := Phi(Ap,Minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix,p);
  49 |   13   0.047 320469|         PhiBp := Phi(Bp,Minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix,p)
                                end if;
  50 |   13   0.000     52|     st := time();
  51 |   13   0.156 2137639|     Cp := traperror(PRSAlg(PhiAp,PhiBp,x,p));
  52 |   13   0.000    208|     pgcdtime := pgcdtime+time()-st;
  53 |   13   0.000     82|     if Cp = lasterror and nops([Cp]) = 2 and
                                Cp[1] = &quot;inverse does not exist&quot; then
  54 |    0   0.000      0|         ZD := Cp[2];
<Font encoding="UTF-8">  55 |    0   0.000      0|         printf(&quot;p=%d is a ZD prime ZD=%a\134n&quot;,p,ZD);
</Font>  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   13   0.000     39|     if nops(minpolys) &lt;&gt; 1 then
  59 |   13   0.063 134141|         Cp := Phi(Cp,Minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p)
                                end if;
  60 |   13   0.000     39|     if count = 0 then
  61 |    1   0.000      0|         CRT := Cp;
  62 |    1   0.000      4|         H := [Cp];
  63 |    1   0.000      0|         count := count+1
                                else
  64 |   12   0.000    159|         H := [op(H), Cp];
  65 |   12   0.016 111764|         CRT := Algebraic:-
                                      RecursiveDensePolynomials:-ichremrpoly(
                                      map(Algebraic:-RecursiveDensePolynomials
                                      :-retextsrpoly,H));
  66 |   12   0.000      0|         count := count+1
                                end if;
  67 |   13   0.000      0|     Np := Np+1;
  68 |   13   0.000  20369|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  69 |   13   0.000     39|     if irat &lt;&gt; FAIL then
  70 |    3   0.000     15|         if irat = previousresult and irat = 
                                      PPresult then
  71 |    1   0.000     12|             tt := time()-tt;
  72 |    1   0.000      4|             if timings = true then
<Font encoding="UTF-8">  73 |    0   0.000      0|                 printf(&quot;MRS: time=%.3f  LAminpoly=\134
                                              %.3f  PGCD=%.3f  Np=%d\134n&quot;,tt,
</Font>                                              laminpolytime,pgcdtime,Np)
                                        end if;
  74 |    1   0.000     12|             irat := subsop(1 = ringA,irat);
  75 |    1   0.000      5|             return [irat, Np]
                                    else
  76 |    2   0.000      0|             PPresult := previousresult;
  77 |    2   0.000      0|             previousresult := irat
                                    end if
                                end if
                            end do
end proc

MRS1
MRS1 := proc(A1, B1, x)
local count, Np, previousresult, A, B, ringA, X, Xpoly, Minpolys, i, m, n, Xmin, k,
H, prod, p, Ap, Bp, Cp, CRT, H2, test1, test2, irat, M, gama, gamma, phimatrix
  , invphimatrix, PhiAp, PhiBp, lcmintest, ca, cb, nca, ncb, C, counter, j, s,
  LA, Rand, ZD, wt, randfunction, minpolys, st, tt, laminpolytime, pgcdtime, 
  PPresult;
     |Calls Seconds  Words|
PROC |    1   0.281 2269339|
   1 |    1   0.000      0| Np := 0;
   2 |    1   0.000      0| previousresult := 0;
   3 |    1   0.000      0| PPresult := 0;
   4 |    1   0.000      0| count := 0;
   5 |    1   0.000      4| tt := time();
   6 |    1   0.000      0| laminpolytime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000   3054| A := semi(A1);
   9 |    1   0.000   3054| B := semi(B1);
  10 |    1   0.000      6| checkconsistency(A,B);
  11 |    1   0.000      0| ringA := op(1,A);
  12 |    1   0.000      0| X := op([1, 2],A);
  13 |    1   0.000      0| n := nops(X);
  14 |    1   0.000    498| minpolys := Algebraic:-RecursiveDensePolynomials:-
                              getalgexts(A);
  15 |    1   0.000      0| m := nops(minpolys);
  16 |    1   0.000      7| Xpoly := X[1 .. n-m];
  17 |    1   0.000     31| Xmin := ListTools:-Reverse(X[n-m+1 .. n]);
  18 |    1   0.000   2074| Minpolys := map(Algebraic:-
                              RecursiveDensePolynomials:-rpoly,map(semi,
                              minpolys));
  19 |    1   0.000      0| k := nops(Xpoly);
  20 |    1   0.000      0| H := [];
  21 |    1   0.000      0| p := 2147483648;
  22 |    1   0.000      0| do
  23 |   13   0.000  12194|     do
  24 |   13   0.000   1226|         p := nextprime(p);
  25 |   13   0.000      0|         lcmintest := true;
  26 |   13   0.000      0|         for i to m do
  27 |   39   0.000    640|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false;
<Font encoding="UTF-8">  29 |    0   0.000      0|                 printf(&quot;p=%d is an lc-bad prime mi\134
                                              npoly case\134n&quot;,p)
</Font>                                        end if
                                    end do;
  30 |   13   0.000  12155|         if Algebraic:-
                                      RecursiveDensePolynomials:-rpoly
                                      (Algebraic:-
                                      RecursiveDensePolynomials:-
                                      lcrpoly(A,Xpoly)) mod p = 0 then
<Font encoding="UTF-8">  31 |    0   0.000      0|             printf(&quot;p=%d is an lc-bad prime polyno\134
                                          mial case\134n&quot;,p)
</Font>                                    end if
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  32 |   13   0.000  57876|     Ap := Algebraic:-RecursiveDensePolynomials:-
                                  phirpoly(A,p);
  33 |   13   0.000  57876|     Bp := Algebraic:-RecursiveDensePolynomials:-
                                  phirpoly(B,p);
  34 |   13   0.000  27661|     Rand := rand(1 .. p-1);
  35 |   13   0.000     39|     if nops(minpolys) = 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   13   0.000    429|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   13   0.000    741|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   13   0.000  42656|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   13   0.000     52|         st := time();
  42 |   13   0.000 266535|         LA := LAMinpoly(Minpolys,p,gamma,Xmin,X[n]
                                      );
  43 |   13   0.000    108|         laminpolytime := laminpolytime+time()-st;
  44 |   13   0.000     39|         if LA = FAIL then
<Font encoding="UTF-8">  45 |    0   0.000      0|             printf(&quot;p=%d is a det-bad prime or C=%\134
                                          a is an inappropriate list of consta\134
                                          nts\134n&quot;,p,C);
</Font>  46 |    0   0.000      0|             next
                                    end if;
  47 |   13   0.000     52|         M, phimatrix, invphimatrix := LA;
  48 |   13   0.016 292987|         PhiAp := Phi(Ap,Minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix,p);
  49 |   13   0.016 294456|         PhiBp := Phi(Bp,Minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix,p)
                                end if;
  50 |   13   0.000     52|     st := time();
  51 |   13   0.202 938040|     Cp := traperror(PRSAlg(PhiAp,PhiBp,x,p));
  52 |   13   0.000    200|     pgcdtime := pgcdtime+time()-st;
  53 |   13   0.000     78|     if Cp = lasterror and nops([Cp]) = 2 and
                                Cp[1] = &quot;inverse does not exist&quot; then
  54 |    0   0.000      0|         ZD := Cp[2];
<Font encoding="UTF-8">  55 |    0   0.000      0|         printf(&quot;p=%d is a ZD prime ZD=%a\134n&quot;,p,ZD);
</Font>  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   13   0.000     39|     if nops(minpolys) &lt;&gt; 1 then
  59 |   13   0.016 132694|         Cp := Phi(Cp,Minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p)
                                end if;
  60 |   13   0.000     39|     if count = 0 then
  61 |    1   0.000      0|         CRT := Cp;
  62 |    1   0.000      4|         H := [Cp];
  63 |    1   0.000      0|         count := count+1
                                else
  64 |   12   0.000    159|         H := [op(H), Cp];
  65 |   12   0.031 103702|         CRT := Algebraic:-
                                      RecursiveDensePolynomials:-ichremrpoly(
                                      map(Algebraic:-RecursiveDensePolynomials
                                      :-retextsrpoly,H));
  66 |   12   0.000      0|         count := count+1
                                end if;
  67 |   13   0.000      0|     Np := Np+1;
  68 |   13   0.000  17799|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  69 |   13   0.000     39|     if irat &lt;&gt; FAIL then
  70 |    3   0.000     15|         if irat = previousresult and irat = 
                                      PPresult then
  71 |    1   0.000     12|             tt := time()-tt;
  72 |    1   0.000      0|             if timings = true then
<Font encoding="UTF-8">  73 |    0   0.000      0|                 printf(&quot;MRS: time=%.3f  LAminpoly=\134
                                              %.3f  PGCD=%.3f  Np=%d\134n&quot;,tt,
</Font>                                              laminpolytime,pgcdtime,Np)
                                        end if;
  74 |    1   0.000     12|             irat := subsop(1 = ringA,irat);
  75 |    1   0.000      5|             return [irat, Np]
                                    else
  76 |    2   0.000      0|             PPresult := previousresult;
  77 |    2   0.000      0|             previousresult := irat
                                    end if
                                end if
                            end do
end proc

MRS1
MRS1 := proc(A1, B1, x)
local count, Np, previousresult, A, B, ringA, X, Xpoly, Minpolys, i, m, n, Xmin, k,
H, prod, p, Ap, Bp, Cp, CRT, H2, test1, test2, irat, M, gama, gamma, phimatrix
  , invphimatrix, PhiAp, PhiBp, lcmintest, ca, cb, nca, ncb, C, counter, j, s,
  LA, Rand, ZD, wt, randfunction, minpolys, st, tt, laminpolytime, pgcdtime, 
  PPresult;
     |Calls Seconds  Words|
PROC |    1   0.109 1154288|
   1 |    1   0.000      0| Np := 0;
   2 |    1   0.000      0| previousresult := 0;
   3 |    1   0.000      0| PPresult := 0;
   4 |    1   0.000      0| count := 0;
   5 |    1   0.000      4| tt := time();
   6 |    1   0.000      0| laminpolytime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000   2121| A := semi(A1);
   9 |    1   0.000   2121| B := semi(B1);
  10 |    1   0.000      6| checkconsistency(A,B);
  11 |    1   0.000      0| ringA := op(1,A);
  12 |    1   0.000      0| X := op([1, 2],A);
  13 |    1   0.000      0| n := nops(X);
  14 |    1   0.000    498| minpolys := Algebraic:-RecursiveDensePolynomials:-
                              getalgexts(A);
  15 |    1   0.000      0| m := nops(minpolys);
  16 |    1   0.000      7| Xpoly := X[1 .. n-m];
  17 |    1   0.000     31| Xmin := ListTools:-Reverse(X[n-m+1 .. n]);
  18 |    1   0.000   2074| Minpolys := map(Algebraic:-
                              RecursiveDensePolynomials:-rpoly,map(semi,
                              minpolys));
  19 |    1   0.000      0| k := nops(Xpoly);
  20 |    1   0.000      0| H := [];
  21 |    1   0.000      0| p := 2147483648;
  22 |    1   0.000      0| do
  23 |    9   0.000   8442|     do
  24 |    9   0.000    930|         p := nextprime(p);
  25 |    9   0.000      0|         lcmintest := true;
  26 |    9   0.000      0|         for i to m do
  27 |   27   0.000    443|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false;
<Font encoding="UTF-8">  29 |    0   0.000      0|                 printf(&quot;p=%d is an lc-bad prime mi\134
                                              npoly case\134n&quot;,p)
</Font>                                        end if
                                    end do;
  30 |    9   0.000   8415|         if Algebraic:-
                                      RecursiveDensePolynomials:-rpoly
                                      (Algebraic:-
                                      RecursiveDensePolynomials:-
                                      lcrpoly(A,Xpoly)) mod p = 0 then
<Font encoding="UTF-8">  31 |    0   0.000      0|             printf(&quot;p=%d is an lc-bad prime polyno\134
                                          mial case\134n&quot;,p)
</Font>                                    end if
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  32 |    9   0.016  29079|     Ap := Algebraic:-RecursiveDensePolynomials:-
                                  phirpoly(A,p);
  33 |    9   0.015  29079|     Bp := Algebraic:-RecursiveDensePolynomials:-
                                  phirpoly(B,p);
  34 |    9   0.000  19159|     Rand := rand(1 .. p-1);
  35 |    9   0.000     27|     if nops(minpolys) = 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |    9   0.000    317|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |    9   0.000    513|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |    9   0.000  29439|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |    9   0.000     36|         st := time();
  42 |    9   0.000 184342|         LA := LAMinpoly(Minpolys,p,gamma,Xmin,X[n]
                                      );
  43 |    9   0.000     76|         laminpolytime := laminpolytime+time()-st;
  44 |    9   0.000     27|         if LA = FAIL then
<Font encoding="UTF-8">  45 |    0   0.000      0|             printf(&quot;p=%d is a det-bad prime or C=%\134
                                          a is an inappropriate list of consta\134
                                          nts\134n&quot;,p,C);
</Font>  46 |    0   0.000      0|             next
                                    end if;
  47 |    9   0.000     36|         M, phimatrix, invphimatrix := LA;
  48 |    9   0.000 149155|         PhiAp := Phi(Ap,Minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix,p);
  49 |    9   0.016 149462|         PhiBp := Phi(Bp,Minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix,p)
                                end if;
  50 |    9   0.000     36|     st := time();
  51 |    9   0.047 385902|     Cp := traperror(PRSAlg(PhiAp,PhiBp,x,p));
  52 |    9   0.000    112|     pgcdtime := pgcdtime+time()-st;
  53 |    9   0.000     54|     if Cp = lasterror and nops([Cp]) = 2 and
                                Cp[1] = &quot;inverse does not exist&quot; then
  54 |    0   0.000      0|         ZD := Cp[2];
<Font encoding="UTF-8">  55 |    0   0.000      0|         printf(&quot;p=%d is a ZD prime ZD=%a\134n&quot;,p,ZD);
</Font>  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |    9   0.000     27|     if nops(minpolys) &lt;&gt; 1 then
  59 |    9   0.015  91723|         Cp := Phi(Cp,Minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p)
                                end if;
  60 |    9   0.000     27|     if count = 0 then
  61 |    1   0.000      0|         CRT := Cp;
  62 |    1   0.000      4|         H := [Cp];
  63 |    1   0.000      0|         count := count+1
                                else
  64 |    8   0.000     89|         H := [op(H), Cp];
  65 |    8   0.000  46812|         CRT := Algebraic:-
                                      RecursiveDensePolynomials:-ichremrpoly(
                                      map(Algebraic:-RecursiveDensePolynomials
                                      :-retextsrpoly,H));
  66 |    8   0.000      0|         count := count+1
                                end if;
  67 |    9   0.000      0|     Np := Np+1;
  68 |    9   0.000  13592|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  69 |    9   0.000     27|     if irat &lt;&gt; FAIL then
  70 |    3   0.000     15|         if irat = previousresult and irat = 
                                      PPresult then
  71 |    1   0.000     12|             tt := time()-tt;
  72 |    1   0.000      0|             if timings = true then
<Font encoding="UTF-8">  73 |    0   0.000      0|                 printf(&quot;MRS: time=%.3f  LAminpoly=\134
                                              %.3f  PGCD=%.3f  Np=%d\134n&quot;,tt,
</Font>                                              laminpolytime,pgcdtime,Np)
                                        end if;
  74 |    1   0.000     12|             irat := subsop(1 = ringA,irat);
  75 |    1   0.000      5|             return [irat, Np]
                                    else
  76 |    2   0.000      0|             PPresult := previousresult;
  77 |    2   0.000      0|             previousresult := irat
                                    end if
                                end if
                            end do
end proc

MRS1
MRS1 := proc(A1, B1, x)
local count, Np, previousresult, A, B, ringA, X, Xpoly, Minpolys, i, m, n, Xmin, k,
H, prod, p, Ap, Bp, Cp, CRT, H2, test1, test2, irat, M, gama, gamma, phimatrix
  , invphimatrix, PhiAp, PhiBp, lcmintest, ca, cb, nca, ncb, C, counter, j, s,
  LA, Rand, ZD, wt, randfunction, minpolys, st, tt, laminpolytime, pgcdtime, 
  PPresult;
     |Calls Seconds  Words|
PROC |    1   0.047 445104|
   1 |    1   0.000      0| Np := 0;
   2 |    1   0.000      0| previousresult := 0;
   3 |    1   0.000      0| PPresult := 0;
   4 |    1   0.000      0| count := 0;
   5 |    1   0.000      4| tt := time();
   6 |    1   0.000      0| laminpolytime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000   1188| A := semi(A1);
   9 |    1   0.000   1188| B := semi(B1);
  10 |    1   0.000      6| checkconsistency(A,B);
  11 |    1   0.000      0| ringA := op(1,A);
  12 |    1   0.000      0| X := op([1, 2],A);
  13 |    1   0.000      0| n := nops(X);
  14 |    1   0.000    498| minpolys := Algebraic:-RecursiveDensePolynomials:-
                              getalgexts(A);
  15 |    1   0.000      0| m := nops(minpolys);
  16 |    1   0.000      7| Xpoly := X[1 .. n-m];
  17 |    1   0.000     31| Xmin := ListTools:-Reverse(X[n-m+1 .. n]);
  18 |    1   0.000   2074| Minpolys := map(Algebraic:-
                              RecursiveDensePolynomials:-rpoly,map(semi,
                              minpolys));
  19 |    1   0.000      0| k := nops(Xpoly);
  20 |    1   0.000      0| H := [];
  21 |    1   0.000      0| p := 2147483648;
  22 |    1   0.000      0| do
  23 |    5   0.000   4690|     do
  24 |    5   0.000    557|         p := nextprime(p);
  25 |    5   0.000      0|         lcmintest := true;
  26 |    5   0.000      0|         for i to m do
  27 |   15   0.000    251|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false;
<Font encoding="UTF-8">  29 |    0   0.000      0|                 printf(&quot;p=%d is an lc-bad prime mi\134
                                              npoly case\134n&quot;,p)
</Font>                                        end if
                                    end do;
  30 |    5   0.000   4675|         if Algebraic:-
                                      RecursiveDensePolynomials:-rpoly
                                      (Algebraic:-
                                      RecursiveDensePolynomials:-
                                      lcrpoly(A,Xpoly)) mod p = 0 then
<Font encoding="UTF-8">  31 |    0   0.000      0|             printf(&quot;p=%d is an lc-bad prime polyno\134
                                          mial case\134n&quot;,p)
</Font>                                    end if
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  32 |    5   0.000  10050|     Ap := Algebraic:-RecursiveDensePolynomials:-
                                  phirpoly(A,p);
  33 |    5   0.000  10050|     Bp := Algebraic:-RecursiveDensePolynomials:-
                                  phirpoly(B,p);
  34 |    5   0.000  10654|     Rand := rand(1 .. p-1);
  35 |    5   0.000     15|     if nops(minpolys) = 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |    5   0.000    185|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |    5   0.000    285|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |    5   0.000  16384|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |    5   0.000     20|         st := time();
  42 |    5   0.016 102457|         LA := LAMinpoly(Minpolys,p,gamma,Xmin,X[n]
                                      );
  43 |    5   0.000     48|         laminpolytime := laminpolytime+time()-st;
  44 |    5   0.000     15|         if LA = FAIL then
<Font encoding="UTF-8">  45 |    0   0.000      0|             printf(&quot;p=%d is a det-bad prime or C=%\134
                                          a is an inappropriate list of consta\134
                                          nts\134n&quot;,p,C);
</Font>  46 |    0   0.000      0|             next
                                    end if;
  47 |    5   0.000     20|         M, phimatrix, invphimatrix := LA;
  48 |    5   0.016  55179|         PhiAp := Phi(Ap,Minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix,p);
  49 |    5   0.000  55326|         PhiBp := Phi(Bp,Minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix,p)
                                end if;
  50 |    5   0.000     20|     st := time();
  51 |    5   0.015  94720|     Cp := traperror(PRSAlg(PhiAp,PhiBp,x,p));
  52 |    5   0.000     64|     pgcdtime := pgcdtime+time()-st;
  53 |    5   0.000     30|     if Cp = lasterror and nops([Cp]) = 2 and
                                Cp[1] = &quot;inverse does not exist&quot; then
  54 |    0   0.000      0|         ZD := Cp[2];
<Font encoding="UTF-8">  55 |    0   0.000      0|         printf(&quot;p=%d is a ZD prime ZD=%a\134n&quot;,p,ZD);
</Font>  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |    5   0.000     15|     if nops(minpolys) &lt;&gt; 1 then
  59 |    5   0.000  50846|         Cp := Phi(Cp,Minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p)
                                end if;
  60 |    5   0.000     15|     if count = 0 then
  61 |    1   0.000      0|         CRT := Cp;
  62 |    1   0.000      4|         H := [Cp];
  63 |    1   0.000      0|         count := count+1
                                else
  64 |    4   0.000     35|         H := [op(H), Cp];
  65 |    4   0.000  12083|         CRT := Algebraic:-
                                      RecursiveDensePolynomials:-ichremrpoly(
                                      map(Algebraic:-RecursiveDensePolynomials
                                      :-retextsrpoly,H));
  66 |    4   0.000      0|         count := count+1
                                end if;
  67 |    5   0.000      0|     Np := Np+1;
  68 |    5   0.000  11356|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  69 |    5   0.000     15|     if irat &lt;&gt; FAIL then
  70 |    3   0.000     15|         if irat = previousresult and irat = 
                                      PPresult then
  71 |    1   0.000     12|             tt := time()-tt;
  72 |    1   0.000      0|             if timings = true then
<Font encoding="UTF-8">  73 |    0   0.000      0|                 printf(&quot;MRS: time=%.3f  LAminpoly=\134
                                              %.3f  PGCD=%.3f  Np=%d\134n&quot;,tt,
</Font>                                              laminpolytime,pgcdtime,Np)
                                        end if;
  74 |    1   0.000     12|             irat := subsop(1 = ringA,irat);
  75 |    1   0.000      5|             return [irat, Np]
                                    else
  76 |    2   0.000      0|             PPresult := previousresult;
  77 |    2   0.000      0|             previousresult := irat
                                    end if
                                end if
                            end do
end proc

MRS1
MRS1 := proc(A1, B1, x)
local count, Np, previousresult, A, B, ringA, X, Xpoly, Minpolys, i, m, n, Xmin, k,
H, prod, p, Ap, Bp, Cp, CRT, H2, test1, test2, irat, M, gama, gamma, phimatrix
  , invphimatrix, PhiAp, PhiBp, lcmintest, ca, cb, nca, ncb, C, counter, j, s,
  LA, Rand, ZD, wt, randfunction, minpolys, st, tt, laminpolytime, pgcdtime, 
  PPresult;
     |Calls Seconds  Words|
PROC |    1  56.500 550329337|
   1 |    1   0.000      0| Np := 0;
   2 |    1   0.000      0| previousresult := 0;
   3 |    1   0.000      0| PPresult := 0;
   4 |    1   0.000      0| count := 0;
   5 |    1   0.000      4| tt := time();
   6 |    1   0.000      0| laminpolytime := 0;
   7 |    1   0.000      0| pgcdtime := 0;
   8 |    1   0.000  32365| A := semi(A1);
   9 |    1   0.015  32365| B := semi(B1);
  10 |    1   0.000      6| checkconsistency(A,B);
  11 |    1   0.000      0| ringA := op(1,A);
  12 |    1   0.000      0| X := op([1, 2],A);
  13 |    1   0.000      0| n := nops(X);
  14 |    1   0.000    498| minpolys := Algebraic:-RecursiveDensePolynomials:-
                              getalgexts(A);
  15 |    1   0.000      0| m := nops(minpolys);
  16 |    1   0.000      8| Xpoly := X[1 .. n-m];
  17 |    1   0.000     31| Xmin := ListTools:-Reverse(X[n-m+1 .. n]);
  18 |    1   0.000   2074| Minpolys := map(Algebraic:-
                              RecursiveDensePolynomials:-rpoly,map(semi,
                              minpolys));
  19 |    1   0.000      0| k := nops(Xpoly);
  20 |    1   0.000      0| H := [];
  21 |    1   0.000      0| p := 2147483648;
  22 |    1   0.000      0| do
  23 |   16   0.000  15072|     do
  24 |   16   0.000   2788|         p := nextprime(p);
  25 |   16   0.000      0|         lcmintest := true;
  26 |   16   0.000      0|         for i to m do
  27 |   48   0.000    854|             if den(minpolys[i]) mod p = 0 then
  28 |    0   0.000      0|                 lcmintest := false;
<Font encoding="UTF-8">  29 |    0   0.000      0|                 printf(&quot;p=%d is an lc-bad prime mi\134
                                              npoly case\134n&quot;,p)
</Font>                                        end if
                                    end do;
  30 |   16   0.000  15024|         if Algebraic:-
                                      RecursiveDensePolynomials:-rpoly
                                      (Algebraic:-
                                      RecursiveDensePolynomials:-
                                      lcrpoly(A,Xpoly)) mod p = 0 then
<Font encoding="UTF-8">  31 |    0   0.000      0|             printf(&quot;p=%d is an lc-bad prime polyno\134
                                          mial case\134n&quot;,p)
</Font>                                    end if
                                until Algebraic:-RecursiveDensePolynomials:-rpoly(
                                  Algebraic:-RecursiveDensePolynomials:-
                                  lcrpoly(A,Xpoly)) mod p &lt;&gt; 0 and lcmintest =
                                  true;
  32 |   16   0.077 672944|     Ap := Algebraic:-RecursiveDensePolynomials:-
                                  phirpoly(A,p);
  33 |   16   0.124 672944|     Bp := Algebraic:-RecursiveDensePolynomials:-
                                  phirpoly(B,p);
  34 |   16   0.000  34122|     Rand := rand(1 .. p-1);
  35 |   16   0.000     48|     if nops(minpolys) = 1 then
  36 |    0   0.000      0|         PhiAp := Ap;
  37 |    0   0.000      0|         PhiBp := Bp
                                else
  38 |   16   0.000    518|         C := [seq(Rand(),i = 1 .. m-1)];
  39 |   16   0.000    912|         gama := Xmin[1]+add(C[i]*Xmin[i+1],i = 1
                                      .. m-1);
  40 |   16   0.000  52336|         gamma := Algebraic:-
                                      RecursiveDensePolynomials:-phirpoly(
                                      Algebraic:-RecursiveDensePolynomials:-
                                      rpoly(gama,Algebraic:-
                                      RecursiveDensePolynomials:-getcofring(A)
                                      ),p);
  41 |   16   0.000     64|         st := time();
  42 |   16   0.016 327654|         LA := LAMinpoly(Minpolys,p,gamma,Xmin,X[n]
                                      );
  43 |   16   0.000    136|         laminpolytime := laminpolytime+time()-st;
  44 |   16   0.000     48|         if LA = FAIL then
<Font encoding="UTF-8">  45 |    0   0.000      0|             printf(&quot;p=%d is a det-bad prime or C=%\134
                                          a is an inappropriate list of consta\134
                                          nts\134n&quot;,p,C);
</Font>  46 |    0   0.000      0|             next
                                    end if;
  47 |   16   0.000     64|         M, phimatrix, invphimatrix := LA;
  48 |   16   0.267 3989868|         PhiAp := Phi(Ap,Minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix,p);
  49 |   16   0.282 3983804|         PhiBp := Phi(Bp,Minpolys,Xmin,Xpoly,1,M,
                                      phimatrix,invphimatrix,p)
                                end if;
  50 |   16   0.000     64|     st := time();
  51 |   16  51.843 516239121|     Cp := traperror(PRSAlg(PhiAp,PhiBp,x,p));
  52 |   16   0.000    256|     pgcdtime := pgcdtime+time()-st;
  53 |   16   0.000     96|     if Cp = lasterror and nops([Cp]) = 2 and
                                Cp[1] = &quot;inverse does not exist&quot; then
  54 |    0   0.000      0|         ZD := Cp[2];
<Font encoding="UTF-8">  55 |    0   0.000      0|         printf(&quot;p=%d is a ZD prime ZD=%a\134n&quot;,p,ZD);
</Font>  56 |    0   0.000      0|         next
                                elif Cp = lasterror then
  57 |    0   0.000      0|         error lasterror
                                end if;
  58 |   16   0.000     48|     if nops(minpolys) &lt;&gt; 1 then
  59 |   16   0.860 8615663|         Cp := Phi(Cp,Minpolys,Xmin,Xpoly,-1,M,
                                      phimatrix,invphimatrix,p)
                                end if;
  60 |   16   0.000     48|     if count = 0 then
  61 |    1   0.000      0|         CRT := Cp;
  62 |    1   0.000      4|         H := [Cp];
  63 |    1   0.000      0|         count := count+1
                                else
  64 |   15   0.000    222|         H := [op(H), Cp];
  65 |   15   2.782 14007096|         CRT := Algebraic:-
                                      RecursiveDensePolynomials:-ichremrpoly(
                                      map(Algebraic:-RecursiveDensePolynomials
                                      :-retextsrpoly,H));
  66 |   15   0.000      0|         count := count+1
                                end if;
  67 |   16   0.000      0|     Np := Np+1;
  68 |   16   0.234 1630076|     irat := Algebraic:-RecursiveDensePolynomials:-
                                  irrrpoly(CRT);
  69 |   16   0.000     48|     if irat &lt;&gt; FAIL then
  70 |    3   0.000     15|         if irat = previousresult and irat = 
                                      PPresult then
  71 |    1   0.000     12|             tt := time()-tt;
  72 |    1   0.000      0|             if timings = true then
<Font encoding="UTF-8">  73 |    0   0.000      0|                 printf(&quot;MRS: time=%.3f  LAminpoly=\134
                                              %.3f  PGCD=%.3f  Np=%d\134n&quot;,tt,
</Font>                                              laminpolytime,pgcdtime,Np)
                                        end if;
  74 |    1   0.000     12|             irat := subsop(1 = ringA,irat);
  75 |    1   0.000      5|             return [irat, Np]
                                    else
  76 |    2   0.000      0|             PPresult := previousresult;
  77 |    2   0.000      0|             previousresult := irat
                                    end if
                                end if
                            end do
end proc

</Text-field>
</Output>
</Group>
<Group hide-input="false" labelreference="L709" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font opaque="true" size="16" background="[255,255,153]" foreground="[0,0,255]">#2: </Font><Font opaque="true" background="[255,255,153]" foreground="[0,0,128]">Total degree of the polynomials are changing from 1 to 15
</Font><Font opaque="true" foreground="[0,0,128]">tdeg:=</Font><Font opaque="true" foreground="[128,0,0]">[4,</Font><Font foreground="[128,0,0]">6,8,10,12,16,20,24,28,32,36,40</Font>]<Font opaque="true" background="[255,255,153]" foreground="[0,0,128]">
</Font>R:=<Font foreground="[128,0,0]">Benchmain(flagalg,2</Font>,tdeg,10,24,4,0);
Export(R,&quot;MRES1.xls&quot;,&quot;Tdeg&quot;);
</Text-field>
</Input>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUkjbWlHRiQ2JVEoZmxhZ2FsZ0YnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy1JI21vR0YkNi1RKSZBc3NpZ247RicvRjNRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y9LyUpc3RyZXRjaHlHRj0vJSpzeW1tZXRyaWNHRj0vJShsYXJnZW9wR0Y9LyUubW92YWJsZWxpbWl0c0dGPS8lJ2FjY2VudEdGPS8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkwtRiw2JVEoTUdDREFsZ0YnRi9GMkY5">QyQ+SShmbGFnYWxnRzYiSShNR0NEQWxnR0YlUS1fbm90ZXJtaW5hdGVGJQ==</Equation></Text-field>
</Output>
</Group>
<Group hide-input="false" labelreference="L704" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font opaque="true" size="16" background="[255,255,153]" foreground="[0,0,255]">#3 </Font><Font opaque="true" background="[255,255,153]" foreground="[0,0,128]">Degree of the field is in [4,8,12,16,24,32,64,72] with max number of extensions</Font>
dF:<Font opaque="true" foreground="[128,0,0]">=[4,8,12,16,24,32,64,72];
</Font>R:=<Font foreground="[128,0,0]">Benchmain(flagalg,2</Font>,24,12,dF,numext,0);
Export(R,&quot;MRES1.xls&quot;,&quot;dF&quot;);<Font opaque="true" foreground="[128,0,0]">
</Font></Text-field>
</Input>
</Group>
<Group hide-input="false" labelreference="L706" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font opaque="true" size="16" background="[255,255,153]" foreground="[0,0,255]">#4 </Font><Font opaque="true" background="[255,255,153]" foreground="[0,0,128]">Number of extensions for a field of degree 64 is changing from 1..6 
</Font>R:=<Font foreground="[128,0,0]">Benchmain(flagalg,2</Font>,24,12,64,[seq(1..6)],0);
Export(R,&quot;MRES1.xls&quot;,&quot;#exts&quot;);</Text-field>
</Input>
</Group>
<Group hide-input="false" labelreference="L730" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
</Worksheet>