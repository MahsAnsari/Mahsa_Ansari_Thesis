#The isomorphism phi

#with(PolynomialTools):
#with(ArrayTools):
#with(RandomTools):
#phi : L=Q(a1,..an)---->K=Q(gamma) is an isomorhism from Q[x1,..xn]/<m1,..mn> to Q[z]/<m(z)>. If  we want to call phi, then flag:=1 else if we want to call phi^(-1) then flag:=-1 
#X is the list of minimal polynomials' variables 
#If we call phi then the minpoly of the single extension is w.r.t Z:=op(indets(M)
#If we call phi^(-1) then we need to have the variable of the single extension
#Inputs: the polynomial f1, m=[m1,..mn]=list of minimal polynomials from Q[x1,..xn]/<m1,..mn>,Xmin=minimal polynomials' variables,  Xpoly=polynomial's variables, flag=1 or -1, gama,M,A,Ainv= The out puts of LAMinpoly
Phi:=proc(f1,m,Xmin,Xpoly,flag,M,A,Ainv)  
uses RDP=Algebraic:-RecursiveDensePolynomials, LA=LinearAlgebra;
   local npmin,n,Z,deg,d,monombasis,F,final,newf,i,basis2,f,fmin,Ringfmin,Ring,p,R2,R3,R33,Rfinal,R, phimin,XT,Xmin1,Rf,newvar, finalf;
        #The variable of the single extension's minimal polynomial
        Z:=op(indets(M));
        Ring:=getring(f1);
        #The characteristic of the field
        p:=op(1,Ring);
        n:=nops(m); #nops(m)=nops(X)
        deg:=[seq(degree(m[i],Xmin[i]),i=1..n)];
        d:=degree(M);   #d:=mul(deg[i],i=1..n);
        monombasis:= Basemaker(Xmin,deg); #set it as an input
        f:=Expand(RDP:-rpoly(f1)) mod p;
        if flag=1 then #we want to calculate Phi(f) so f is in L and we need Ainv 
           R2:=[op(Xpoly),Z];
           fmin:=RDP:-phirpoly(RDP:-phirpoly(RDP:-rpoly(1,Z),RDP:-rpoly(M,[Z])),p);   #Get the RECDEN format of the minimal polynomial M
           Ringfmin:=getring(fmin); 
           R33:=[op(1,op(3,Ringfmin))]; #This is the Minpoly of single extension in recden version [[],[],[]]
           Rfinal:=[p,R2,R33];  #The ring of single extension is Rfinal
           F:= Monomlist(f,monombasis,Xmin);
           final:=Ainv.F mod p;
           #write the final result as a polyomial w.r.t Z in Q[Z]/<m(Z)> 
           newf:=add(final[i]*Z^(i-1),i=1...d);
           return RDP:-rpoly(newf,Rfinal); 
       elif flag=-1 then #We want to call phi^(-1)
      #Note: Every two bases of a vector space have the same cardinality. Hence, if the base of Q[x,y]/<m1,m2> has d items then the basis of Q[z]/<m(z)> has d items too. Remember these two vector spaces are isomorphic.
      #When we call phi^(-1) we have a polynomial over Q[Z]/<m(Z)> and we want to map it to the corresponding polynomial in Q[x,y]/<m1,m2>
      #write f w.r.t the basis ord:=[1,Z,Z^2,..,Z^(d-1)] of Q[Z]/<m(Z)> where deg(M(Z))=d
          basis2:=Array(1..d);
          for i to d do
             basis2[i]:=Z^(i-1); #A basis for the single extension Q[Z]/<M(Z)>
          od;
          F:=Monomlist(f,basis2,Z); #The coordinate of f relative to basis2
          final:=A.F mod p;
	  	    Xmin1:= [ seq( Xmin[-i], i=1..nops(Xmin) ) ]; 
		    newvar:=[op(Xpoly),op(Xmin1)]; #The variables [Xpoly,Xmin]
          newf:=RDP:-rpoly(add(final[i]*monombasis[i],i=1..d),newvar, m); 
          finalf:=RDP:-phirpoly(newf,p); #The final polynomial with correct ring mod p in the recden form
          return(finalf);
       fi;
end: